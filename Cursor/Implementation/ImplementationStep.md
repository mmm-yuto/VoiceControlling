# VO!CE Paint Battle å®Ÿè£…æ‰‹é †æ›¸

## ğŸ¯ è¨­è¨ˆåŸå‰‡ï¼šå¤‰æ›´ã—ã‚„ã™ã„å®Ÿè£…

### åŸºæœ¬æ–¹é‡
å…¨ã¦ã®å®Ÿè£…ã«ãŠã„ã¦ã€**è¨­å®šå¤‰æ›´ãƒ»æ©Ÿèƒ½è¿½åŠ ãƒ»ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ã‚’å®¹æ˜“ã«ã™ã‚‹**ã“ã¨ã‚’æœ€å„ªå…ˆã¨ã—ã¾ã™ã€‚

### 1. ScriptableObjectã«ã‚ˆã‚‹è¨­å®šç®¡ç†
**ç›®çš„**: ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã›ãšã«Inspectorã§è¨­å®šã‚’èª¿æ•´å¯èƒ½ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- ã‚²ãƒ¼ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå¡—ã‚Šå¼·åº¦ã€æ”»æ’ƒåˆ¤å®šé–¾å€¤ã€ãƒãƒƒãƒæ™‚é–“ãªã©ï¼‰ã¯å…¨ã¦ScriptableObjectã§ç®¡ç†
- ãƒ—ãƒ¬ãƒãƒ–ã‚„ã‚·ãƒ¼ãƒ³ã«ç›´æ¥å€¤ã‚’æ›¸ã‹ãªã„
- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¤‡æ•°ä½œæˆã—ã€ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«ã™ã‚‹

**ä¾‹**:
```
Assets/ScriptableObjects/
â”œâ”€â”€ GameSettings.asset          // åŸºæœ¬ã‚²ãƒ¼ãƒ è¨­å®š
â”œâ”€â”€ PaintSettings.asset         // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ è¨­å®š
â”œâ”€â”€ AttackSettings.asset        // æ”»æ’ƒã‚¿ã‚¤ãƒ—è¨­å®š
â””â”€â”€ BalancePresets/             // ãƒãƒ©ãƒ³ã‚¹ãƒ—ãƒªã‚»ãƒƒãƒˆ
    â”œâ”€â”€ FastPaced.asset
    â”œâ”€â”€ Strategic.asset
    â””â”€â”€ Casual.asset
```

### 2. ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
**ç›®çš„**: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“ã®çµåˆã‚’ç·©ãã—ã€æ©Ÿèƒ½è¿½åŠ ã‚’å®¹æ˜“ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- UnityEventã‚„C#ã®Action/Eventã‚’ä½¿ç”¨
- ç›´æ¥å‚ç…§ã§ã¯ãªãã€ã‚¤ãƒ™ãƒ³ãƒˆã§é€šä¿¡
- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã«ã™ã‚‹

**ä¾‹**:
```csharp
// å¡—ã‚Šã‚¤ãƒ™ãƒ³ãƒˆ
public static event Action<Vector2, int, float> OnPaint;
// æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
public static event Action<AttackType> OnAttackTypeChanged;
// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ã‚³ã‚¢æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆ
public static event Action<int, float> OnScoreUpdated;
```

### 3. ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹/æŠ½è±¡ã‚¯ãƒ©ã‚¹ã®æ´»ç”¨
**ç›®çš„**: å®Ÿè£…ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«ã—ã€æ‹¡å¼µæ€§ã‚’é«˜ã‚ã‚‹

**å®Ÿè£…æ–¹é‡**:
- æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šã€å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã€AIè¡Œå‹•ãªã©ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–
- æ–°ã—ã„æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚„AIè¡Œå‹•ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã ã‘

**ä¾‹**:
```csharp
// æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
public interface IAttackTypeDetector
{
    AttackType DetectAttackType(float volume, float pitch, float deltaTime);
}

// å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
public interface IPaintStrategy
{
    void Paint(Vector2 position, int playerId, float intensity);
}
```

### 4. ãƒ‡ãƒ¼ã‚¿ã¨ãƒ­ã‚¸ãƒƒã‚¯ã®åˆ†é›¢
**ç›®çš„**: ãƒãƒ©ãƒ³ã‚¹èª¿æ•´æ™‚ã«ãƒ­ã‚¸ãƒƒã‚¯ã‚’è§¦ã‚‰ãšã«æ¸ˆã‚€ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- è¨ˆç®—å¼ã®ä¿‚æ•°ã‚„é–¾å€¤ã¯å…¨ã¦ScriptableObjectã«
- ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã™ã‚‹ã ã‘
- è¨ˆç®—å¼è‡ªä½“ã‚‚è¨­å®šå¯èƒ½ã«ã™ã‚‹ï¼ˆä¾‹: AnimationCurveï¼‰

### 5. Inspectorã§èª¿æ•´å¯èƒ½ãªè¨­è¨ˆ
**ç›®çš„**: ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ã§ãªãã¦ã‚‚èª¿æ•´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- å…¨ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«`[Header]`ã€`[Tooltip]`ã‚’ä»˜ã‘ã‚‹
- ç¯„å›²åˆ¶é™`[Range(min, max)]`ã‚’ä½¿ç”¨
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’é©åˆ‡ã«è¨­å®š

### 6. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã¨ä¾å­˜æ€§ã®æœ€å°åŒ–
**ç›®çš„**: ä¸€éƒ¨ã®å¤‰æ›´ãŒä»–ã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- å„ã‚·ã‚¹ãƒ†ãƒ ã¯ç‹¬ç«‹ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã—ã¦å®Ÿè£…
- ä¾å­˜é–¢ä¿‚ã¯æ˜ç¤ºçš„ã«ï¼ˆInspectorã§æ¥ç¶šã€ã¾ãŸã¯Service Locatorãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã¯æœ€å°é™ã«

### 7. ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã®æŸ”è»Ÿæ€§
**ç›®çš„**: è¦‹ãŸç›®ã‚’ç°¡å˜ã«å¤‰æ›´ãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æŠ½è±¡åŒ–**: `IInkEffect`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè£…ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ãƒãƒ†ãƒªã‚¢ãƒ«ç®¡ç†**: `InkMaterialData`ï¼ˆScriptableObjectï¼‰ã§ãƒãƒ†ãƒªã‚¢ãƒ«ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€è‰²ã‚’ç®¡ç†
- **ãƒ—ãƒ¬ãƒãƒ–ãƒ™ãƒ¼ã‚¹**: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ¬ãƒãƒ–åŒ–ã—ã€Inspectorã§å·®ã—æ›¿ãˆå¯èƒ½ã«
- **å‹•çš„å¤‰æ›´**: å®Ÿè¡Œä¸­ã«ãƒãƒ†ãƒªã‚¢ãƒ«ã‚„è‰²ã‚’å¤‰æ›´ã§ãã‚‹APIã‚’æä¾›
- **ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å¯¾å¿œ**: Built-in/URP/HDRPã«å¯¾å¿œã§ãã‚‹è¨­è¨ˆ
- **ãƒ†ãƒ¼ãƒã‚·ã‚¹ãƒ†ãƒ **: UIãƒ†ãƒ¼ãƒã‚„ã‚¤ãƒ³ã‚¯ãƒ†ãƒ¼ãƒã‚’ScriptableObjectã§ç®¡ç†

**ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯è¨­å®šã®æ§‹é€ **:
```
Assets/ScriptableObjects/Graphics/
â”œâ”€â”€ InkEffectSettings.asset        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š
â”œâ”€â”€ InkMaterialData.asset          // ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
â”œâ”€â”€ PlayerColorTheme.asset         // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²ãƒ†ãƒ¼ãƒ
â”œâ”€â”€ UISettings.asset               // UIè¨­å®š
â””â”€â”€ Themes/                        // ãƒ†ãƒ¼ãƒãƒ—ãƒªã‚»ãƒƒãƒˆ
    â”œâ”€â”€ DefaultTheme.asset
    â”œâ”€â”€ NeonTheme.asset
    â””â”€â”€ PaintTheme.asset
```

---

## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²

### ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²ã®åŸºæœ¬æ–¹é‡

**åˆ†å‰²ã®åŸå‰‡**:
1. **æ©Ÿèƒ½ã”ã¨ã«åˆ†å‰²**: å„ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯1ã¤ã®è²¬ä»»ã‚’æŒã¤
2. **ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§æ•´ç†**: æ©Ÿèƒ½ã”ã¨ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’åˆ†ã‘ã‚‹
3. **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§æŠ½è±¡åŒ–**: å·®ã—æ›¿ãˆå¯èƒ½ãªæ©Ÿèƒ½ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–
4. **è¨­å®šã¯ScriptableObject**: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ScriptableObjectã§ç®¡ç†

### æ¨å¥¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
Assets/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ VoiceDetection/          // éŸ³å£°æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ—¢å­˜ï¼‰
â”‚   â”‚   â”œâ”€â”€ VoiceDetector.cs
â”‚   â”‚   â”œâ”€â”€ VolumeAnalyzer.cs
â”‚   â”‚   â”œâ”€â”€ ImprovedPitchAnalyzer.cs
â”‚   â”‚   â””â”€â”€ VoiceCalibrator.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ GameLogic/               // ã‚²ãƒ¼ãƒ ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”‚   â”œâ”€â”€ PaintCanvas.cs       // å¡—ã‚Šã‚­ãƒ£ãƒ³ãƒã‚¹
â”‚   â”‚   â”œâ”€â”€ PaintSystem.cs       // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ PaintBattleGameManager.cs  // ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
â”‚   â”‚   â”œâ”€â”€ VoiceToScreenMapper.cs      // åº§æ¨™å¤‰æ›
â”‚   â”‚   â”œâ”€â”€ AttackTypeManager.cs       // æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠãƒ»ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ AttackTypeDetector.cs      // æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆè‡ªå‹•åˆ¤å®šç”¨ï¼‰
â”‚   â”‚   â””â”€â”€ AttackTypeSelectors/       // é¸æŠãƒ¢ãƒ¼ãƒ‰å®Ÿè£…
â”‚   â”‚       â”œâ”€â”€ AutoAttackTypeSelector.cs
â”‚   â”‚       â”œâ”€â”€ ManualAttackTypeSelector.cs
â”‚   â”‚       â”œâ”€â”€ RandomTimedAttackTypeSelector.cs
â”‚   â”‚       â””â”€â”€ RandomOnPaintAttackTypeSelector.cs
â”‚   â”‚   â”œâ”€â”€ PlayerManager.cs            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ LocalPlayerManager.cs       // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç”¨
â”‚   â”‚   â”œâ”€â”€ VictoryCondition.cs         // å‹åˆ©æ¡ä»¶
â”‚   â”‚   â””â”€â”€ GameplayManager.cs          // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ Graphics/                 // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ InkEffect.cs          // ã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”œâ”€â”€ PaintRenderer.cs      // å¡—ã‚Šæç”»
â”‚   â”‚   â””â”€â”€ EffectPool.cs         // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«
â”‚   â”‚
â”‚   â”œâ”€â”€ Network/                   // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
â”‚   â”‚   â”œâ”€â”€ NetworkManager.cs     // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ NetworkPaintSync.cs   // å¡—ã‚Šãƒ‡ãƒ¼ã‚¿åŒæœŸ
â”‚   â”‚   â””â”€â”€ NetworkPlayerSync.cs  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŒæœŸ
â”‚   â”‚
â”‚   â”œâ”€â”€ SinglePlayer/              // ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ï¼‰
â”‚   â”‚   â”œâ”€â”€ Monster.cs            // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼
â”‚   â”‚   â”œâ”€â”€ MonsterSpawner.cs       // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆç®¡ç†
â”‚   â”‚   â”œâ”€â”€ MonsterHitDetector.cs // å½“ãŸã‚Šåˆ¤å®š
â”‚   â”‚   â”œâ”€â”€ ScoreManager.cs       // ã‚¹ã‚³ã‚¢ç®¡ç†
â”‚   â”‚   â””â”€â”€ MovementPatterns/     // ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…
â”‚   â”‚       â”œâ”€â”€ LinearMovement.cs
â”‚   â”‚       â”œâ”€â”€ CurveMovement.cs
â”‚   â”‚       â””â”€â”€ RandomMovement.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ UI/                        // UIã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ VoiceDisplay.cs       // éŸ³å£°è¡¨ç¤ºï¼ˆæ—¢å­˜ï¼‰
â”‚   â”‚   â”œâ”€â”€ VoiceScatterPlot.cs   // ã‚°ãƒ©ãƒ•è¡¨ç¤ºï¼ˆæ—¢å­˜ï¼‰
â”‚   â”‚   â”œâ”€â”€ GameHUD.cs            // ã‚²ãƒ¼ãƒ HUD
â”‚   â”‚   â”œâ”€â”€ AttackTypeSelectionUI.cs // æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠUI
â”‚   â”‚   â”œâ”€â”€ CreativeModeUI.cs     // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰UI
â”‚   â”‚   â”œâ”€â”€ MainMenuManager.cs    // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼
â”‚   â”‚   â”œâ”€â”€ SettingsPanel.cs     // è¨­å®šãƒ‘ãƒãƒ«
â”‚   â”‚   â”œâ”€â”€ CustomizationPanel.cs // ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‘ãƒãƒ«
â”‚   â”‚   â””â”€â”€ CalibrationPanel.cs  // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒãƒ«
â”‚   â”‚
â”‚   â”œâ”€â”€ Customization/             // ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ InkCustomizer.cs     // ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
â”‚   â”‚   â”œâ”€â”€ SoundCustomizer.cs   // ã‚µã‚¦ãƒ³ãƒ‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
â”‚   â”‚   â””â”€â”€ ThemeManager.cs      // ãƒ†ãƒ¼ãƒç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ SceneManagement/          // ã‚·ãƒ¼ãƒ³ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ SimpleSceneManager.cs
â”‚   â”‚   â””â”€â”€ GameDataManager.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ Interfaces/               // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
â”‚   â”‚   â”œâ”€â”€ IPaintCanvas.cs
â”‚   â”‚   â”œâ”€â”€ IPaintStrategy.cs
â”‚   â”‚   â”œâ”€â”€ IAttackTypeDetector.cs
â”‚   â”‚   â”œâ”€â”€ IInkEffect.cs
â”‚   â”‚   â””â”€â”€ IPlayerManager.cs
â”‚   â”‚
â”‚   â””â”€â”€ Data/                     // ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ï¼ˆScriptableObjectï¼‰
â”‚       â”œâ”€â”€ Settings/
â”‚       â”‚   â”œâ”€â”€ GameSettings.cs
â”‚       â”‚   â”œâ”€â”€ PaintSettings.cs
â”‚       â”‚   â”œâ”€â”€ AttackSettings.cs
â”‚       â”‚   â””â”€â”€ AttackTypeSelectionSettings.cs
â”‚       â”œâ”€â”€ Graphics/
â”‚       â”‚   â”œâ”€â”€ InkEffectSettings.cs
â”‚       â”‚   â”œâ”€â”€ InkMaterialData.cs
â”‚       â”‚   â””â”€â”€ InkTheme.cs
â”‚       â”œâ”€â”€ Scene/
â”‚       â”‚   â”œâ”€â”€ SceneReference.cs
â”‚       â”‚   â””â”€â”€ GameData.cs
â”‚       â”œâ”€â”€ Creative/
â”‚       â”‚   â””â”€â”€ CreativeModeSettings.cs
â”‚       â””â”€â”€ SinglePlayer/
â”‚           â”œâ”€â”€ MonsterSettings.cs
â”‚           â”œâ”€â”€ SpawnSettings.cs
â”‚           â””â”€â”€ ScoreSettings.cs
â”‚
â”œâ”€â”€ ScriptableObjects/            // ScriptableObjectã‚¢ã‚»ãƒƒãƒˆ
â”‚   â”œâ”€â”€ Settings/
â”‚   â”œâ”€â”€ Graphics/
â”‚   â””â”€â”€ Themes/
â”‚
â”œâ”€â”€ Prefabs/                      // ãƒ—ãƒ¬ãƒãƒ–
â”‚   â”œâ”€â”€ Effects/
â”‚   â”‚   â”œâ”€â”€ ImpactShotEffect.prefab
â”‚   â”‚   â””â”€â”€ StreamPaintEffect.prefab
â”‚   â””â”€â”€ UI/
â”‚
â””â”€â”€ Scenes/                       // ã‚·ãƒ¼ãƒ³
    â”œâ”€â”€ 00_MainMenu.unity
    â”œâ”€â”€ 01_Gameplay.unity
    â””â”€â”€ 99_Test.unity
```

### ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²ã®è©³ç´°

#### 1. VoiceDetection/ï¼ˆéŸ³å£°æ¤œå‡ºï¼‰
**å½¹å‰²**: ãƒã‚¤ã‚¯å…¥åŠ›ã‹ã‚‰éŸ³é‡ãƒ»ãƒ”ãƒƒãƒã‚’æ¤œå‡º

**åˆ†å‰²æ–¹é‡**:
- å„æ©Ÿèƒ½ã‚’ç‹¬ç«‹ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«
- æ—¢å­˜ã®å®Ÿè£…ã‚’ãã®ã¾ã¾ä½¿ç”¨

#### 2. GameLogic/ï¼ˆã‚²ãƒ¼ãƒ ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
**å½¹å‰²**: ã‚²ãƒ¼ãƒ ã®æ ¸ã¨ãªã‚‹ãƒ­ã‚¸ãƒƒã‚¯

**åˆ†å‰²æ–¹é‡**:
- **PaintCanvas.cs**: å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†ã®ã¿
- **PaintSystem.cs**: å¡—ã‚Šå‡¦ç†ã®å®Ÿè¡Œï¼ˆStrategy ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- **PaintBattleGameManager.cs**: å…¨ä½“ã®çµ±åˆãƒ»ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
- **AttackTypeManager.cs**: æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®é¸æŠãƒ»ç®¡ç†ï¼ˆè¤‡æ•°ã®é¸æŠãƒ¢ãƒ¼ãƒ‰ã«å¯¾å¿œï¼‰
- **AttackTypeDetector.cs**: æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆè‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
- **PlayerManager.cs**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…
- **LocalPlayerManager.cs**: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç”¨ã®å®Ÿè£…

**ç†ç”±**: å„æ©Ÿèƒ½ã‚’ç‹¬ç«‹ã•ã›ã‚‹ã“ã¨ã§ã€ãƒ†ã‚¹ãƒˆãƒ»ä¿®æ­£ãƒ»æ‹¡å¼µãŒå®¹æ˜“

#### 3. Graphics/ï¼ˆã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ï¼‰
**å½¹å‰²**: è¦–è¦šçš„è¡¨ç¾

**åˆ†å‰²æ–¹é‡**:
- **InkEffect.cs**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†ç”Ÿãƒ»ç®¡ç†
- **PaintRenderer.cs**: å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®æç”»
- **EffectPool.cs**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

**ç†ç”±**: ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯å‡¦ç†ã‚’åˆ†é›¢ã—ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å¤‰æ›´ã«å¯¾å¿œã—ã‚„ã™ã

#### 4. Network/ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
**å½¹å‰²**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤

**åˆ†å‰²æ–¹é‡**:
- **NetworkManager.cs**: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šç®¡ç†
- **NetworkPaintSync.cs**: å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
- **NetworkPlayerSync.cs**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®åŒæœŸ

**ç†ç”±**: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ©Ÿèƒ½ã‚’åˆ†é›¢ã—ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’ä¸ãˆãªã„

#### 5. SinglePlayer/ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ï¼‰
**å½¹å‰²**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰

**åˆ†å‰²æ–¹é‡**:
- **Monster.cs**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®åŸºæœ¬å‹•ä½œã€HPç®¡ç†
- **MonsterSpawner.cs**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç”Ÿæˆãƒ»ç®¡ç†
- **MonsterHitDetector.cs**: ã‚¤ãƒ³ã‚¯ã¨ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å½“ãŸã‚Šåˆ¤å®š
- **ScoreManager.cs**: ã‚¹ã‚³ã‚¢è¨ˆç®—ã€ã‚³ãƒ³ãƒœç®¡ç†
- **MovementPatterns/**: ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Ÿè£…ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ï¼‰

**ç†ç”±**: å„æ©Ÿèƒ½ã‚’ç‹¬ç«‹ã•ã›ã€ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ã‚„ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¿½åŠ ã—ã‚„ã™ã

#### 6. UI/ï¼ˆUIã‚·ã‚¹ãƒ†ãƒ ï¼‰
**å½¹å‰²**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

**åˆ†å‰²æ–¹é‡**:
- å„ç”»é¢ï¼ˆãƒ‘ãƒãƒ«ï¼‰ã”ã¨ã«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’åˆ†å‰²
- æ—¢å­˜ã®`VoiceDisplay`ã€`VoiceScatterPlot`ã¯ãã®ã¾ã¾ä½¿ç”¨

**ç†ç”±**: UIã®å¤‰æ›´ãŒä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«

#### 7. Customization/ï¼ˆã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼‰
**å½¹å‰²**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

**åˆ†å‰²æ–¹é‡**:
- **InkCustomizer.cs**: ã‚¤ãƒ³ã‚¯é–¢é€£ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **SoundCustomizer.cs**: ã‚µã‚¦ãƒ³ãƒ‰é–¢é€£ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **ThemeManager.cs**: ãƒ†ãƒ¼ãƒã®ç®¡ç†

**ç†ç”±**: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ©Ÿèƒ½ã‚’ç‹¬ç«‹ã•ã›ã€æ‹¡å¼µã—ã‚„ã™ã

#### 8. Interfaces/ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰
**å½¹å‰²**: æŠ½è±¡åŒ–å®šç¾©

**åˆ†å‰²æ–¹é‡**:
- å„ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’1ãƒ•ã‚¡ã‚¤ãƒ«ã«1ã¤
- å®Ÿè£…ã¯åˆ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«

**ç†ç”±**: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®šç¾©ã‚’æ˜ç¢ºã«ã—ã€ä¾å­˜é–¢ä¿‚ã‚’æ•´ç†

#### 9. Data/ï¼ˆScriptableObjectï¼‰
**å½¹å‰²**: è¨­å®šãƒ‡ãƒ¼ã‚¿ã®å®šç¾©

**åˆ†å‰²æ–¹é‡**:
- æ©Ÿèƒ½ã”ã¨ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’åˆ†ã‘ã‚‹
- 1ã¤ã®ScriptableObjectã‚¯ãƒ©ã‚¹ = 1ãƒ•ã‚¡ã‚¤ãƒ«

**ç†ç”±**: è¨­å®šãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†ã‚’æ˜ç¢ºã«

### ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²ã®åˆ¤æ–­åŸºæº–

**1ã¤ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã¾ã¨ã‚ã‚‹ã¹ãå ´åˆ**:
- âœ… å¯†æ¥ã«é–¢é€£ã™ã‚‹æ©Ÿèƒ½ï¼ˆä¾‹: `PaintCanvas`ã¨ãã®æç”»å‡¦ç†ï¼‰
- âœ… å¸¸ã«ä¸€ç·’ã«ä½¿ã‚ã‚Œã‚‹æ©Ÿèƒ½
- âœ… å°è¦æ¨¡ãªãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹

**åˆ¥ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«åˆ†ã‘ã‚‹ã¹ãå ´åˆ**:
- âœ… **ç•°ãªã‚‹è²¬ä»»**: å¡—ã‚Šå‡¦ç†ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã¯åˆ¥
- âœ… **ç‹¬ç«‹ã—ã¦ãƒ†ã‚¹ãƒˆã—ãŸã„**: AIã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¯åˆ¥
- âœ… **å·®ã—æ›¿ãˆå¯èƒ½ã«ã—ãŸã„**: Strategy ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å®Ÿè£…ã‚’åˆ†ã‘ã‚‹
- âœ… **é–‹ç™ºè€…ãŒç•°ãªã‚‹**: UIã¨ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã¯åˆ¥

### ä¾å­˜é–¢ä¿‚ã®ç®¡ç†

**ä¾å­˜é–¢ä¿‚ã®åŸå‰‡**:
- **ä¸Šä½å±¤ã‹ã‚‰ä¸‹ä½å±¤ã¸**: UI â†’ GameLogic â†’ VoiceDetection
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹çµŒç”±**: ç›´æ¥å‚ç…§ã§ã¯ãªãã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§æ¥ç¶š
- **Inspectorã§æ¥ç¶š**: ä¾å­˜é–¢ä¿‚ã¯Inspectorã§æ˜ç¤ºçš„ã«æ¥ç¶š

**ä¾å­˜é–¢ä¿‚ã®ä¾‹**:
```
UI/
  â””â”€â†’ GameLogic/ (ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹çµŒç”±)
        â””â”€â†’ VoiceDetection/
        â””â”€â†’ Graphics/
        â””â”€â†’ Network/ (æ¡ä»¶ä»˜ã)
        â””â”€â†’ AI/ (æ¡ä»¶ä»˜ã)
```

### å®Ÿè£…ã®å„ªå…ˆé †ä½ï¼ˆæ®µéšçš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰

**åŸºæœ¬æ–¹é‡**: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ã‚’å„ªå…ˆã—ã€ãã®æ¬¡ã«ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã‚’å®Ÿè£…ã€‚ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã¯æœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ã«ã™ã‚‹

1. **Phase 1: ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼‰**
   - `GameLogic/` - ã‚³ã‚¢ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã€æ”»æ’ƒã‚¿ã‚¤ãƒ—ï¼‰
   - `Graphics/` - åŸºæœ¬çš„ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
   - `Interfaces/` - ä¸»è¦ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
   - **ç›®æ¨™**: å£°ã§ç”»é¢ã«è‰²ã‚’å¡—ã‚Œã‚‹åŸºæœ¬æ©Ÿèƒ½ã‚’å®Œæˆ

2. **Phase 2: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå£°ã§çµµã‚’æããƒ¢ãƒ¼ãƒ‰ï¼‰ã€å®Ÿè£…é›£æ˜“åº¦ï¼šä½ã€‘**
   - `Creative/` - ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿ä½¿ç”¨ï¼‰
   - `UI/` - ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨ã®åŸºæœ¬UIï¼ˆã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã€è‰²é¸æŠãªã©ï¼‰
   - **ç›®æ¨™**: å£°ã§è‡ªç”±ã«çµµã‚’æã‘ã‚‹çŠ¶æ…‹ã«ã™ã‚‹
   - **ç‰¹å¾´**: ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰ã¯ä¸è¦ã€å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿ä½¿ç”¨

3. **Phase 3: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ï¼ˆå„ªå…ˆå®Ÿè£…ï¼‰**
   - `SinglePlayer/` - ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰
   - `UI/` - ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ç”¨ã®åŸºæœ¬UIï¼ˆã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰
   - **ç›®æ¨™**: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã§éŠã¹ã‚‹çŠ¶æ…‹ã«ã™ã‚‹

4. **Phase 4: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã®æ¬¡ï¼‰**
   - `Network/` - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å®Ÿè£…
   - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸã‚·ã‚¹ãƒ†ãƒ 
   - ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°
   - **ç›®æ¨™**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹

5. **Phase 5: UI/UXå®Ÿè£…**
   - `UI/GameHUD` - ã‚²ãƒ¼ãƒ ç”»é¢UI
   - `UI/MenuSystem` - ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 
   - `SceneManagement/` - ã‚·ãƒ¼ãƒ³ç®¡ç†
   - **ç›®æ¨™**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰å„ãƒ¢ãƒ¼ãƒ‰ã«é·ç§»ã§ãã‚‹

6. **Phase 6: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ **
   - `Customization/` - ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚µã‚¦ãƒ³ãƒ‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
   - **ç›®æ¨™**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ãŸç›®ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹

7. **Phase 7: æœ€é©åŒ–ã¨ãƒã‚°ä¿®æ­£**
   - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
   - ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
   - ãƒã‚°ä¿®æ­£
   - **ç›®æ¨™**: ãƒªãƒªãƒ¼ã‚¹æº–å‚™å®Œäº†

8. **Phase 8: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦ï¼‰ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰**
   - `GameLogic/PlayerManager` - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
   - `GameLogic/VictoryCondition` - å‹åˆ©æ¡ä»¶åˆ¤å®š
   - `UI/` - å¯¾æˆ¦ç”¨UIï¼ˆå¡—ã‚Šé¢ç©è¡¨ç¤ºã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰
   - **ç›®æ¨™**: åŒä¸€ç«¯æœ«ã§ã®2äººå¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹
   - **æ³¨æ„**: ä»–ã®æ©Ÿèƒ½ãŒå®Œæˆã—ã¦ã‹ã‚‰å®Ÿè£…ã™ã‚‹

---

## ğŸ“‹ ç¾åœ¨ã®å®Ÿè£…çŠ¶æ³

### âœ… å®Ÿè£…æ¸ˆã¿
- **éŸ³å£°æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ **
  - `VoiceDetector.cs` - ãƒã‚¤ã‚¯å…¥åŠ›ã®å–å¾—
  - `VolumeAnalyzer.cs` - éŸ³é‡ã®æ¤œå‡º
  - `ImprovedPitchAnalyzer.cs` - ãƒ”ãƒƒãƒã®é«˜ç²¾åº¦æ¤œå‡ºï¼ˆãƒ—ãƒªã‚¨ãƒ³ãƒ•ã‚¡ã‚·ã‚¹ã€DCé™¤å»ã€æ”¾ç‰©ç·šè£œé–“ï¼‰
  - `VoiceCalibrator.cs` - ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ï¼ˆãƒã‚¤ã‚ºè¨ˆæ¸¬ã€å‹•çš„é–¾å€¤è¨­å®šï¼‰

- **UIã‚·ã‚¹ãƒ†ãƒ **
  - `VoiceDisplay.cs` - éŸ³é‡ãƒ»ãƒ”ãƒƒãƒã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¡¨ç¤º
  - `VoiceScatterPlot.cs` - 2Dã‚°ãƒ©ãƒ•è¡¨ç¤ºï¼ˆVolumeÃ—Pitchã®å¯è¦–åŒ–ã€è»¸ã®é¸æŠå¯èƒ½ï¼‰

---

## ğŸ¬ ã‚·ãƒ¼ãƒ³æ§‹æˆã¨ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### ã‚·ãƒ¼ãƒ³åˆ†å‰²ã®æ–¹é‡ï¼ˆå°è¦æ¨¡ã‚²ãƒ¼ãƒ å‘ã‘ï¼‰

**åŸºæœ¬æ–¹é‡**: æœ€å°é™ã®ã‚·ãƒ¼ãƒ³åˆ†å‰²ã§ã€é–‹ç™ºåŠ¹ç‡ã¨ä¿å®ˆæ€§ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚‹

**ã‚·ãƒ¼ãƒ³ã‚’åˆ†ã‘ã‚‹ç†ç”±**:
1. **é–‹ç™ºåŠ¹ç‡**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¨ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚’åˆ†ã‘ã‚‹ã“ã¨ã§ã€ãƒ†ã‚¹ãƒˆãŒå®¹æ˜“
2. **ä¿å®ˆæ€§**: æ©Ÿèƒ½ã”ã¨ã«ã‚·ãƒ¼ãƒ³ãŒåˆ†ã‹ã‚Œã¦ã„ã‚‹ã¨ã€ãƒã‚°ä¿®æ­£ã‚„æ©Ÿèƒ½è¿½åŠ ãŒå®¹æ˜“
3. **ãƒ¡ãƒ¢ãƒªç®¡ç†**: ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ä¸­ã«ä¸è¦ãªãƒ¡ãƒ‹ãƒ¥ãƒ¼UIã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰

**æ³¨æ„**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€éåº¦ãªåˆ†å‰²ã¯é¿ã‘ã‚‹ã€‚ã‚·ãƒ¼ãƒ³é·ç§»ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¨é–‹ç™ºã®è¤‡é›‘ã•ã‚’è€ƒæ…®ã€‚

### æ¨å¥¨ã‚·ãƒ¼ãƒ³æ§‹æˆï¼ˆæœ€å°æ§‹æˆï¼‰

```
Assets/Scenes/
â”œâ”€â”€ 00_MainMenu.unity           // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ + è¨­å®š + ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼ˆçµ±åˆï¼‰
â”œâ”€â”€ 01_Gameplay.unity           // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ï¼ˆå…¨ãƒ¢ãƒ¼ãƒ‰å…±é€šï¼‰
â””â”€â”€ 99_Test.unity               // ãƒ†ã‚¹ãƒˆç”¨ã‚·ãƒ¼ãƒ³ï¼ˆé–‹ç™ºä¸­ã®ã¿ï¼‰
```

**æ§‹æˆã®è€ƒãˆæ–¹**:
- **ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€è¨­å®šã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’1ã¤ã®ã‚·ãƒ¼ãƒ³ã«çµ±åˆ
  - UIãƒ‘ãƒãƒ«ã§ç”»é¢ã‚’åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚·ãƒ¼ãƒ³é·ç§»ä¸è¦ï¼‰
  - ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå°ã•ã„ãŸã‚ã€çµ±åˆã—ã¦ã‚‚å•é¡Œãªã—
- **ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³**: ã‚·ãƒ³ã‚°ãƒ«ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å…¨ã¦ã‚’1ã¤ã®ã‚·ãƒ¼ãƒ³ã§å¯¾å¿œ
  - ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ‰ç„¡ã‚„è¨­å®šã§åˆ‡ã‚Šæ›¿ãˆ
  - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®è¿½åŠ /å‰Šé™¤ã§ã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚’åˆ‡ã‚Šæ›¿ãˆ

### å„ã‚·ãƒ¼ãƒ³ã®å½¹å‰²

#### 00_MainMenu.unityï¼ˆãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³ï¼‰
**ç›®çš„**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€è¨­å®šã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ±åˆ

**å«ã¾ã‚Œã‚‹è¦ç´ **:
- **ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼UI**: ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰é¸æŠãƒœã‚¿ãƒ³
- **è¨­å®šãƒ‘ãƒãƒ«**: éŸ³é‡ã€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯å“è³ªãªã©ã®è¨­å®šï¼ˆUIãƒ‘ãƒãƒ«ã§è¡¨ç¤º/éè¡¨ç¤ºï¼‰
- **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‘ãƒãƒ«**: ã‚¤ãƒ³ã‚¯è‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£é¸æŠï¼ˆUIãƒ‘ãƒãƒ«ã§è¡¨ç¤º/éè¡¨ç¤ºï¼‰
- **ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒãƒ«**: éŸ³å£°å…¥åŠ›ã®ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆUIãƒ‘ãƒãƒ«ã§è¡¨ç¤º/éè¡¨ç¤ºï¼‰
- **ã‚·ãƒ¼ãƒ³ç®¡ç†**: ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ã¸ã®é·ç§»
- **æ°¸ç¶šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ**: è¨­å®šãƒ‡ãƒ¼ã‚¿ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼ˆDontDestroyOnLoadï¼‰

**å®Ÿè£…æ–¹é‡**:
```csharp
public class MainMenuManager : MonoBehaviour
{
    [Header("UI Panels")]
    [SerializeField] private GameObject mainMenuPanel;
    [SerializeField] private GameObject settingsPanel;
    [SerializeField] private GameObject customizationPanel;
    [SerializeField] private GameObject calibrationPanel;
    
    [Header("Scene Management")]
    [SerializeField] private string gameplaySceneName = "01_Gameplay";
    
    void Start()
    {
        // åˆæœŸåŒ–å‡¦ç†
        LoadSettings();
        ShowMainMenu();
    }
    
    public void ShowMainMenu() => ShowPanel(mainMenuPanel);
    public void ShowSettings() => ShowPanel(settingsPanel);
    public void ShowCustomization() => ShowPanel(customizationPanel);
    public void ShowCalibration() => ShowPanel(calibrationPanel);
    
    private void ShowPanel(GameObject panel)
    {
        // å…¨ã¦ã®ãƒ‘ãƒãƒ«ã‚’éè¡¨ç¤ºã«ã—ã¦ã‹ã‚‰ã€æŒ‡å®šãƒ‘ãƒãƒ«ã®ã¿è¡¨ç¤º
        mainMenuPanel.SetActive(false);
        settingsPanel.SetActive(false);
        customizationPanel.SetActive(false);
        calibrationPanel.SetActive(false);
        panel.SetActive(true);
    }
    
    public void StartGame()
    {
        UnityEngine.SceneManagement.SceneManager.LoadScene(gameplaySceneName);
    }
}
```

#### 01_Gameplay.unityï¼ˆã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ï¼‰
**ç›®çš„**: å…¨ã¦ã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚·ãƒ³ã‚°ãƒ«ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ï¼‰ã‚’1ã¤ã®ã‚·ãƒ¼ãƒ³ã§å¯¾å¿œ

**è¨­è¨ˆæ–¹é‡**: 
- **åŒã˜ã‚·ãƒ¼ãƒ³ã‚’ä½¿ç”¨**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§åˆ¥ã‚·ãƒ¼ãƒ³ã«ã™ã‚‹å¿…è¦ã¯ãªã„
- **åˆæœŸåŒ–å‡¦ç†ã§åˆ†å²**: ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ã€ç•°ãªã‚‹åˆæœŸåŒ–å‡¦ç†ã‚’å®Ÿè¡Œ
- **ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ‰åŠ¹/ç„¡åŠ¹**: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é–¢é€£ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿æœ‰åŠ¹åŒ–

**å«ã¾ã‚Œã‚‹è¦ç´ **:
- **ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼**: ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®ç®¡ç†ã€ãƒ¢ãƒ¼ãƒ‰åˆæœŸåŒ–
- **å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ **: ã‚¤ãƒ³ã‚¯å¡—ã‚Šã¤ã¶ã—ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å…±é€šï¼‰
- **ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®ç®¡ç†ï¼ˆãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å®Ÿè£…ã‚’åˆ‡ã‚Šæ›¿ãˆï¼‰
- **ã‚²ãƒ¼ãƒ UI**: HUDã€ã‚¿ã‚¤ãƒãƒ¼ã€ã‚¹ã‚³ã‚¢è¡¨ç¤ºï¼ˆå…±é€šï¼‰
- **ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿æœ‰åŠ¹åŒ–

**å®Ÿè£…æ–¹é‡**:
```csharp
public enum GameMode
{
    Creative,       // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå£°ã§çµµã‚’æãï¼‰
    SinglePlayer,   // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰
    OfflineMulti,   // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰
    OnlineMulti     // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
}

public class GameplayManager : MonoBehaviour
{
    [Header("Game Mode")]
    [SerializeField] private GameMode currentMode = GameMode.OfflineMulti;
    
    [Header("Mode-Specific Components")]
    [SerializeField] private CreativeModeManager creativeModeManager; // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨
    [SerializeField] private MonsterSpawner monsterSpawner; // ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ç”¨
    [SerializeField] private NetworkManager networkManager; // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ç”¨
    [SerializeField] private LocalPlayerManager localPlayerManager; // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ç”¨
    
    [Header("Shared Components")]
    [SerializeField] private PaintSystem paintSystem;
    [SerializeField] private PaintCanvas canvas;
    [SerializeField] private GameHUD hud;
    
    void Start()
    {
        InitializeGameMode();
    }
    
    private void InitializeGameMode()
    {
        // å…¨ã¦ã®ãƒ¢ãƒ¼ãƒ‰å›ºæœ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ç„¡åŠ¹åŒ–
        if (creativeModeManager != null) creativeModeManager.gameObject.SetActive(false);
        if (monsterSpawner != null) monsterSpawner.gameObject.SetActive(false);
        if (networkManager != null) networkManager.gameObject.SetActive(false);
        if (localPlayerManager != null) localPlayerManager.gameObject.SetActive(false);
        
        // ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦åˆæœŸåŒ–
        switch (currentMode)
        {
            case GameMode.Creative:
                InitializeCreative();
                break;
            case GameMode.SinglePlayer:
                InitializeSinglePlayer();
                break;
            case GameMode.OfflineMulti:
                InitializeOfflineMulti();
                break;
            case GameMode.OnlineMulti:
                InitializeOnlineMulti();
                break;
        }
    }
    
    private void InitializeCreative()
    {
        // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’æœ‰åŠ¹åŒ–
        if (creativeModeManager != null)
        {
            creativeModeManager.gameObject.SetActive(true);
            creativeModeManager.Initialize();
        }
        // ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ãªã©ï¼‰ã¯ç„¡åŠ¹åŒ–
        if (monsterSpawner != null)
            monsterSpawner.gameObject.SetActive(false);
    }
    
    private void InitializeSinglePlayer()
    {
        // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ã‚’æœ‰åŠ¹åŒ–
        if (monsterSpawner != null)
        {
            monsterSpawner.gameObject.SetActive(true);
            monsterSpawner.Initialize();
        }
        // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚’ä½¿ç”¨ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1äººï¼‰
        if (localPlayerManager != null)
        {
            localPlayerManager.gameObject.SetActive(true);
            localPlayerManager.Initialize(1);
        }
    }
    
    private void InitializeOfflineMulti()
    {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ç„¡åŠ¹
        if (networkManager != null)
            networkManager.gameObject.SetActive(false);
            
        // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚’ä½¿ç”¨
        if (localPlayerManager != null)
        {
            localPlayerManager.gameObject.SetActive(true);
            localPlayerManager.Initialize(2); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°2ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼‰
        }
    }
    
    private void InitializeOnlineMulti()
    {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’æœ‰åŠ¹åŒ–
        if (networkManager != null)
        {
            networkManager.gameObject.SetActive(true);
            networkManager.Initialize();
        }
        
        // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã¯ç„¡åŠ¹ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç®¡ç†ã‚’ä½¿ç”¨ï¼‰
        if (localPlayerManager != null)
            localPlayerManager.gameObject.SetActive(false);
    }
}
```

**ã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®é•ã„**:

| é …ç›® | ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒ | ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒ |
|------|------------------|------------------|
| **ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†** | `LocalPlayerManager`ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰ | `NetworkManager`ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸï¼‰ |
| **å¡—ã‚Šãƒ‡ãƒ¼ã‚¿åŒæœŸ** | ä¸è¦ï¼ˆåŒä¸€ç«¯æœ«ï¼‰ | å¿…è¦ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çµŒç”±ï¼‰ |
| **åˆæœŸåŒ–å‡¦ç†** | ã‚·ãƒ³ãƒ—ãƒ«ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«åˆæœŸåŒ–ã®ã¿ï¼‰ | è¤‡é›‘ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã€ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°ï¼‰ |
| **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°** | ä¸è¦ | å¿…è¦ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ‡æ–­ãªã©ï¼‰ |

**ãƒ¡ãƒªãƒƒãƒˆï¼ˆåŒã˜ã‚·ãƒ¼ãƒ³ã‚’ä½¿ã†è¨­è¨ˆï¼‰**:
- âœ… **é–‹ç™ºåŠ¹ç‡**: ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ãŒå°‘ãªã„
- âœ… **ä¿å®ˆæ€§**: å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‚„UIã¯å…±é€šã§ç®¡ç†
- âœ… **ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§**: ãƒ¢ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ãƒ†ã‚¹ãƒˆå¯èƒ½
- âœ… **å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã«é©ã—ã¦ã„ã‚‹**: ã‚·ãƒ¼ãƒ³é·ç§»ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãŒãªã„

**æ³¨æ„ç‚¹**:
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆæœŸåŒ–å‡¦ç†ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿å®Ÿè¡Œ
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã—ã¦ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å®Ÿè£…ã‚’åˆ‡ã‚Šæ›¿ãˆ
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ‡æ–­ãªã©ï¼‰ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿å¿…è¦

#### 99_Test.unityï¼ˆãƒ†ã‚¹ãƒˆç”¨ã‚·ãƒ¼ãƒ³ï¼‰
**ç›®çš„**: é–‹ç™ºä¸­ã®æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ

**å«ã¾ã‚Œã‚‹è¦ç´ **:
- ãƒ†ã‚¹ãƒˆç”¨UI
- ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«
- å„ç¨®ã‚·ã‚¹ãƒ†ãƒ ã®å€‹åˆ¥ãƒ†ã‚¹ãƒˆï¼ˆéŸ³å£°æ¤œå‡ºã€å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ãªã©ï¼‰

**æ³¨æ„**: æœ¬ç•ªãƒ“ãƒ«ãƒ‰ã«ã¯å«ã‚ãªã„

### ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ï¼ˆç°¡æ˜“ç‰ˆï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SceneManagement/SimpleSceneManager.cs`

**å®Ÿè£…å†…å®¹**:
- åŸºæœ¬çš„ãªã‚·ãƒ¼ãƒ³é·ç§»ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ â†” ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ï¼‰
- å¿…è¦ã«å¿œã˜ã¦ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ã‚·ãƒ³ãƒ—ãƒ«ãªå®Ÿè£…**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯è¤‡é›‘ãªã‚·ã‚¹ãƒ†ãƒ ã¯ä¸è¦
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: å¿…è¦ã«å¿œã˜ã¦ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- **ç›´æ¥çš„ãªé·ç§»**: `SceneManager.LoadScene`ã§ååˆ†ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class SimpleSceneManager : MonoBehaviour
{
    [Header("Scene Names")]
    [SerializeField] private string mainMenuSceneName = "00_MainMenu";
    [SerializeField] private string gameplaySceneName = "01_Gameplay";
    
    [Header("Optional Loading Screen")]
    [SerializeField] private GameObject loadingScreenPrefab; // å¿…è¦ã«å¿œã˜ã¦
    
    public static event Action OnSceneChanged; // ã‚ªãƒ—ã‚·ãƒ§ãƒ³
    
    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã¸
    public void LoadGameplay()
    {
        if (loadingScreenPrefab != null)
        {
            StartCoroutine(LoadSceneWithLoading(gameplaySceneName));
        }
        else
        {
            UnityEngine.SceneManagement.SceneManager.LoadScene(gameplaySceneName);
            OnSceneChanged?.Invoke();
        }
    }
    
    // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‹ã‚‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸
    public void LoadMainMenu()
    {
        UnityEngine.SceneManagement.SceneManager.LoadScene(mainMenuSceneName);
        OnSceneChanged?.Invoke();
    }
    
    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ä»˜ãï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    private IEnumerator LoadSceneWithLoading(string sceneName)
    {
        GameObject loadingScreen = Instantiate(loadingScreenPrefab);
        AsyncOperation asyncLoad = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(sceneName);
        
        while (!asyncLoad.isDone)
        {
            yield return null;
        }
        
        if (loadingScreen != null)
            Destroy(loadingScreen);
            
        OnSceneChanged?.Invoke();
    }
}
```

**æ³¨æ„**: 
- å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€ã“ã®ç¨‹åº¦ã®å®Ÿè£…ã§ååˆ†
- å¿…è¦ã«å¿œã˜ã¦ã€å¾Œã‹ã‚‰æ©Ÿèƒ½ã‚’è¿½åŠ å¯èƒ½
- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã¯ã€ã‚·ãƒ¼ãƒ³é·ç§»ãŒé…ã„å ´åˆã®ã¿å®Ÿè£…

### ã‚·ãƒ¼ãƒ³é–“ã®ãƒ‡ãƒ¼ã‚¿å—ã‘æ¸¡ã—

**å®Ÿè£…æ–¹é‡**: ScriptableObjectã‚’ä½¿ç”¨ã—ãŸå…±æœ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆDontDestroyOnLoadã§ä¿æŒï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SceneManagement/GameData.cs`

```csharp
[CreateAssetMenu(fileName = "GameData", menuName = "Game/Game Data")]
public class GameData : ScriptableObject
{
    // ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‡ãƒ¼ã‚¿
    public InkTheme selectedTheme;
    public Color selectedColor;
    
    // ã‚²ãƒ¼ãƒ è¨­å®š
    public GameSettings gameSettings;
    
    // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿
    public float calibratedVolume;
    public float calibratedPitch;
    
    // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰
    public GameMode selectedGameMode = GameMode.OfflineMulti;
}

// ã‚·ãƒ¼ãƒ³é–“ã§ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
public class GameDataManager : MonoBehaviour
{
    public static GameDataManager Instance { get; private set; }
    
    [SerializeField] private GameData gameData;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    public GameData GetGameData() => gameData;
}
```

**ä½¿ç”¨æ–¹æ³•**:
- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³ã§è¨­å®šãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’å¤‰æ›´
- `GameDataManager.Instance.GetGameData()`ã§ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹
- ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ä½¿ç”¨

### ã‚·ãƒ¼ãƒ³åˆ†å‰²ã®åˆ¤æ–­åŸºæº–ï¼ˆå°è¦æ¨¡ã‚²ãƒ¼ãƒ å‘ã‘ï¼‰

**ã‚·ãƒ¼ãƒ³ã‚’åˆ†ã‘ã‚‹ã¹ãå ´åˆ**:
- âœ… **ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¨ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤**: æ©Ÿèƒ½ãŒæ˜ç¢ºã«åˆ†é›¢ã•ã‚Œã¦ãŠã‚Šã€ãƒ†ã‚¹ãƒˆãŒå®¹æ˜“
- âœ… **ãƒªã‚½ãƒ¼ã‚¹ã®åˆ†é›¢**: ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ä¸­ã«ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIãŒä¸è¦

**ã‚·ãƒ¼ãƒ³ã‚’åˆ†ã‘ãªã„æ–¹ãŒè‰¯ã„å ´åˆ**:
- âŒ **è¨­å®šãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º**: UIãƒ‘ãƒãƒ«ã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ãªãŸã‚ã€åˆ¥ã‚·ãƒ¼ãƒ³ä¸è¦
- âŒ **ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³å†…ã®ãƒ‘ãƒãƒ«ã§ååˆ†
- âŒ **ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰**: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ‰åŠ¹/ç„¡åŠ¹ã§å¯¾å¿œå¯èƒ½

**çµè«–**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€**ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¨ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®2ã‚·ãƒ¼ãƒ³**ã§ååˆ†

### å®Ÿè£…ã®å„ªå…ˆé †ä½

1. **Phase 1ï¼ˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼‰**: 
   - `01_Gameplay.unity` - ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®ã¿ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ãªã—ã§ç›´æ¥èµ·å‹•ï¼‰
   - `99_Test.unity` - ãƒ†ã‚¹ãƒˆç”¨

2. **Phase 2ï¼ˆãƒ–ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒƒãƒ—ï¼‰**:
   - `00_MainMenu.unity` - ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³è¿½åŠ ï¼ˆè¨­å®šãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ»ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆï¼‰
   - `SimpleSceneManager.cs` - ã‚·ãƒ¼ãƒ³é·ç§»ã®å®Ÿè£…

3. **Phase 3ï¼ˆå®Œæˆï¼‰**:
   - `GameDataManager.cs` - ãƒ‡ãƒ¼ã‚¿å—ã‘æ¸¡ã—ã®å®Ÿè£…
   - ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰

---

## âœ… ä¼ç”»æ›¸ã¨ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯

### ç¢ºèªçµæœ

#### âœ… ä¸€è‡´ã—ã¦ã„ã‚‹è¦ç´ 

1. **æ“ä½œæ–¹æ³•ï¼ˆVolume/Pitchï¼‰**
   - ä¼ç”»æ›¸: ç¸¦è»¸=Volumeã€æ¨ªè»¸=Pitch
   - å®Ÿè£…: `VoiceToScreenMapper`ã§å®Ÿè£…æ¸ˆã¿ï¼ˆ`volumeOnYAxis = true`ï¼‰

2. **æ”»æ’ƒãƒ¡ã‚«ãƒ‹ã‚ºãƒ **
   - ä¼ç”»æ›¸: ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆã®2ç¨®é¡
   - å®Ÿè£…: `AttackTypeManager`ã§å®Ÿè£…æ¸ˆã¿ã€è¤‡æ•°ã®é¸æŠæ–¹æ³•ã«å¯¾å¿œï¼ˆè‡ªå‹•åˆ¤å®šã€æ‰‹å‹•é¸æŠã€æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
   - **é¸æŠã‚¿ã‚¤ãƒŸãƒ³ã‚°**: ãƒãƒˆãƒ«å‰é¸æŠã€ãƒãƒˆãƒ«ä¸­å¤‰æ›´ã€æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ãªã©ã€æŸ”è»Ÿã«å¯¾å¿œå¯èƒ½

3. **ä¸Šå¡—ã‚Šãƒ¡ã‚«ãƒ‹ã‚ºãƒ **
   - ä¼ç”»æ›¸: ã€Œã™ã§ã«è‰²ãŒå¡—ã‚‰ã‚Œã¦ã„ã‚‹ä½ç½®ã«ä¸Šå¡—ã‚Šã—ã¦é™£åœ°ã‚’å¥ªã„åˆã†ã€
   - å®Ÿè£…: `PaintCanvas.PaintAt()`ã§ä¸Šå¡—ã‚Šåˆ¤å®šã‚’å®Ÿè£…ï¼ˆå¼·åº¦ãƒ™ãƒ¼ã‚¹ï¼‰

4. **ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰**
   - ä¼ç”»æ›¸: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã€ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰
   - å®Ÿè£…: å…¨ã¦å®Ÿè£…æ¸ˆã¿ï¼ˆ`GameplayManager`ã§ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆï¼‰

5. **å‹åˆ©æ¡ä»¶**
   - ä¼ç”»æ›¸: ã€Œåˆ¶é™æ™‚é–“çµ‚äº†æ™‚ã«ã€æœ€çµ‚çš„ã«æœ€ã‚‚åºƒç¯„å›²ã®é™£åœ°ï¼ˆè‰²ï¼‰ã‚’å¡—ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©ã€
   - å®Ÿè£…: `VictoryCondition`ã§å®Ÿè£…æ¸ˆã¿ï¼ˆ`GetPaintedArea()`ã§é¢ç©è¨ˆç®—ï¼‰

6. **ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰**
   - ä¼ç”»æ›¸: ã€Œæ•µã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’è‰²ã‚’å¡—ã‚‹ã“ã¨ã§å€’ã—ã¦ã„ãã€ï¼ˆæ›´æ–°: ç§»å‹•ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ç‹™ã†ï¼‰
   - å®Ÿè£…: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ã¨ã—ã¦å®Ÿè£…æ¸ˆã¿

7. **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºè¦ç´ **
   - ä¼ç”»æ›¸: ã‚¤ãƒ³ã‚¯ï¼ˆè‰²ï¼‰ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
   - å®Ÿè£…: `InkCustomizer`ã€`SoundCustomizer`ã§å®Ÿè£…æ¸ˆã¿

#### ğŸ“ å®Ÿè£…ã®è©³ç´°

**ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚µã‚¤ã‚¯ãƒ«ï¼ˆä¼ç”»æ›¸ï¼‰**:
1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å£°ã‚’å‡ºã—ã¦ã€è‡ªåˆ†ãŒè‰²ã‚’å¡—ã‚ŠãŸã„ä½ç½®ã‚’éŸ³é‡ã¨ãƒ”ãƒƒãƒã§æŒ‡å®šã—ã€æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚’é¸æŠã™ã‚‹ã€‚
   â†’ âœ… å®Ÿè£…: `PaintBattleGameManager.Update()`ã§å®Ÿè£…

2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæŒ‡å®šã—ãŸä½ç½®ã«ã‚¤ãƒ³ã‚¯ãŒå™´å‡ºã•ã‚Œã€è‰²ãŒå¡—ã‚‰ã‚Œã‚‹ã€‚
   â†’ âœ… å®Ÿè£…: `PaintSystem`ã§å®Ÿè£…

3. ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€å£°ã¨ã‚¤ãƒ³ã‚¯ã‚¿ã‚¤ãƒ—ã‚’ä½¿ã„åˆ†ã‘ã€ã™ã§ã«è‰²ãŒå¡—ã‚‰ã‚Œã¦ã„ã‚‹ä½ç½®ã«ä¸Šå¡—ã‚Šã—ã¦é™£åœ°ã‚’å¥ªã„åˆã†ã€‚
   â†’ âœ… å®Ÿè£…: `PaintCanvas.PaintAt()`ã§ä¸Šå¡—ã‚Šåˆ¤å®šã‚’å®Ÿè£…

**çµè«–**: ä¼ç”»æ›¸ã®å†…å®¹ã¯å®Ÿè£…æ‰‹é †æ›¸ã«åæ˜ ã•ã‚Œã¦ã„ã¾ã™ã€‚

---

## ğŸ¯ Phase 1: ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆï½12æœˆï¼šãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—é–‹ç™ºï¼‰

**ç›®æ¨™**: å£°ã§ç”»é¢ã«è‰²ã‚’å¡—ã‚Œã‚‹åŸºæœ¬æ©Ÿèƒ½ã‚’å®Œæˆã•ã›ã‚‹

### Step 1.1: ç”»é¢ç€è‰²ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

**ç›®æ¨™**: å£°ã®ãƒ”ãƒƒãƒã¨ãƒœãƒªãƒ¥ãƒ¼ãƒ ã§ç”»é¢ä½ç½®ã‚’æŒ‡å®šã—ã€ãã®ä½ç½®ã«è‰²ã‚’å¡—ã‚‹

#### 1.1.1: PaintCanvas ã‚·ã‚¹ãƒ†ãƒ ã®ä½œæˆ
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintCanvas.cs`

**å®Ÿè£…å†…å®¹**:
- ç”»é¢å…¨ä½“ã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦ç®¡ç†ï¼ˆRenderTextureä½¿ç”¨æ¨å¥¨ï¼‰
- å„ãƒ”ã‚¯ã‚»ãƒ«ã«ã€Œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã€ã¨ã€Œå¡—ã‚Šå¼·åº¦ã€ã‚’è¨˜éŒ²
- 2Dé…åˆ—ã¾ãŸã¯Texture2Dã§å¡—ã‚ŠçŠ¶æ…‹ã‚’ç®¡ç†
- **ä¸Šå¡—ã‚Šãƒ¡ã‚«ãƒ‹ã‚ºãƒ **: æ—¢å­˜ã®è‰²ã‚’ä¸Šæ›¸ãã—ã¦é™£åœ°ã‚’å¥ªã„åˆã†ï¼ˆä¼ç”»æ›¸ã®ã‚³ã‚¢æ©Ÿèƒ½ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: `PaintSettings.asset`ã§å¡—ã‚Šå¼·åº¦ã€æ›´æ–°é »åº¦ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ã‚’ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: å¡—ã‚Šå®Œäº†æ™‚ã«`OnPaintCompleted`ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ï¼ˆUIæ›´æ–°ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†ç”Ÿãªã©ï¼‰
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: `IPaintCanvas`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã—ã€å®Ÿè£…ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "PaintSettings", menuName = "Game/Paint Settings")]
public class PaintSettings : ScriptableObject
{
    [Header("Paint Properties")]
    [Range(0.1f, 5f)] public float baseIntensity = 1f;
    [Range(0.1f, 10f)] public float maxIntensity = 3f;
    [Range(1, 10)] public int updateRate = 1; // ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®æ›´æ–°é »åº¦
    
    [Header("Overpaint (ä¸Šå¡—ã‚Š) Properties")]
    [Range(0.5f, 3f)] public float overpaintThreshold = 1.5f; // ä¸Šå¡—ã‚Šã«å¿…è¦ãªå¼·åº¦å€ç‡
    [Tooltip("ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã®ä¸Šå¡—ã‚Šå€ç‡ï¼ˆä¼ç”»æ›¸: ä¸Šå¡—ã‚Šã—ã‚„ã™ã„ï¼‰")]
    [Range(1f, 5f)] public float impactOverpaintMultiplier = 2f;
    
    [Header("Canvas Properties")]
    public int textureWidth = 1920;
    public int textureHeight = 1080;
}

public interface IPaintCanvas
{
    void PaintAt(Vector2 screenPos, int playerId, float intensity, PaintType type);
    float GetPaintedArea(int playerId);
    void ResetCanvas();
}

public class PaintCanvas : MonoBehaviour, IPaintCanvas
{
    [SerializeField] private PaintSettings settings;
    
    public static event Action<Vector2, int, float> OnPaintCompleted;
    public static event Action<Vector2, int, int> OnTerritoryCaptured; // (position, newOwner, oldOwner)
    
    private int[,] playerIdData; // å„ãƒ”ã‚¯ã‚»ãƒ«ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ID
    private float[,] intensityData; // å„ãƒ”ã‚¯ã‚»ãƒ«ã®å¡—ã‚Šå¼·åº¦
    
    public void PaintAt(Vector2 screenPos, int playerId, float intensity, PaintType type)
    {
        // è¨­å®šã‹ã‚‰å¼·åº¦ã‚’å–å¾—
        float baseIntensity = intensity * settings.baseIntensity;
        
        // ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã¯ä¸Šå¡—ã‚Šå€ç‡ã‚’é©ç”¨ï¼ˆä¼ç”»æ›¸: ä¸Šå¡—ã‚Šã—ã‚„ã™ã„ï¼‰
        if (type == AttackType.ImpactShot)
        {
            baseIntensity *= settings.impactOverpaintMultiplier;
        }
        
        // ç”»é¢åº§æ¨™ã‚’ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã«å¤‰æ›
        int x = Mathf.RoundToInt(screenPos.x);
        int y = Mathf.RoundToInt(screenPos.y);
        
        // ç¯„å›²ãƒã‚§ãƒƒã‚¯
        if (x < 0 || x >= settings.textureWidth || y < 0 || y >= settings.textureHeight)
            return;
        
        // æ—¢å­˜ã®å¡—ã‚ŠçŠ¶æ…‹ã‚’ç¢ºèª
        int existingPlayerId = playerIdData[x, y];
        float existingIntensity = intensityData[x, y];
        
        // ä¸Šå¡—ã‚Šåˆ¤å®šï¼ˆä¼ç”»æ›¸: ã™ã§ã«è‰²ãŒå¡—ã‚‰ã‚Œã¦ã„ã‚‹ä½ç½®ã«ä¸Šå¡—ã‚Šï¼‰
        if (existingPlayerId != 0 && existingPlayerId != playerId)
        {
            // ä¸Šå¡—ã‚Šã«å¿…è¦ãªå¼·åº¦ã‚’ãƒã‚§ãƒƒã‚¯
            float requiredIntensity = existingIntensity * settings.overpaintThreshold;
            if (baseIntensity >= requiredIntensity)
            {
                // ä¸Šå¡—ã‚ŠæˆåŠŸï¼šé™£åœ°ã‚’å¥ªå–
                playerIdData[x, y] = playerId;
                intensityData[x, y] = baseIntensity;
                OnTerritoryCaptured?.Invoke(screenPos, playerId, existingPlayerId);
            }
            else
            {
                // ä¸Šå¡—ã‚Šå¤±æ•—ï¼šå¼·åº¦ãŒè¶³ã‚Šãªã„
                return;
            }
        }
        else
        {
            // ç©ºç™½ã¾ãŸã¯è‡ªåˆ†ã®è‰²ï¼šé€šå¸¸ã®å¡—ã‚Š
            playerIdData[x, y] = playerId;
            intensityData[x, y] = Mathf.Max(intensityData[x, y], baseIntensity);
        }
        
        OnPaintCompleted?.Invoke(screenPos, playerId, baseIntensity);
    }
    
    public float GetPaintedArea(int playerId) 
    {
        int count = 0;
        for (int x = 0; x < settings.textureWidth; x++)
        {
            for (int y = 0; y < settings.textureHeight; y++)
            {
                if (playerIdData[x, y] == playerId)
                    count++;
            }
        }
        return (float)count / (settings.textureWidth * settings.textureHeight);
    }
    
    public void ResetCanvas() 
    {
        // å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
        for (int x = 0; x < settings.textureWidth; x++)
        {
            for (int y = 0; y < settings.textureHeight; y++)
            {
                playerIdData[x, y] = 0;
                intensityData[x, y] = 0f;
            }
        }
    }
}
```

#### 1.1.2: åº§æ¨™å¤‰æ›ã‚·ã‚¹ãƒ†ãƒ 
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/VoiceToScreenMapper.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ”ãƒƒãƒãƒ»ãƒœãƒªãƒ¥ãƒ¼ãƒ å€¤ â†’ ç”»é¢åº§æ¨™ã¸ã®å¤‰æ›
- `VoiceScatterPlot`ã®ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class VoiceToScreenMapper : MonoBehaviour
{
    public bool volumeOnYAxis = true; // ä¼ç”»æ›¸: ç¸¦è»¸=Volume
    
    // ãƒ”ãƒƒãƒãƒ»ãƒœãƒªãƒ¥ãƒ¼ãƒ  â†’ ç”»é¢åº§æ¨™
    public Vector2 MapToScreenPosition(float pitch, float volume, 
                                       float minPitch, float maxPitch,
                                       float minVolume, float maxVolume);
}
```

#### 1.1.3: ã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å®Ÿè£…
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/InkEffect.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¤ãƒ³ã‚¯ã®è¦–è¦šçš„è¡¨ç¾ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã€ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰
- å¡—ã‚Šã¤ã¶ã—æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®æŠ½è±¡åŒ–**: `IInkEffect`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è¨­å®šã€ãƒãƒ†ãƒªã‚¢ãƒ«ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ãƒ—ãƒ¬ãƒãƒ–ãƒ™ãƒ¼ã‚¹**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ¬ãƒãƒ–åŒ–ã—ã€Inspectorã§å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ãƒãƒ†ãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ **: ã‚¤ãƒ³ã‚¯ã®è¦‹ãŸç›®ï¼ˆè‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ï¼‰ã‚’å‹•çš„ã«å¤‰æ›´å¯èƒ½ã«
- **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨æŸ”è»Ÿæ€§ã®ä¸¡ç«‹

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public interface IInkEffect
{
    void PlayEffect(Vector2 position, int playerId, AttackType type, float intensity);
    void StopEffect();
    void SetMaterial(Material material);
    void SetColor(Color color);
}

[CreateAssetMenu(fileName = "InkEffectSettings", menuName = "Game/Graphics/Ink Effect Settings")]
public class InkEffectSettings : ScriptableObject
{
    [Header("Impact Shot Effect")]
    public GameObject impactShotPrefab;
    public ParticleSystem impactParticles;
    [Range(0.1f, 5f)] public float impactScale = 1f;
    [Range(0f, 2f)] public float impactDuration = 0.5f;
    
    [Header("Stream Paint Effect")]
    public GameObject streamPrefab;
    public ParticleSystem streamParticles;
    [Range(0.1f, 3f)] public float streamWidth = 1f;
    
    [Header("Materials")]
    public Material defaultInkMaterial;
    public Texture2D defaultInkTexture;
    public Shader inkShader;
}

[CreateAssetMenu(fileName = "InkMaterialData", menuName = "Game/Graphics/Ink Material")]
public class InkMaterialData : ScriptableObject
{
    [Header("Visual Properties")]
    public Material material;
    public Texture2D texture;
    public Color tintColor = Color.white;
    [Range(0f, 1f)] public float metallic = 0f;
    [Range(0f, 1f)] public float smoothness = 0.5f;
    
    [Header("Animation")]
    public AnimationCurve intensityCurve; // å¼·åº¦ã«ã‚ˆã‚‹è¦‹ãŸç›®ã®å¤‰åŒ–
    public bool useFlowAnimation = true;
    [Range(0f, 5f)] public float flowSpeed = 1f;
}

public class InkEffect : MonoBehaviour, IInkEffect
{
    [SerializeField] private InkEffectSettings settings;
    [SerializeField] private InkMaterialData materialData;
    
    private Dictionary<int, ParticleSystem> activeEffects = new Dictionary<int, ParticleSystem>();
    private Material currentMaterial;
    
    public void PlayEffect(Vector2 position, int playerId, AttackType type, float intensity)
    {
        GameObject prefab = type == AttackType.ImpactShot 
            ? settings.impactShotPrefab 
            : settings.streamPrefab;
            
        if (prefab != null)
        {
            GameObject effect = Instantiate(prefab, position, Quaternion.identity);
            ParticleSystem ps = effect.GetComponent<ParticleSystem>();
            
            // ãƒãƒ†ãƒªã‚¢ãƒ«ã¨è‰²ã‚’é©ç”¨
            if (materialData != null)
            {
                ApplyMaterial(ps, materialData, playerId);
            }
            
            // å¼·åº¦ã«å¿œã˜ã¦ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´
            var main = ps.main;
            main.startSize = main.startSize.constant * intensity;
            
            activeEffects[playerId] = ps;
        }
    }
    
    private void ApplyMaterial(ParticleSystem ps, InkMaterialData data, int playerId)
    {
        var renderer = ps.GetComponent<ParticleSystemRenderer>();
        if (renderer != null && data.material != null)
        {
            // ãƒãƒ†ãƒªã‚¢ãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆï¼ˆå„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ï¼‰
            Material instance = new Material(data.material);
            instance.SetTexture("_MainTex", data.texture);
            instance.SetColor("_Color", data.tintColor);
            renderer.material = instance;
        }
    }
    
    public void SetMaterial(Material material)
    {
        currentMaterial = material;
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«é©ç”¨
        foreach (var effect in activeEffects.Values)
        {
            var renderer = effect.GetComponent<ParticleSystemRenderer>();
            if (renderer != null)
                renderer.material = material;
        }
    }
    
    public void SetColor(Color color)
    {
        if (materialData != null)
            materialData.tintColor = color;
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å³åº§ã«åæ˜ 
        foreach (var effect in activeEffects.Values)
        {
            var main = effect.main;
            main.startColor = color;
        }
    }
    
    public void StopEffect() { /* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆåœæ­¢å‡¦ç† */ }
}
```

---

### Step 1.2: æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

#### 1.2.1: æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/AttackTypeManager.cs`

**å®Ÿè£…å†…å®¹**:
- æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®é¸æŠæ–¹æ³•ã‚’æŸ”è»Ÿã«å¯¾å¿œï¼ˆæ‰‹å‹•é¸æŠã€è‡ªå‹•åˆ¤å®šã€æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
- é¸æŠã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®è¨­å®šï¼ˆãƒãƒˆãƒ«å‰ã€ãƒãƒˆãƒ«ä¸­ã€æ™‚é–“åˆ¶ãªã©ï¼‰
- æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®çŠ¶æ…‹ç®¡ç†

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **é¸æŠãƒ¢ãƒ¼ãƒ‰ã®æŠ½è±¡åŒ–**: `IAttackTypeSelector`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§é¸æŠæ–¹æ³•ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: é¸æŠãƒ¢ãƒ¼ãƒ‰ã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã€ãƒ©ãƒ³ãƒ€ãƒ é–“éš”ãªã©ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
- **æ‹¡å¼µæ€§**: æ–°ã—ã„é¸æŠæ–¹æ³•ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã ã‘

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public enum AttackTypeSelectionMode
{
    Auto,           // éŸ³å£°ã«ã‚ˆã‚‹è‡ªå‹•åˆ¤å®šï¼ˆæ—¢å­˜ï¼‰
    Manual,         // æ‰‹å‹•é¸æŠï¼ˆãƒãƒˆãƒ«å‰ã¾ãŸã¯ãƒãƒˆãƒ«ä¸­ï¼‰
    RandomTimed,    // æ™‚é–“åˆ¶ã§ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰æ›´
    RandomOnPaint   // å¡—ã‚‹ãŸã³ã«ãƒ©ãƒ³ãƒ€ãƒ 
}

[CreateAssetMenu(fileName = "AttackTypeSelectionSettings", menuName = "Game/Attack Type Selection Settings")]
public class AttackTypeSelectionSettings : ScriptableObject
{
    [Header("Selection Mode")]
    public AttackTypeSelectionMode mode = AttackTypeSelectionMode.Auto;
    
    [Header("Manual Selection")]
    [Tooltip("ãƒãƒˆãƒ«é–‹å§‹å‰ã«é¸æŠã™ã‚‹ã‹")]
    public bool selectBeforeBattle = true;
    [Tooltip("ãƒãƒˆãƒ«ä¸­ã«å¤‰æ›´å¯èƒ½ã‹")]
    public bool allowChangeDuringBattle = false;
    
    [Header("Random Timed Mode")]
    [Range(1f, 30f)] public float randomChangeInterval = 5f; // ãƒ©ãƒ³ãƒ€ãƒ å¤‰æ›´ã®é–“éš”ï¼ˆç§’ï¼‰
    [Range(0f, 1f)] public float impactShotProbability = 0.5f; // ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã®ç¢ºç‡
    
    [Header("Auto Detection (æ—¢å­˜ã®éŸ³å£°åˆ¤å®š)")]
    public AttackSettings autoDetectionSettings; // æ—¢å­˜ã®AttackSettingsã‚’å‚ç…§
}

public interface IAttackTypeSelector
{
    AttackType GetCurrentType();
    void Initialize(AttackTypeSelectionSettings settings);
    void Update(float deltaTime);
    void SetManualType(AttackType type); // æ‰‹å‹•é¸æŠç”¨
}

public class AttackTypeManager : MonoBehaviour
{
    [SerializeField] private AttackTypeSelectionSettings settings;
    [SerializeField] private IAttackTypeSelector selector;
    
    private AttackType currentType = AttackType.None;
    
    public static event Action<AttackType> OnAttackTypeChanged;
    public static event Action<AttackType> OnAttackTypeSelected; // æ‰‹å‹•é¸æŠæ™‚
    
    void Start()
    {
        InitializeSelector();
    }
    
    void Update()
    {
        if (selector != null)
        {
            selector.Update(Time.deltaTime);
            AttackType newType = selector.GetCurrentType();
            if (newType != currentType)
            {
                currentType = newType;
                OnAttackTypeChanged?.Invoke(currentType);
            }
        }
    }
    
    private void InitializeSelector()
    {
        // é¸æŠãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’åˆæœŸåŒ–
        switch (settings.mode)
        {
            case AttackTypeSelectionMode.Auto:
                selector = gameObject.AddComponent<AutoAttackTypeSelector>();
                break;
            case AttackTypeSelectionMode.Manual:
                selector = gameObject.AddComponent<ManualAttackTypeSelector>();
                break;
            case AttackTypeSelectionMode.RandomTimed:
                selector = gameObject.AddComponent<RandomTimedAttackTypeSelector>();
                break;
            case AttackTypeSelectionMode.RandomOnPaint:
                selector = gameObject.AddComponent<RandomOnPaintAttackTypeSelector>();
                break;
        }
        
        if (selector != null)
        {
            selector.Initialize(settings);
        }
    }
    
    // æ‰‹å‹•é¸æŠç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆUIã‹ã‚‰å‘¼ã³å‡ºã—ï¼‰
    public void SelectAttackType(AttackType type)
    {
        if (selector is ManualAttackTypeSelector manualSelector)
        {
            manualSelector.SetManualType(type);
            OnAttackTypeSelected?.Invoke(type);
        }
    }
    
    public AttackType GetCurrentType() => currentType;
}
```

#### 1.2.2: å„é¸æŠãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/AttackTypeSelectors/`

**å®Ÿè£…å†…å®¹**:
- è‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰ï¼ˆæ—¢å­˜ã®éŸ³å£°åˆ¤å®šï¼‰
- æ‰‹å‹•é¸æŠãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒãƒˆãƒ«å‰/ãƒãƒˆãƒ«ä¸­ï¼‰
- æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰
- å¡—ã‚‹ãŸã³ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
// è‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰ï¼ˆæ—¢å­˜ã®å®Ÿè£…ã‚’å†åˆ©ç”¨ï¼‰
public class AutoAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private IAttackTypeDetector detector;
    private AttackTypeSelectionSettings settings;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        detector = gameObject.AddComponent<AttackTypeDetector>();
        // æ—¢å­˜ã®AttackSettingsã‚’é©ç”¨
    }
    
    public AttackType GetCurrentType()
    {
        return detector?.CurrentType ?? AttackType.None;
    }
    
    public void Update(float deltaTime) { /* è‡ªå‹•åˆ¤å®šã¯DetectorãŒå‡¦ç† */ }
    public void SetManualType(AttackType type) { /* ç„¡åŠ¹ */ }
}

// æ‰‹å‹•é¸æŠãƒ¢ãƒ¼ãƒ‰
public class ManualAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private AttackType selectedType = AttackType.ImpactShot;
    private AttackTypeSelectionSettings settings;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        // ãƒãƒˆãƒ«é–‹å§‹å‰ã®é¸æŠã‚’å¾…ã¤
        if (settings.selectBeforeBattle)
        {
            selectedType = AttackType.None; // æœªé¸æŠçŠ¶æ…‹
        }
    }
    
    public AttackType GetCurrentType() => selectedType;
    
    public void Update(float deltaTime) { /* æ‰‹å‹•é¸æŠãªã®ã§æ›´æ–°ä¸è¦ */ }
    
    public void SetManualType(AttackType type)
    {
        if (settings.allowChangeDuringBattle || selectedType == AttackType.None)
        {
            selectedType = type;
        }
    }
}

// æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰
public class RandomTimedAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private AttackType currentType = AttackType.ImpactShot;
    private AttackTypeSelectionSettings settings;
    private float timer = 0f;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        RandomizeType();
    }
    
    public AttackType GetCurrentType() => currentType;
    
    public void Update(float deltaTime)
    {
        timer += deltaTime;
        if (timer >= settings.randomChangeInterval)
        {
            RandomizeType();
            timer = 0f;
        }
    }
    
    private void RandomizeType()
    {
        currentType = Random.value < settings.impactShotProbability 
            ? AttackType.ImpactShot 
            : AttackType.StreamPaint;
    }
    
    public void SetManualType(AttackType type) { /* ç„¡åŠ¹ */ }
}

// å¡—ã‚‹ãŸã³ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰
public class RandomOnPaintAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private AttackType currentType = AttackType.ImpactShot;
    private AttackTypeSelectionSettings settings;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        RandomizeType();
        
        // å¡—ã‚Šã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­
        PaintCanvas.OnPaintCompleted += OnPaint;
    }
    
    void OnDestroy()
    {
        PaintCanvas.OnPaintCompleted -= OnPaint;
    }
    
    private void OnPaint(Vector2 pos, int playerId, float intensity)
    {
        RandomizeType();
    }
    
    public AttackType GetCurrentType() => currentType;
    
    public void Update(float deltaTime) { /* ä¸è¦ */ }
    
    private void RandomizeType()
    {
        currentType = Random.value < settings.impactShotProbability 
            ? AttackType.ImpactShot 
            : AttackType.StreamPaint;
    }
    
    public void SetManualType(AttackType type) { /* ç„¡åŠ¹ */ }
}
```

#### 1.2.3: æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ï¼ˆè‡ªå‹•åˆ¤å®šç”¨ã€æ—¢å­˜ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/AttackTypeDetector.cs`

**å®Ÿè£…å†…å®¹**:
- **ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆ**: éŸ³é‡ã®æ€¥æ¿€ãªå¤‰åŒ–ï¼ˆå¾®åˆ†å€¤ãŒé–¾å€¤è¶…ï¼‰ã‚’æ¤œå‡º
- **ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆ**: ä¸€å®šæ™‚é–“ä»¥ä¸Šã€éŸ³é‡ãŒå®‰å®šã—ã¦ç¶™ç¶šã—ã¦ã„ã‚‹çŠ¶æ…‹ã‚’æ¤œå‡º
- **æ³¨æ„**: è‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ä½¿ç”¨ã•ã‚Œã‚‹

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: `IAttackTypeDetector`ã‚’å®Ÿè£…ã—ã€åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: é–¾å€¤ã€åˆ¤å®šæ™‚é–“ã€å±¥æ­´ã‚µã‚¤ã‚ºã‚’å…¨ã¦è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
- **æ‹¡å¼µæ€§**: æ–°ã—ã„æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã ã‘

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "AttackSettings", menuName = "Game/Attack Settings")]
public class AttackSettings : ScriptableObject
{
    [Header("Impact Shot Detection")]
    [Range(0.01f, 1f)] public float impactVolumeThreshold = 0.3f; // éŸ³é‡æ€¥ä¸Šæ˜‡ã®é–¾å€¤
    [Range(0.01f, 0.5f)] public float impactTimeWindow = 0.1f; // åˆ¤å®šæ™‚é–“çª“
    
    [Header("Stream Paint Detection")]
    [Range(0.1f, 3f)] public float streamMinDuration = 0.5f; // æœ€å°ç¶™ç¶šæ™‚é–“
    [Range(0.01f, 0.2f)] public float streamVolumeVariance = 0.05f; // è¨±å®¹éŸ³é‡å¤‰å‹•
    [Range(5, 30)] public int streamHistorySize = 10; // å±¥æ­´ã‚µã‚¤ã‚º
    
    [Header("Smoothing")]
    [Range(0f, 1f)] public float typeChangeSmoothing = 0.2f; // ã‚¿ã‚¤ãƒ—å¤‰æ›´ã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
}

public interface IAttackTypeDetector
{
    AttackType DetectAttackType(float volume, float pitch, float deltaTime);
    AttackType CurrentType { get; }
}

public enum AttackType
{
    None,
    ImpactShot,
    StreamPaint
}

public class AttackTypeDetector : MonoBehaviour, IAttackTypeDetector
{
    [SerializeField] private AttackSettings settings;
    
    public static event Action<AttackType> OnAttackTypeChanged;
    
    private Queue<float> volumeHistory = new Queue<float>();
    private float lastVolume = 0f;
    private AttackType currentType = AttackType.None;
    
    public AttackType CurrentType => currentType;
    
    public AttackType DetectAttackType(float currentVolume, float pitch, float deltaTime)
    {
        AttackType detectedType = AttackType.None;
        
        if (IsImpactShot(currentVolume))
            detectedType = AttackType.ImpactShot;
        else if (IsStreamPaint())
            detectedType = AttackType.StreamPaint;
        
        // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
        if (detectedType != currentType)
        {
            currentType = detectedType;
            OnAttackTypeChanged?.Invoke(currentType);
        }
        
        return currentType;
    }
    
    private bool IsImpactShot(float currentVolume)
    {
        float volumeDelta = currentVolume - lastVolume;
        return volumeDelta > settings.impactVolumeThreshold;
    }
    
    private bool IsStreamPaint()
    {
        if (volumeHistory.Count < settings.streamHistorySize) return false;
        // å®‰å®šæ€§ãƒã‚§ãƒƒã‚¯ï¼ˆè¨­å®šã‹ã‚‰é–¾å€¤ã‚’å–å¾—ï¼‰
        // ...
        return true;
    }
}
```

#### 1.2.2: æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¥ã®å¡—ã‚Šãƒ­ã‚¸ãƒƒã‚¯
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintSystem.cs`

**å®Ÿè£…å†…å®¹**:
- **ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆ**: æŒ‡å®šä½ç½®ã«é«˜å¯†åº¦ã®å††çŠ¶ã‚¤ãƒ³ã‚¯ã‚’å¡—ã‚‹ï¼ˆåŠå¾„å›ºå®šã€å¼·åº¦é«˜ï¼‰
- **ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆ**: å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®è»Œè·¡ã«æ²¿ã£ã¦é€£ç¶šçš„ã«ã‚¤ãƒ³ã‚¯ã‚’å¡—ã‚‹ï¼ˆç·šçŠ¶/é¢çŠ¶ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **Strategy ãƒ‘ã‚¿ãƒ¼ãƒ³**: å„æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚’`IPaintStrategy`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§å®Ÿè£…
- **ScriptableObjectè¨­å®š**: åŠå¾„ã€å¼·åº¦ã€è»Œè·¡ã®é•·ã•ãªã©ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **Inspectorã§å·®ã—æ›¿ãˆ**: å¡—ã‚Šæˆ¦ç•¥ã‚’Inspectorã§é¸æŠå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public interface IPaintStrategy
{
    void Paint(Vector2 position, int playerId, float intensity, IPaintCanvas canvas);
}

[CreateAssetMenu(fileName = "ImpactShotSettings", menuName = "Game/Paint/Impact Shot")]
public class ImpactShotSettings : ScriptableObject
{
    [Range(10f, 200f)] public float radius = 50f;
    [Range(1f, 5f)] public float intensityMultiplier = 2f;
}

public class ImpactShotStrategy : ScriptableObject, IPaintStrategy
{
    [SerializeField] private ImpactShotSettings settings;
    
    public void Paint(Vector2 position, int playerId, float intensity, IPaintCanvas canvas)
    {
        // è¨­å®šã‹ã‚‰åŠå¾„ã¨å¼·åº¦ã‚’å–å¾—ã—ã¦å¡—ã‚‹
        float finalIntensity = intensity * settings.intensityMultiplier;
        // å††çŠ¶ã«å¡—ã‚‹å‡¦ç†
    }
}

public class PaintSystem : MonoBehaviour
{
    [SerializeField] private IPaintStrategy impactShotStrategy;
    [SerializeField] private IPaintStrategy streamPaintStrategy;
    [SerializeField] private IPaintCanvas canvas;
    
    private Vector2 lastPaintPosition;
    private Queue<Vector2> paintTrail = new Queue<Vector2>();
    
    public void PaintImpactShot(Vector2 position, int playerId, float intensity)
    {
        impactShotStrategy?.Paint(position, playerId, intensity, canvas);
    }
    
    public void PaintStream(Vector2 currentPosition, int playerId, float intensity)
    {
        streamPaintStrategy?.Paint(currentPosition, playerId, intensity, canvas);
        UpdatePaintTrail(currentPosition);
    }
    
    private void UpdatePaintTrail(Vector2 position) { /* ... */ }
}
```

---

### Step 1.3: ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®çµ±åˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintBattleGameManager.cs`

**å®Ÿè£…å†…å®¹**:
- éŸ³å£°æ¤œå‡º â†’ åº§æ¨™å¤‰æ› â†’ æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®š â†’ å¡—ã‚Šå‡¦ç†ã®çµ±åˆ
- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®ç®¡ç†

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **Inspectorã§æ¥ç¶š**: å…¨ã¦ã®ä¾å­˜ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’Inspectorã§æ¥ç¶šï¼ˆFindObjectOfTypeã‚’é¿ã‘ã‚‹ï¼‰
- **ScriptableObjectè¨­å®š**: ã‚²ãƒ¼ãƒ å…¨ä½“ã®è¨­å®šã‚’`GameSettings.asset`ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•**: å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ã€ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ãŒåå¿œå¯èƒ½ã«
- **çŠ¶æ…‹ç®¡ç†**: ã‚²ãƒ¼ãƒ çŠ¶æ…‹ï¼ˆPlaying, Paused, Endedï¼‰ã‚’æ˜ç¢ºã«ç®¡ç†

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "GameSettings", menuName = "Game/Game Settings")]
public class GameSettings : ScriptableObject
{
    [Header("Game Flow")]
    public float matchDuration = 180f;
    public int maxPlayers = 2;
    
    [Header("Paint Settings")]
    public PaintSettings paintSettings;
    public AttackSettings attackSettings;
    
    [Header("Balance")]
    [Range(0.5f, 2f)] public float paintSpeedMultiplier = 1f;
}

public class PaintBattleGameManager : MonoBehaviour
{
    [Header("Dependencies")] // Inspectorã§æ¥ç¶š
    [SerializeField] private VoiceToScreenMapper mapper;
    [SerializeField] private AttackTypeManager attackTypeManager; // æ”»æ’ƒã‚¿ã‚¤ãƒ—ç®¡ç†
    [SerializeField] private PaintSystem paintSystem;
    [SerializeField] private IPaintCanvas canvas;
    [SerializeField] private ImprovedPitchAnalyzer pitchAnalyzer;
    [SerializeField] private VolumeAnalyzer volumeAnalyzer;
    
    [Header("Settings")]
    [SerializeField] private GameSettings settings;
    
    private int currentPlayerId = 0;
    
    public static event Action<float, float> OnVoiceInput; // pitch, volume
    public static event Action<Vector2> OnPositionMapped;
    public static event Action<AttackType> OnAttackDetected;
    
    void Start()
    {
        // æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­
        if (attackTypeManager != null)
        {
            AttackTypeManager.OnAttackTypeChanged += OnAttackTypeChanged;
        }
    }
    
    void OnDestroy()
    {
        if (attackTypeManager != null)
        {
            AttackTypeManager.OnAttackTypeChanged -= OnAttackTypeChanged;
        }
    }
    
    void Update()
    {
        if (!IsGameActive()) return;
        
        // 1. éŸ³å£°ãƒ‡ãƒ¼ã‚¿å–å¾—
        float pitch = pitchAnalyzer.lastDetectedPitch;
        float volume = volumeAnalyzer.lastDetectedVolume;
        OnVoiceInput?.Invoke(pitch, volume);
        
        // 2. åº§æ¨™å¤‰æ›
        Vector2 screenPos = mapper.MapToScreenPosition(
            pitch, volume, 
            pitchAnalyzer.minFrequency, pitchAnalyzer.maxFrequency,
            0f, volumeAnalyzer.maxVolume
        );
        OnPositionMapped?.Invoke(screenPos);
        
        // 3. æ”»æ’ƒã‚¿ã‚¤ãƒ—å–å¾—ï¼ˆé¸æŠãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦è‡ªå‹•/æ‰‹å‹•/ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
        AttackType type = attackTypeManager != null 
            ? attackTypeManager.GetCurrentType() 
            : AttackType.None;
        OnAttackDetected?.Invoke(type);
        
        // 4. å¡—ã‚Šå‡¦ç†ï¼ˆStrategy ãƒ‘ã‚¿ãƒ¼ãƒ³ã§åˆ†å²ä¸è¦ï¼‰
        if (type != AttackType.None)
        {
            float intensity = volume * settings.paintSpeedMultiplier;
            paintSystem.Paint(screenPos, currentPlayerId, intensity, type);
        }
    }
    
    private void OnAttackTypeChanged(AttackType newType)
    {
        OnAttackDetected?.Invoke(newType);
    }
    
    private bool IsGameActive() { /* çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ */ }
}
```

---

## ğŸ¨ Phase 2: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå£°ã§çµµã‚’æããƒ¢ãƒ¼ãƒ‰ï¼‰ã€å®Ÿè£…é›£æ˜“åº¦ï¼šä¸­ã€‘

**ç›®æ¨™**: å£°ã§è‡ªç”±ã«çµµã‚’æã‘ã‚‹çŠ¶æ…‹ã«ã™ã‚‹

**ç‰¹å¾´**:
- Phase 1ã®å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‚’ãã®ã¾ã¾ä½¿ç”¨
- ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ã€å‹åˆ©æ¡ä»¶ï¼‰ã¯ä¸è¦
- ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ„ãƒ¼ãƒ«ã¨ã—ã¦ã®æ©Ÿèƒ½ï¼ˆè‰²é¸æŠã€æ¶ˆã—ã‚´ãƒ ã€å·»ãæˆ»ã—ã€ä¿å­˜ãƒ»å…±æœ‰ï¼‰
- å®Ÿè£…é›£æ˜“åº¦ã¯ä¸­ç¨‹åº¦ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ãŒå®Œæˆã—ã¦ã„ã‚Œã°å®Ÿè£…å¯èƒ½ï¼‰

### Step 2.1: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Creative/CreativeModeManager.cs`

**å®Ÿè£…å†…å®¹**:
- Phase 1ã®`PaintCanvas`ã¨`PaintBattleGameManager`ã‚’ãã®ã¾ã¾ä½¿ç”¨
- ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰ã¯ç„¡åŠ¹åŒ–
- å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿æœ‰åŠ¹åŒ–
- **ãƒ„ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰ç®¡ç†**: å¡—ã‚Šãƒ¢ãƒ¼ãƒ‰ã€æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
- **å±¥æ­´ç®¡ç†**: å·»ãæˆ»ã—æ©Ÿèƒ½ã®ãŸã‚ã®çŠ¶æ…‹å±¥æ­´

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨ã®è¨­å®šï¼ˆè‰²ã€å¡—ã‚Šå¼·åº¦ãªã©ï¼‰ã‚’ç®¡ç†
- **ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ**: `GameMode`enumã«`Creative`ã‚’è¿½åŠ 
- **ãƒ„ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰**: `CreativeToolMode`enumã§å¡—ã‚Š/æ¶ˆã—ã‚´ãƒ ã‚’åˆ‡ã‚Šæ›¿ãˆ
- **å±¥æ­´ã‚·ã‚¹ãƒ†ãƒ **: çŠ¶æ…‹ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä¿å­˜ã—ã€å·»ãæˆ»ã—ã‚’å¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public enum CreativeToolMode
{
    Paint,      // å¡—ã‚Šãƒ¢ãƒ¼ãƒ‰
    Eraser      // æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰
}

[CreateAssetMenu(fileName = "CreativeModeSettings", menuName = "Game/Creative Mode Settings")]
public class CreativeModeSettings : ScriptableObject
{
    [Header("Paint Settings")]
    public PaintSettings paintSettings; // Phase 1ã®PaintSettingsã‚’å‚ç…§
    
    [Header("Color Selection")]
    public Color[] availableColors = new Color[] 
    { 
        Color.red, Color.blue, Color.green, Color.yellow, 
        Color.cyan, Color.magenta, Color.white, Color.black 
    };
    [Range(0.1f, 2f)] public float paintIntensity = 1f;
    
    [Header("Eraser Settings")]
    [Range(10f, 200f)] public float eraserRadius = 50f;
    [Range(0.1f, 5f)] public float eraserIntensity = 2f; // æ¶ˆå»å¼·åº¦
    
    [Header("History Settings")]
    public enum HistorySaveMode
    {
        OnOperation,    // æ“ä½œã”ã¨ã«ä¿å­˜ï¼ˆæ¨å¥¨ï¼‰
        TimeBased       // æ™‚é–“ãƒ™ãƒ¼ã‚¹ã§è‡ªå‹•ä¿å­˜
    }
    
    [Tooltip("å±¥æ­´ä¿å­˜æ–¹æ³•")]
    public HistorySaveMode historySaveMode = HistorySaveMode.OnOperation;
    
    [Range(10, 100)] public int maxHistorySize = 50; // å±¥æ­´ã®æœ€å¤§æ•°
    
    [Tooltip("æ™‚é–“ãƒ™ãƒ¼ã‚¹ä¿å­˜æ™‚ã®é–“éš”ï¼ˆç§’ï¼‰")]
    [Range(0.1f, 5f)] public float autoSaveHistoryInterval = 0.5f;
    
    [Tooltip("ç„¡éŸ³åˆ¤å®šã®éŸ³é‡é–¾å€¤ï¼ˆã“ã®å€¤ä»¥ä¸‹ã§ç„¡éŸ³ã¨åˆ¤å®šï¼‰")]
    [Tooltip("æ³¨æ„: ImprovedPitchAnalyzerã®volumeThresholdã¨åŒã˜å€¤ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨")]
    [Range(0.001f, 0.1f)] public float silenceVolumeThreshold = 0.01f;
    
    [Tooltip("æ“ä½œçµ‚äº†åˆ¤å®šã®ç„¡éŸ³ç¶™ç¶šæ™‚é–“ï¼ˆç§’ï¼‰")]
    [Range(0.1f, 2f)] public float silenceDurationForOperationEnd = 0.3f;
    
    [Header("References (Optional)")]
    [Tooltip("ImprovedPitchAnalyzerã‚’å‚ç…§ã™ã‚‹ã¨ã€ãã®volumeThresholdã‚’è‡ªå‹•çš„ã«ä½¿ç”¨")]
    public ImprovedPitchAnalyzer improvedPitchAnalyzer;
}

public class CreativeModeManager : MonoBehaviour
{
    [Header("Settings")]
    [SerializeField] private CreativeModeSettings settings;
    
    [Header("References")]
    [SerializeField] private PaintCanvas paintCanvas;
    [SerializeField] private PaintBattleGameManager paintGameManager;
    
    [Header("UI References")]
    [SerializeField] private Button clearButton;
    [SerializeField] private Button[] colorButtons; // è‰²é¸æŠãƒœã‚¿ãƒ³
    [SerializeField] private Button eraserButton; // æ¶ˆã—ã‚´ãƒ ãƒœã‚¿ãƒ³
    [SerializeField] private Button undoButton; // å·»ãæˆ»ã—ãƒœã‚¿ãƒ³
    
    private int currentColorIndex = 0;
    private int currentPlayerId = 1; // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ã¯1ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã¿
    private CreativeToolMode currentToolMode = CreativeToolMode.Paint;
    
    // å±¥æ­´ç®¡ç†
    private Stack<CanvasState> historyStack = new Stack<CanvasState>();
    private float lastHistorySaveTime = 0f;
    private float lastOperationTime = 0f;
    private bool isOperationInProgress = false;
    
    // ç„¡éŸ³åˆ¤å®š
    private float silenceStartTime = 0f;
    private bool wasSilent = false;
    
    public static event Action<CreativeToolMode> OnToolModeChanged;
    public static event Action<Color> OnColorChanged;
    
    void Start()
    {
        InitializeCreativeMode();
    }
    
    void Update()
    {
        // æ™‚é–“ãƒ™ãƒ¼ã‚¹ã®å±¥æ­´ä¿å­˜ï¼ˆè¨­å®šã§æœ‰åŠ¹ãªå ´åˆï¼‰
        if (settings.historySaveMode == CreativeModeSettings.HistorySaveMode.TimeBased)
        {
            if (Time.time - lastHistorySaveTime >= settings.autoSaveHistoryInterval)
            {
                SaveHistoryState();
                lastHistorySaveTime = Time.time;
            }
        }
    }
    
    // ç„¡éŸ³åˆ¤å®šï¼ˆPaintBattleGameManagerã‹ã‚‰å‘¼ã°ã‚Œã‚‹ã€ã¾ãŸã¯VolumeAnalyzerã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­ï¼‰
    public void OnVolumeDetected(float volume)
    {
        if (settings.historySaveMode != CreativeModeSettings.HistorySaveMode.OnOperation)
            return;
        
        // ç„¡éŸ³åˆ¤å®š: ImprovedPitchAnalyzerã®volumeThresholdã‚’å„ªå…ˆçš„ã«ä½¿ç”¨
        // VoiceScatterPlotã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆéŸ³é‡0ã¨åˆ¤æ–­ã™ã‚‹å€¤ã¨åŒã˜ï¼‰
        float threshold = settings.improvedPitchAnalyzer != null 
            ? settings.improvedPitchAnalyzer.volumeThreshold 
            : settings.silenceVolumeThreshold;
        
        bool isSilent = volume <= threshold;
        
        if (isSilent)
        {
            // ç„¡éŸ³çŠ¶æ…‹
            if (!wasSilent)
            {
                // ç„¡éŸ³ãŒå§‹ã¾ã£ãŸæ™‚ç‚¹ã‚’è¨˜éŒ²
                silenceStartTime = Time.time;
                wasSilent = true;
            }
            else
            {
                // ç„¡éŸ³ãŒä¸€å®šæ™‚é–“ç¶šã„ãŸã‚‰æ“ä½œçµ‚äº†ã¨åˆ¤å®š
                if (isOperationInProgress && 
                    Time.time - silenceStartTime >= settings.silenceDurationForOperationEnd)
                {
                    // æ“ä½œçµ‚äº†: ç¾åœ¨ã®çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
                    SaveHistoryState();
                    isOperationInProgress = false;
                }
            }
        }
        else
        {
            // éŸ³å£°ãŒæ¤œå‡ºã•ã‚ŒãŸ
            wasSilent = false;
            lastOperationTime = Time.time;
        }
    }
    
    private void InitializeCreativeMode()
    {
        // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‚’æœ‰åŠ¹åŒ–
        if (paintCanvas != null)
            paintCanvas.gameObject.SetActive(true);
        if (paintGameManager != null)
            paintGameManager.gameObject.SetActive(true);
        
        // è‰²é¸æŠãƒœã‚¿ãƒ³ã®è¨­å®š
        if (colorButtons != null)
        {
            for (int i = 0; i < colorButtons.Length && i < settings.availableColors.Length; i++)
            {
                int colorIndex = i; // ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å¯¾ç­–
                colorButtons[i].onClick.AddListener(() => SelectColor(colorIndex));
                
                // ãƒœã‚¿ãƒ³ã®è‰²ã‚’è¨­å®š
                var colors = colorButtons[i].colors;
                colors.normalColor = settings.availableColors[i];
                colorButtons[i].colors = colors;
            }
        }
        
        // æ¶ˆã—ã‚´ãƒ ãƒœã‚¿ãƒ³ã®è¨­å®š
        if (eraserButton != null)
            eraserButton.onClick.AddListener(() => SetToolMode(CreativeToolMode.Eraser));
        
        // å·»ãæˆ»ã—ãƒœã‚¿ãƒ³ã®è¨­å®š
        if (undoButton != null)
            undoButton.onClick.AddListener(Undo);
        
        // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã®è¨­å®š
        if (clearButton != null)
            clearButton.onClick.AddListener(ClearCanvas);
        
        // åˆæœŸçŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
        SaveHistoryState();
    }
    
    private void SelectColor(int colorIndex)
    {
        currentColorIndex = colorIndex;
        currentToolMode = CreativeToolMode.Paint; // è‰²é¸æŠæ™‚ã¯å¡—ã‚Šãƒ¢ãƒ¼ãƒ‰ã«
        OnColorChanged?.Invoke(settings.availableColors[colorIndex]);
        OnToolModeChanged?.Invoke(CreativeToolMode.Paint);
    }
    
    public void SetToolMode(CreativeToolMode mode)
    {
        currentToolMode = mode;
        OnToolModeChanged?.Invoke(mode);
    }
    
    public CreativeToolMode GetCurrentToolMode() => currentToolMode;
    
    // å¡—ã‚Šå‡¦ç†ï¼ˆPaintBattleGameManagerã‹ã‚‰å‘¼ã°ã‚Œã‚‹ï¼‰
    public void PaintAt(Vector2 screenPos, float intensity)
    {
        // æ“ä½œãƒ™ãƒ¼ã‚¹ä¿å­˜æ™‚: æ“ä½œé–‹å§‹æ™‚ã«å±¥æ­´ã‚’ä¿å­˜ï¼ˆåˆå›ã®ã¿ï¼‰
        if (settings.historySaveMode == CreativeModeSettings.HistorySaveMode.OnOperation)
        {
            if (!isOperationInProgress)
            {
                // æ“ä½œé–‹å§‹æ™‚ç‚¹ã®çŠ¶æ…‹ã‚’ä¿å­˜ï¼ˆã€Œä¸€å›å‰ã€ã®çŠ¶æ…‹ï¼‰
                // ã“ã‚Œã«ã‚ˆã‚Šã€Undoæ™‚ã«ã¯ã€Œå£°ã‚’å‡ºã—å§‹ã‚ã‚‹å‰ã®çŠ¶æ…‹ã€ã«æˆ»ã‚‹
                SaveHistoryState();
                isOperationInProgress = true;
            }
            lastOperationTime = Time.time;
            wasSilent = false; // éŸ³å£°ãŒæ¤œå‡ºã•ã‚ŒãŸã®ã§ç„¡éŸ³ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
        }
        
        if (currentToolMode == CreativeToolMode.Paint)
        {
            // é€šå¸¸ã®å¡—ã‚Šå‡¦ç†
            Color paintColor = settings.availableColors[currentColorIndex];
            paintCanvas.PaintAt(screenPos, currentPlayerId, intensity * settings.paintIntensity, AttackType.StreamPaint);
        }
        else if (currentToolMode == CreativeToolMode.Eraser)
        {
            // æ¶ˆã—ã‚´ãƒ å‡¦ç†
            EraseAt(screenPos, intensity);
        }
    }
    
    private void EraseAt(Vector2 screenPos, float intensity)
    {
        // æ¶ˆã—ã‚´ãƒ å‡¦ç†: æŒ‡å®šä½ç½®ã®å‘¨å›²ã‚’æ¶ˆå»
        float eraseIntensity = intensity * settings.eraserIntensity;
        int radius = Mathf.RoundToInt(settings.eraserRadius);
        
        for (int x = -radius; x <= radius; x++)
        {
            for (int y = -radius; y <= radius; y++)
            {
                float distance = Mathf.Sqrt(x * x + y * y);
                if (distance <= radius)
                {
                    Vector2 erasePos = screenPos + new Vector2(x, y);
                    // PaintCanvasã«æ¶ˆå»å‡¦ç†ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                    // paintCanvas.EraseAt(erasePos, eraseIntensity);
                }
            }
        }
    }
    
    private void ClearCanvas()
    {
        if (paintCanvas != null)
        {
            paintCanvas.ResetCanvas();
            SaveHistoryState(); // ã‚¯ãƒªã‚¢å¾Œã‚‚å±¥æ­´ã«ä¿å­˜
        }
    }
    
    // å±¥æ­´ç®¡ç†
    private void SaveHistoryState()
    {
        if (paintCanvas == null) return;
        
        CanvasState state = paintCanvas.GetState(); // PaintCanvasã«GetState()ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
        historyStack.Push(state);
        
        // å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™
        if (historyStack.Count > settings.maxHistorySize)
        {
            var tempStack = new Stack<CanvasState>();
            for (int i = 0; i < settings.maxHistorySize; i++)
            {
                tempStack.Push(historyStack.Pop());
            }
            historyStack.Clear();
            while (tempStack.Count > 0)
            {
                historyStack.Push(tempStack.Pop());
            }
        }
    }
    
    public void Undo()
    {
        if (historyStack.Count <= 1) return; // åˆæœŸçŠ¶æ…‹ã¯æ®‹ã™
        
        // æ“ä½œãƒ™ãƒ¼ã‚¹ä¿å­˜æ™‚: ç¾åœ¨ã®æ“ä½œã‚’ä¸­æ–­
        if (settings.historySaveMode == CreativeModeSettings.HistorySaveMode.OnOperation)
        {
            isOperationInProgress = false;
        }
        
        // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ç ´æ£„ï¼ˆStackã®æœ€ä¸Šéƒ¨ = æœ€æ–°ã®çŠ¶æ…‹ï¼‰
        historyStack.Pop();
        
        // ä¸€ã¤å‰ã®çŠ¶æ…‹ã‚’å¾©å…ƒï¼ˆStackã®æœ€ä¸Šéƒ¨ = ã€Œä¸€å›å‰ã€ã®çŠ¶æ…‹ï¼‰
        if (historyStack.Count > 0)
        {
            CanvasState previousState = historyStack.Peek();
            paintCanvas.RestoreState(previousState); // PaintCanvasã«RestoreState()ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
        }
    }
    
    /// <summary>
    /// ã€Œä¸€å›å‰ã®çŠ¶æ…‹ã€ã®å®šç¾©:
    /// - æ“ä½œãƒ™ãƒ¼ã‚¹ä¿å­˜æ™‚: æœ€å¾Œã®æ“ä½œï¼ˆå¡—ã‚Š/æ¶ˆã—ã‚´ãƒ ï¼‰ã®ç›´å‰ã®çŠ¶æ…‹
    ///   â†’ å…·ä½“çš„ã«ã¯ã€Œå£°ã‚’å‡ºã—å§‹ã‚ã‚‹å‰ã®çŠ¶æ…‹ã€
    ///   â†’ å£°ãŒèã“ãˆãªããªã£ãŸæ™‚ç‚¹ã§æ“ä½œçµ‚äº†ã¨åˆ¤å®šã—ã€ãã®æ™‚ç‚¹ã®çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
    /// - æ™‚é–“ãƒ™ãƒ¼ã‚¹ä¿å­˜æ™‚: æœ€å¾Œã®è‡ªå‹•ä¿å­˜æ™‚ç‚¹ã®çŠ¶æ…‹
    /// </summary>
    public bool CanUndo()
    {
        return historyStack.Count > 1; // åˆæœŸçŠ¶æ…‹ä»¥å¤–ãŒã‚ã‚Œã°Undoå¯èƒ½
    }
    
    // ç¾åœ¨é¸æŠä¸­ã®è‰²ã‚’å–å¾—
    public Color GetCurrentColor()
    {
        return settings.availableColors[currentColorIndex];
    }
    
    public CreativeModeSettings GetSettings()
    {
        return settings;
    }
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã®çŠ¶æ…‹ã‚’ä¿å­˜ã™ã‚‹ã‚¯ãƒ©ã‚¹
[System.Serializable]
public class CanvasState
{
    public int[,] playerIdData;
    public float[,] intensityData;
    public int width;
    public int height;
    
    public CanvasState(int width, int height)
    {
        this.width = width;
        this.height = height;
        playerIdData = new int[width, height];
        intensityData = new float[width, height];
    }
}
```

### Step 2.2: è‰²é¸æŠã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Creative/ColorSelectionSystem.cs`

**å®Ÿè£…å†…å®¹**:
- è¤‡æ•°ã®è‰²é¸æŠæ–¹æ³•ã‚’ã‚µãƒãƒ¼ãƒˆ
- è‰²é¸æŠæ–¹æ³•ã®åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½

**è‰²é¸æŠã®æ–¹æ³•**:

#### æ–¹æ³•1: ãƒœã‚¿ãƒ³é¸æŠï¼ˆåŸºæœ¬ï¼‰
- **å®Ÿè£…**: UIãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã§è‰²ã‚’é¸æŠ
- **ãƒ¡ãƒªãƒƒãƒˆ**: ã‚·ãƒ³ãƒ—ãƒ«ã€ç›´æ„Ÿçš„
- **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**: è‰²æ•°ãŒå¢—ãˆã‚‹ã¨UIãŒè¤‡é›‘ã«ãªã‚‹

#### æ–¹æ³•2: ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ï¼ˆæ¨å¥¨ï¼‰
- **å®Ÿè£…**: Unityã®ColorPickerã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¾ãŸã¯ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…
- **ãƒ¡ãƒªãƒƒãƒˆ**: ä»»æ„ã®è‰²ã‚’é¸æŠå¯èƒ½ã€æŸ”è»Ÿæ€§ãŒé«˜ã„
- **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**: å®Ÿè£…ãŒã‚„ã‚„è¤‡é›‘

#### æ–¹æ³•3: éŸ³å£°ã«ã‚ˆã‚‹è‰²é¸æŠï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- **å®Ÿè£…**: ç‰¹å®šã®éŸ³å£°ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¾‹: ç‰¹å®šã®ãƒ”ãƒƒãƒç¯„å›²ï¼‰ã§è‰²ã‚’é¸æŠ
- **ãƒ¡ãƒªãƒƒãƒˆ**: å£°ã ã‘ã§æ“ä½œå¯èƒ½ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªä½“é¨“
- **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**: å­¦ç¿’æ›²ç·šãŒã‚ã‚‹ã€èª¤èªè­˜ã®å¯èƒ½æ€§

#### æ–¹æ³•4: ãƒ—ãƒªã‚»ãƒƒãƒˆè‰²ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆæ¨å¥¨ï¼‰
- **å®Ÿè£…**: ã‚ˆãä½¿ã†è‰²ã‚’ãƒ—ãƒªã‚»ãƒƒãƒˆã¨ã—ã¦ä¿å­˜
- **ãƒ¡ãƒªãƒƒãƒˆ**: ç´ æ—©ã„é¸æŠã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½
- **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**: è‰²æ•°ã«åˆ¶é™ãŒã‚ã‚‹

**æ¨å¥¨å®Ÿè£…**: æ–¹æ³•2ï¼ˆã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ï¼‰+ æ–¹æ³•4ï¼ˆãƒ—ãƒªã‚»ãƒƒãƒˆï¼‰ã®çµ„ã¿åˆã‚ã›

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: è‰²é¸æŠæ–¹æ³•ã‚’è¨­å®šã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: `IColorSelector`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§é¸æŠæ–¹æ³•ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ãƒ—ãƒªã‚»ãƒƒãƒˆç®¡ç†**: ãƒ—ãƒªã‚»ãƒƒãƒˆè‰²ã‚’ScriptableObjectã§ç®¡ç†

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public enum ColorSelectionMethod
{
    ButtonSelection,      // ãƒœã‚¿ãƒ³é¸æŠ
    ColorPicker,          // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼
    VoiceSelection,      // éŸ³å£°é¸æŠï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    PresetPalette        // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆ
}

public interface IColorSelector
{
    Color GetSelectedColor();
    void Initialize(CreativeModeSettings settings);
    void Update();
}

[CreateAssetMenu(fileName = "ColorSelectionSettings", menuName = "Game/Creative/Color Selection Settings")]
public class ColorSelectionSettings : ScriptableObject
{
    [Header("Selection Method")]
    public ColorSelectionMethod method = ColorSelectionMethod.ColorPicker;
    
    [Header("Preset Colors")]
    public Color[] presetColors = new Color[]
    {
        Color.red, Color.blue, Color.green, Color.yellow,
        Color.cyan, Color.magenta, Color.white, Color.black,
        new Color(1f, 0.5f, 0f), // ã‚ªãƒ¬ãƒ³ã‚¸
        new Color(0.5f, 0f, 1f)  // ç´«
    };
    
    [Header("Voice Selection (Optional)")]
    [Range(100f, 1000f)] public float[] voicePitchRanges = new float[] { 200f, 300f, 400f }; // å„è‰²ã«å¯¾å¿œã™ã‚‹ãƒ”ãƒƒãƒç¯„å›²
}

public class ColorSelectionSystem : MonoBehaviour
{
    [SerializeField] private ColorSelectionSettings settings;
    [SerializeField] private IColorSelector colorSelector;
    
    private Color currentColor = Color.red;
    
    public static event Action<Color> OnColorSelected;
    
    void Start()
    {
        InitializeSelector();
    }
    
    void Update()
    {
        if (colorSelector != null)
        {
            Color newColor = colorSelector.GetSelectedColor();
            if (newColor != currentColor)
            {
                currentColor = newColor;
                OnColorSelected?.Invoke(currentColor);
            }
        }
    }
    
    private void InitializeSelector()
    {
        switch (settings.method)
        {
            case ColorSelectionMethod.ButtonSelection:
                colorSelector = gameObject.AddComponent<ButtonColorSelector>();
                break;
            case ColorSelectionMethod.ColorPicker:
                colorSelector = gameObject.AddComponent<ColorPickerSelector>();
                break;
            case ColorSelectionMethod.VoiceSelection:
                colorSelector = gameObject.AddComponent<VoiceColorSelector>();
                break;
            case ColorSelectionMethod.PresetPalette:
                colorSelector = gameObject.AddComponent<PresetPaletteSelector>();
                break;
        }
        
        if (colorSelector != null)
        {
            colorSelector.Initialize(settings);
        }
    }
    
    public Color GetCurrentColor() => currentColor;
}

// ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼å®Ÿè£…ä¾‹
public class ColorPickerSelector : MonoBehaviour, IColorSelector
{
    [SerializeField] private ColorPicker colorPicker; // Unity Asset Storeã®ColorPickerã¾ãŸã¯ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…
    private ColorSelectionSettings settings;
    
    public void Initialize(ColorSelectionSettings settings)
    {
        this.settings = settings;
        if (colorPicker != null)
        {
            colorPicker.onValueChanged.AddListener(OnColorChanged);
        }
    }
    
    public Color GetSelectedColor()
    {
        return colorPicker != null ? colorPicker.CurrentColor : Color.red;
    }
    
    public void Update() { }
    
    private void OnColorChanged(Color color)
    {
        ColorSelectionSystem.OnColorSelected?.Invoke(color);
    }
}
```

### Step 2.3: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨UI

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/CreativeModeUI.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
- è‰²é¸æŠUIï¼ˆãƒœã‚¿ãƒ³ã€ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã€ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆï¼‰
- æ¶ˆã—ã‚´ãƒ ãƒœã‚¿ãƒ³
- å·»ãæˆ»ã—ãƒœã‚¿ãƒ³
- ä¿å­˜ãƒœã‚¿ãƒ³
- å…±æœ‰ãƒœã‚¿ãƒ³
- ãƒ„ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **Inspectorè¨­å®š**: UIè¦ç´ ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: è‰²ã®ãƒªã‚¹ãƒˆã¯`CreativeModeSettings`ã§ç®¡ç†
- **UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ**: ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’å¤‰æ›´ã—ã‚„ã™ã„æ§‹é€ 

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class CreativeModeUI : MonoBehaviour
{
    [Header("UI Elements")]
    [SerializeField] private Button clearButton;
    [SerializeField] private Button eraserButton;
    [SerializeField] private Button undoButton;
    [SerializeField] private Button saveButton;
    [SerializeField] private Button shareButton;
    
    [Header("Color Selection UI")]
    [SerializeField] private Transform colorButtonParent;
    [SerializeField] private GameObject colorButtonPrefab;
    [SerializeField] private GameObject colorPickerPanel; // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ãƒ‘ãƒãƒ«
    [SerializeField] private Button colorPickerToggleButton;
    
    [Header("Tool Mode Display")]
    [SerializeField] private TextMeshProUGUI toolModeText;
    [SerializeField] private Image currentColorDisplay; // ç¾åœ¨é¸æŠä¸­ã®è‰²ã‚’è¡¨ç¤º
    
    [Header("References")]
    [SerializeField] private CreativeModeManager creativeManager;
    [SerializeField] private ColorSelectionSystem colorSelectionSystem;
    [SerializeField] private CreativeModeSaveSystem saveSystem;
    
    void Start()
    {
        InitializeUI();
        SubscribeToEvents();
    }
    
    void OnDestroy()
    {
        UnsubscribeFromEvents();
    }
    
    private void InitializeUI()
    {
        // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
        if (clearButton != null && creativeManager != null)
        {
            clearButton.onClick.AddListener(() => creativeManager.ClearCanvas());
        }
        
        // æ¶ˆã—ã‚´ãƒ ãƒœã‚¿ãƒ³
        if (eraserButton != null && creativeManager != null)
        {
            eraserButton.onClick.AddListener(() => creativeManager.SetToolMode(CreativeToolMode.Eraser));
        }
        
        // å·»ãæˆ»ã—ãƒœã‚¿ãƒ³
        if (undoButton != null && creativeManager != null)
        {
            undoButton.onClick.AddListener(() => creativeManager.Undo());
        }
        
        // ä¿å­˜ãƒœã‚¿ãƒ³
        if (saveButton != null && saveSystem != null)
        {
            saveButton.onClick.AddListener(() => saveSystem.SaveCanvas());
        }
        
        // å…±æœ‰ãƒœã‚¿ãƒ³
        if (shareButton != null && saveSystem != null)
        {
            shareButton.onClick.AddListener(() => saveSystem.ShareImage());
        }
        
        // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ãƒˆã‚°ãƒ«
        if (colorPickerToggleButton != null && colorPickerPanel != null)
        {
            colorPickerToggleButton.onClick.AddListener(() => 
            {
                colorPickerPanel.SetActive(!colorPickerPanel.activeSelf);
            });
        }
        
        // è‰²é¸æŠãƒœã‚¿ãƒ³ã®ç”Ÿæˆï¼ˆãƒ—ãƒªã‚»ãƒƒãƒˆè‰²ç”¨ï¼‰
        if (creativeManager != null && colorButtonPrefab != null && colorButtonParent != null)
        {
            var settings = creativeManager.GetSettings();
            if (settings != null)
            {
                foreach (Color color in settings.availableColors)
                {
                    GameObject buttonObj = Instantiate(colorButtonPrefab, colorButtonParent);
                    Button button = buttonObj.GetComponent<Button>();
                    
                    // ãƒœã‚¿ãƒ³ã®è‰²ã‚’è¨­å®š
                    var colors = button.colors;
                    colors.normalColor = color;
                    button.colors = colors;
                    
                    // ã‚¯ãƒªãƒƒã‚¯ã§è‰²ã‚’é¸æŠ
                    Color selectedColor = color; // ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å¯¾ç­–
                    button.onClick.AddListener(() => 
                    {
                        if (colorSelectionSystem != null)
                        {
                            // è‰²é¸æŠã‚·ã‚¹ãƒ†ãƒ ã«é€šçŸ¥ï¼ˆå®Ÿè£…æ–¹æ³•ã«å¿œã˜ã¦èª¿æ•´ï¼‰
                        }
                    });
                }
            }
        }
        
        // åˆæœŸè¡¨ç¤º
        UpdateToolModeDisplay(CreativeToolMode.Paint);
        UpdateColorDisplay(Color.red);
    }
    
    private void SubscribeToEvents()
    {
        CreativeModeManager.OnToolModeChanged += UpdateToolModeDisplay;
        ColorSelectionSystem.OnColorSelected += UpdateColorDisplay;
    }
    
    private void UnsubscribeFromEvents()
    {
        CreativeModeManager.OnToolModeChanged -= UpdateToolModeDisplay;
        ColorSelectionSystem.OnColorSelected -= UpdateColorDisplay;
    }
    
    private void UpdateToolModeDisplay(CreativeToolMode mode)
    {
        if (toolModeText != null)
        {
            toolModeText.text = mode == CreativeToolMode.Paint ? "å¡—ã‚Šãƒ¢ãƒ¼ãƒ‰" : "æ¶ˆã—ã‚´ãƒ ãƒ¢ãƒ¼ãƒ‰";
        }
    }
    
    private void UpdateColorDisplay(Color color)
    {
        if (currentColorDisplay != null)
        {
            currentColorDisplay.color = color;
        }
    }
}
```

### Step 2.4: æ¶ˆã—ã‚´ãƒ æ©Ÿèƒ½ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintCanvas.cs`ï¼ˆæ‹¡å¼µï¼‰

**å®Ÿè£…å†…å®¹**:
- `PaintCanvas`ã«æ¶ˆå»ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
- æŒ‡å®šä½ç½®ã®å‘¨å›²ã‚’æ¶ˆå»ï¼ˆplayerIdã‚’0ã«è¨­å®šã€å¼·åº¦ã‚’0ã«ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: æ¶ˆã—ã‚´ãƒ ã®åŠå¾„ã€å¼·åº¦ã‚’è¨­å®šå¯èƒ½ã«
- **æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µ**: Phase 1ã®`PaintCanvas`ã‚’æ‹¡å¼µã™ã‚‹å½¢ã§å®Ÿè£…

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
// PaintCanvas.csã«è¿½åŠ 
public void EraseAt(Vector2 screenPos, float intensity, float radius)
{
    int x = Mathf.RoundToInt(screenPos.x);
    int y = Mathf.RoundToInt(screenPos.y);
    
    int radiusInt = Mathf.RoundToInt(radius);
    
    for (int dx = -radiusInt; dx <= radiusInt; dx++)
    {
        for (int dy = -radiusInt; dy <= radiusInt; dy++)
        {
            float distance = Mathf.Sqrt(dx * dx + dy * dy);
            if (distance <= radius)
            {
                int px = x + dx;
                int py = y + dy;
                
                // ç¯„å›²ãƒã‚§ãƒƒã‚¯
                if (px >= 0 && px < settings.textureWidth && py >= 0 && py < settings.textureHeight)
                {
                    // æ¶ˆå»å‡¦ç†: playerIdã‚’0ï¼ˆç©ºç™½ï¼‰ã«ã€å¼·åº¦ã‚’0ã«
                    playerIdData[px, py] = 0;
                    intensityData[px, py] = 0f;
                }
            }
        }
    }
    
    // æ¶ˆå»å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆ
    OnPaintCompleted?.Invoke(screenPos, 0, 0f);
}
```

### Step 2.5: å·»ãæˆ»ã—æ©Ÿèƒ½ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintCanvas.cs`ï¼ˆæ‹¡å¼µï¼‰

**å®Ÿè£…å†…å®¹**:
- ã‚­ãƒ£ãƒ³ãƒã‚¹ã®çŠ¶æ…‹ã‚’ä¿å­˜ãƒ»å¾©å…ƒã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
- `GetState()`: ç¾åœ¨ã®çŠ¶æ…‹ã‚’`CanvasState`ã¨ã—ã¦å–å¾—
- `RestoreState()`: ä¿å­˜ã•ã‚ŒãŸçŠ¶æ…‹ã‚’å¾©å…ƒ

**ã€Œä¸€å›å‰ã®çŠ¶æ…‹ã€ã®å®šç¾©**:

å·»ãæˆ»ã—æ©Ÿèƒ½ã«ãŠã‘ã‚‹ã€Œä¸€å›å‰ã®çŠ¶æ…‹ã€ã¯ã€ä»¥ä¸‹ã®2ã¤ã®æ–¹æ³•ã‹ã‚‰é¸æŠå¯èƒ½ã§ã™ï¼š

#### æ–¹æ³•1: æ“ä½œãƒ™ãƒ¼ã‚¹ã®å±¥æ­´ä¿å­˜ï¼ˆæ¨å¥¨ï¼‰
- **å®šç¾©**: ã€Œä¸€å›å‰ã€= æœ€å¾Œã®æ“ä½œï¼ˆå¡—ã‚Š/æ¶ˆã—ã‚´ãƒ ï¼‰ã®**ç›´å‰**ã®çŠ¶æ…‹
- **å®Ÿè£…**: 
  - æ“ä½œé–‹å§‹æ™‚: æ“ä½œå‰ã®çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜ï¼ˆåˆå›ã®ã¿ï¼‰
  - æ“ä½œä¸­: å£°ã‚’å‡ºã—ç¶šã‘ã¦å¡—ã‚‹/æ¶ˆã™
  - æ“ä½œçµ‚äº†æ™‚: **å£°ãŒèã“ãˆãªããªã£ãŸæ™‚ç‚¹**ã§æ“ä½œçµ‚äº†ã¨åˆ¤å®šã—ã€ãã®æ™‚ç‚¹ã®çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
- **ç„¡éŸ³åˆ¤å®š**: 
  - éŸ³é‡ãŒé–¾å€¤ä»¥ä¸‹ã«ãªã£ãŸæ™‚ç‚¹ã§ç„¡éŸ³ã¨åˆ¤å®š
  - ç„¡éŸ³ãŒä¸€å®šæ™‚é–“ï¼ˆä¾‹: 0.3ç§’ï¼‰ç¶šã„ãŸã‚‰æ“ä½œçµ‚äº†ã¨ã¿ãªã™
- **ãƒ¡ãƒªãƒƒãƒˆ**: 
  - ç›´æ„Ÿçš„ï¼ˆå£°ã‚’å‡ºã—ç¶šã‘ã‚‹ = 1ã¤ã®æ“ä½œï¼‰
  - è‡ªç„¶ãªæ“ä½œæ„Ÿï¼ˆå£°ãŒæ­¢ã¾ã£ãŸã‚‰æ“ä½œçµ‚äº†ï¼‰
  - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœŸå¾…ã«ä¸€è‡´
- **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**: 
  - ç„¡éŸ³åˆ¤å®šã®é–¾å€¤èª¿æ•´ãŒå¿…è¦

#### æ–¹æ³•2: æ™‚é–“ãƒ™ãƒ¼ã‚¹ã®å±¥æ­´ä¿å­˜
- **å®šç¾©**: ã€Œä¸€å›å‰ã€= ä¸€å®šæ™‚é–“ï¼ˆä¾‹: 0.5ç§’ï¼‰å‰ã®çŠ¶æ…‹
- **å®Ÿè£…**: ä¸€å®šé–“éš”ã§è‡ªå‹•çš„ã«å±¥æ­´ã‚’ä¿å­˜
- **ãƒ¡ãƒªãƒƒãƒˆ**: 
  - å±¥æ­´æ•°ãŒäºˆæ¸¬å¯èƒ½
  - é€£ç¶šæ“ä½œã§ã‚‚å±¥æ­´ãŒå¢—ãˆã™ããªã„
- **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**: 
  - æ“ä½œã¨å±¥æ­´ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒä¸€è‡´ã—ãªã„å¯èƒ½æ€§
  - ç›´æ„Ÿçš„ã§ãªã„å ´åˆãŒã‚ã‚‹

**æ¨å¥¨å®Ÿè£…**: æ–¹æ³•1ï¼ˆæ“ä½œãƒ™ãƒ¼ã‚¹ï¼‰+ è¨­å®šã§æ–¹æ³•2ã‚‚é¸æŠå¯èƒ½ã«ã™ã‚‹

**å‹•ä½œä¾‹ï¼ˆæ“ä½œãƒ™ãƒ¼ã‚¹ä¿å­˜æ™‚ï¼‰**:

1. **åˆæœŸçŠ¶æ…‹**: ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯ç©ºç™½
   - å±¥æ­´: [åˆæœŸçŠ¶æ…‹]

2. **æ“ä½œ1: å£°ã‚’å‡ºã—ã¦èµ¤ã§å¡—ã‚‹**
   - å£°ã‚’å‡ºã—å§‹ã‚ã‚‹: æ“ä½œé–‹å§‹ â†’ å±¥æ­´ã«ã€Œæ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆç©ºç™½ï¼‰ã€ã‚’ä¿å­˜
   - å±¥æ­´: [åˆæœŸçŠ¶æ…‹, æ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆç©ºç™½ï¼‰]
   - å£°ã‚’å‡ºã—ç¶šã‘ã¦å¡—ã‚‹: èµ¤ã§å¡—ã‚Šç¶šã‘ã‚‹
   - å£°ãŒæ­¢ã¾ã‚‹ï¼ˆç„¡éŸ³ãŒ0.3ç§’ç¶šãï¼‰: æ“ä½œçµ‚äº† â†’ å±¥æ­´ã«ã€Œæ“ä½œå¾Œã®çŠ¶æ…‹ï¼ˆèµ¤ã§å¡—ã‚‰ã‚ŒãŸçŠ¶æ…‹ï¼‰ã€ã‚’ä¿å­˜
   - å±¥æ­´: [åˆæœŸçŠ¶æ…‹, æ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆç©ºç™½ï¼‰, æ“ä½œå¾Œã®çŠ¶æ…‹ï¼ˆèµ¤ï¼‰]

3. **æ“ä½œ2: å£°ã‚’å‡ºã—ã¦é’ã§å¡—ã‚‹**
   - å£°ã‚’å‡ºã—å§‹ã‚ã‚‹: æ“ä½œé–‹å§‹ â†’ å±¥æ­´ã«ã€Œæ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆèµ¤ï¼‰ã€ã‚’ä¿å­˜
   - å±¥æ­´: [åˆæœŸçŠ¶æ…‹, æ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆç©ºç™½ï¼‰, æ“ä½œå¾Œã®çŠ¶æ…‹ï¼ˆèµ¤ï¼‰, æ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆèµ¤ï¼‰]
   - å£°ã‚’å‡ºã—ç¶šã‘ã¦å¡—ã‚‹: é’ã§å¡—ã‚Šç¶šã‘ã‚‹
   - å£°ãŒæ­¢ã¾ã‚‹ï¼ˆç„¡éŸ³ãŒ0.3ç§’ç¶šãï¼‰: æ“ä½œçµ‚äº† â†’ å±¥æ­´ã«ã€Œæ“ä½œå¾Œã®çŠ¶æ…‹ï¼ˆèµ¤+é’ï¼‰ã€ã‚’ä¿å­˜
   - å±¥æ­´: [åˆæœŸçŠ¶æ…‹, æ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆç©ºç™½ï¼‰, æ“ä½œå¾Œã®çŠ¶æ…‹ï¼ˆèµ¤ï¼‰, æ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆèµ¤ï¼‰, æ“ä½œå¾Œã®çŠ¶æ…‹ï¼ˆèµ¤+é’ï¼‰]

4. **Undoãƒœã‚¿ãƒ³ã‚’æŠ¼ã™**
   - ç¾åœ¨ã®çŠ¶æ…‹ï¼ˆèµ¤+é’ï¼‰ã‚’ç ´æ£„
   - ã€Œä¸€å›å‰ã®çŠ¶æ…‹ï¼ˆæ“ä½œå‰ã®çŠ¶æ…‹ï¼ˆèµ¤ï¼‰ï¼‰ã€ã‚’å¾©å…ƒ
   - çµæœ: ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯ã€Œèµ¤ã§å¡—ã‚‰ã‚ŒãŸçŠ¶æ…‹ã€ã«æˆ»ã‚‹ï¼ˆå£°ã‚’å‡ºã—å§‹ã‚ã‚‹å‰ã®çŠ¶æ…‹ï¼‰

**ç„¡éŸ³åˆ¤å®šã®ä»•çµ„ã¿**:

- **éŸ³é‡é–¾å€¤**: 
  - `ImprovedPitchAnalyzer.volumeThreshold`ã‚’å„ªå…ˆçš„ã«ä½¿ç”¨ï¼ˆæ¨å¥¨ï¼‰
  - ã“ã‚Œã«ã‚ˆã‚Šã€`VoiceScatterPlot`ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã€ŒéŸ³é‡0ã¨åˆ¤æ–­ã™ã‚‹å€¤ã€ã¨åŒã˜ã«ãªã‚‹
  - `ImprovedPitchAnalyzer`ãŒå‚ç…§ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€`silenceVolumeThreshold`ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 0.01ï¼‰ã‚’ä½¿ç”¨
- **æ“ä½œçµ‚äº†åˆ¤å®š**: ç„¡éŸ³ãŒ`silenceDurationForOperationEnd`ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 0.3ç§’ï¼‰ç¶šã„ãŸã‚‰æ“ä½œçµ‚äº†
- **ãƒ¡ãƒªãƒƒãƒˆ**: 
  - å£°ã‚’å‡ºã—ç¶šã‘ã‚‹ = 1ã¤ã®æ“ä½œã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹
  - å£°ãŒæ­¢ã¾ã£ãŸã‚‰æ“ä½œçµ‚äº† = è‡ªç„¶ãªæ“ä½œæ„Ÿ
  - çŸ­ã„ç„¡éŸ³ï¼ˆæ¯ç¶™ããªã©ï¼‰ã¯æ“ä½œç¶™ç¶šã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹
  - æ—¢å­˜ã®éŸ³å£°æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ã¨ä¸€è²«æ€§ãŒã‚ã‚‹
- **è¨­å®š**: 
  - é–¾å€¤ã¯`ImprovedPitchAnalyzer`ã®è¨­å®šã«é€£å‹•ï¼ˆæ¨å¥¨ï¼‰
  - ã¾ãŸã¯`silenceVolumeThreshold`ã§å€‹åˆ¥ã«è¨­å®šå¯èƒ½
  - ç¶™ç¶šæ™‚é–“ã¯`silenceDurationForOperationEnd`ã§èª¿æ•´å¯èƒ½

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ãƒ¡ãƒ¢ãƒªç®¡ç†**: å±¥æ­´ã‚µã‚¤ã‚ºã‚’åˆ¶é™ã—ã€ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’ç®¡ç†
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: çŠ¶æ…‹ã®ã‚³ãƒ”ãƒ¼ã¯å¿…è¦æœ€å°é™ã«
- **è¨­å®šå¯èƒ½**: å±¥æ­´ä¿å­˜æ–¹æ³•ã‚’ScriptableObjectã§é¸æŠå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
// PaintCanvas.csã«è¿½åŠ 
public CanvasState GetState()
{
    CanvasState state = new CanvasState(settings.textureWidth, settings.textureHeight);
    
    // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼
    for (int x = 0; x < settings.textureWidth; x++)
    {
        for (int y = 0; y < settings.textureHeight; y++)
        {
            state.playerIdData[x, y] = playerIdData[x, y];
            state.intensityData[x, y] = intensityData[x, y];
        }
    }
    
    return state;
}

public void RestoreState(CanvasState state)
{
    if (state.width != settings.textureWidth || state.height != settings.textureHeight)
    {
        Debug.LogError("CanvasStateã®ã‚µã‚¤ã‚ºãŒä¸€è‡´ã—ã¾ã›ã‚“");
        return;
    }
    
    // ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
    for (int x = 0; x < settings.textureWidth; x++)
    {
        for (int y = 0; y < settings.textureHeight; y++)
        {
            playerIdData[x, y] = state.playerIdData[x, y];
            intensityData[x, y] = state.intensityData[x, y];
        }
    }
    
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ›´æ–°ï¼ˆå¯è¦–åŒ–ç”¨ï¼‰
    UpdateTexture();
}
```

### Step 2.6: ä¿å­˜ãƒ»å…±æœ‰æ©Ÿèƒ½ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Creative/CreativeModeSaveSystem.cs`

**å®Ÿè£…å†…å®¹**:
- æã„ãŸçµµã‚’PNGç”»åƒã¨ã—ã¦ä¿å­˜
- ç”»åƒã‚’å…±æœ‰ï¼ˆSNSã€ãƒ¡ãƒ¼ãƒ«ã€ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ãªã©ï¼‰
- ä¿å­˜å…ˆã®ç®¡ç†

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: ä¿å­˜å…ˆãƒ‘ã‚¹ã€ãƒ•ã‚¡ã‚¤ãƒ«åå½¢å¼ã‚’è¨­å®šå¯èƒ½ã«
- **ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œ**: PCã€ãƒ¢ãƒã‚¤ãƒ«ï¼ˆAndroid/iOSï¼‰ã«å¯¾å¿œ
- **å…±æœ‰æ–¹æ³•**: è¤‡æ•°ã®å…±æœ‰æ–¹æ³•ã‚’ã‚µãƒãƒ¼ãƒˆ

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "SaveSettings", menuName = "Game/Creative/Save Settings")]
public class SaveSettings : ScriptableObject
{
    [Header("Save Path")]
    [Tooltip("ä¿å­˜å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆç›¸å¯¾ãƒ‘ã‚¹ï¼‰")]
    public string saveDirectory = "Screenshots";
    
    [Header("File Naming")]
    [Tooltip("ãƒ•ã‚¡ã‚¤ãƒ«åã®å½¢å¼ï¼ˆ{0}ã«æ—¥æ™‚ãŒå…¥ã‚‹ï¼‰")]
    public string fileNameFormat = "Creative_{0:yyyyMMdd_HHmmss}.png";
    
    [Header("Image Settings")]
    [Range(0.5f, 2f)] public float imageScale = 1f; // ç”»åƒã®ã‚¹ã‚±ãƒ¼ãƒ«
    public bool includeTimestamp = true;
}

public class CreativeModeSaveSystem : MonoBehaviour
{
    [Header("Settings")]
    [SerializeField] private SaveSettings settings;
    
    [Header("References")]
    [SerializeField] private PaintCanvas paintCanvas;
    [SerializeField] private Button saveButton;
    [SerializeField] private Button shareButton;
    
    public static event Action<string> OnImageSaved;
    public static event Action<bool> OnShareCompleted;
    
    void Start()
    {
        if (saveButton != null)
            saveButton.onClick.AddListener(SaveCanvas);
        
        if (shareButton != null)
            shareButton.onClick.AddListener(ShareImage);
    }
    
    public void SaveCanvas()
    {
        if (paintCanvas == null) return;
        
        // PaintCanvasã®ãƒ‡ãƒ¼ã‚¿ã‚’Texture2Dã«å¤‰æ›
        Texture2D texture = paintCanvas.GetTexture(); // PaintCanvasã«GetTexture()ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
        
        if (texture == null)
        {
            Debug.LogError("ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ");
            return;
        }
        
        // PNGã«å¤‰æ›
        byte[] pngData = texture.EncodeToPNG();
        
        // ä¿å­˜å…ˆãƒ‘ã‚¹ã‚’å–å¾—
        string directory = GetSaveDirectory();
        if (!System.IO.Directory.Exists(directory))
        {
            System.IO.Directory.CreateDirectory(directory);
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
        string fileName = GetFileName();
        string filePath = System.IO.Path.Combine(directory, fileName);
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
        System.IO.File.WriteAllBytes(filePath, pngData);
        
        Debug.Log($"ç”»åƒã‚’ä¿å­˜ã—ã¾ã—ãŸ: {filePath}");
        OnImageSaved?.Invoke(filePath);
    }
    
    public void ShareImage()
    {
        if (paintCanvas == null) return;
        
        // ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜
        Texture2D texture = paintCanvas.GetTexture();
        if (texture == null) return;
        
        byte[] pngData = texture.EncodeToPNG();
        string tempPath = System.IO.Path.Combine(Application.temporaryCachePath, "share_temp.png");
        System.IO.File.WriteAllBytes(tempPath, pngData);
        
        // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ åˆ¥ã®å…±æœ‰å‡¦ç†
        #if UNITY_ANDROID
            ShareImageAndroid(tempPath);
        #elif UNITY_IOS
            ShareImageIOS(tempPath);
        #elif UNITY_STANDALONE_WIN || UNITY_STANDALONE_OSX
            ShareImageDesktop(tempPath);
        #endif
    }
    
    private void ShareImageAndroid(string imagePath)
    {
        // Android Native Share Plugin ã¾ãŸã¯ Unityã®Shareæ©Ÿèƒ½ã‚’ä½¿ç”¨
        // å®Ÿè£…ä¾‹:
        /*
        AndroidJavaClass intentClass = new AndroidJavaClass("android.content.Intent");
        AndroidJavaObject intentObject = new AndroidJavaObject("android.content.Intent");
        intentObject.Call<AndroidJavaObject>("setAction", intentClass.GetStatic<string>("ACTION_SEND"));
        // ... Androidå…±æœ‰å‡¦ç†
        */
        OnShareCompleted?.Invoke(true);
    }
    
    private void ShareImageIOS(string imagePath)
    {
        // iOS Native Share Plugin ã‚’ä½¿ç”¨
        // å®Ÿè£…ä¾‹:
        /*
        NativeShare.ShareOptions options = new NativeShare.ShareOptions();
        options.AddFile(imagePath);
        NativeShare.Share(options);
        */
        OnShareCompleted?.Invoke(true);
    }
    
    private void ShareImageDesktop(string imagePath)
    {
        // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§ã¯ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
        // å®Ÿè£…ä¾‹:
        /*
        GUIUtility.systemCopyBuffer = imagePath;
        Debug.Log("ç”»åƒãƒ‘ã‚¹ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
        */
        OnShareCompleted?.Invoke(true);
    }
    
    private string GetSaveDirectory()
    {
        string directory = settings.saveDirectory;
        
        // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ åˆ¥ã®ãƒ‘ã‚¹å‡¦ç†
        #if UNITY_ANDROID
            directory = System.IO.Path.Combine(Application.persistentDataPath, directory);
        #elif UNITY_IOS
            directory = System.IO.Path.Combine(Application.persistentDataPath, directory);
        #elif UNITY_STANDALONE_WIN || UNITY_STANDALONE_OSX
            directory = System.IO.Path.Combine(Application.dataPath, "..", directory);
        #endif
        
        return directory;
    }
    
    private string GetFileName()
    {
        if (settings.includeTimestamp)
        {
            return string.Format(settings.fileNameFormat, System.DateTime.Now);
        }
        else
        {
            return "Creative.png";
        }
    }
}
```

---

## ğŸ¯ Phase 3: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ï¼‰ï¼ˆå„ªå…ˆå®Ÿè£…ï¼‰ï¼ˆ1æœˆï¼‰

**ç›®æ¨™**: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã§éŠã¹ã‚‹çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³å®Ÿè£…ã¯ä¸è¦ï¼‰

### Step 3.1: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/Monster.cs`

**å®Ÿè£…å†…å®¹**:
- ç”»é¢ã‚’ç§»å‹•ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å®Ÿè£…
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç›´ç·šã€æ›²ç·šã€ãƒ©ãƒ³ãƒ€ãƒ ãªã©ï¼‰
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®HP/è€ä¹…å€¤ç®¡ç†
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®è¦–è¦šçš„è¡¨ç¾

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ã€ç§»å‹•é€Ÿåº¦ã€HPãªã©ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æŠ½è±¡åŒ–**: `IMonsterMovement`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "MonsterSettings", menuName = "Game/SinglePlayer/Monster Settings")]
public class MonsterSettings : ScriptableObject
{
    [Header("Monster Properties")]
    [Range(1, 10)] public int maxHP = 3;
    [Range(10f, 500f)] public float moveSpeed = 100f;
    [Range(0.5f, 5f)] public float spawnInterval = 2f;
    
    [Header("Visual")]
    public GameObject monsterPrefab;
    public Color monsterColor = Color.red;
    [Range(20f, 200f)] public float monsterSize = 50f;
}

public interface IMonsterMovement
{
    Vector2 GetNextPosition(Vector2 currentPos, float deltaTime);
    void Initialize(Vector2 startPos, Vector2 targetPos);
}

public class Monster : MonoBehaviour
{
    [SerializeField] private MonsterSettings settings;
    [SerializeField] private IMonsterMovement movementPattern;
    
    private int currentHP;
    private Vector2 currentPosition;
    
    public static event Action<Monster> OnMonsterDefeated;
    public static event Action<Monster> OnMonsterSpawned;
    
    void Start()
    {
        currentHP = settings.maxHP;
        OnMonsterSpawned?.Invoke(this);
    }
    
    void Update()
    {
        // ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã£ã¦ç§»å‹•
        if (movementPattern != null)
        {
            currentPosition = movementPattern.GetNextPosition(currentPosition, Time.deltaTime);
            transform.position = currentPosition;
        }
    }
    
    // ã‚¤ãƒ³ã‚¯ãŒå½“ãŸã£ãŸæ™‚ã®å‡¦ç†
    public void TakeDamage(int damage)
    {
        currentHP -= damage;
        if (currentHP <= 0)
        {
            Defeat();
        }
    }
    
    private void Defeat()
    {
        OnMonsterDefeated?.Invoke(this);
        // ã‚¹ã‚³ã‚¢åŠ ç®—ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†ç”Ÿãªã©
        Destroy(gameObject);
    }
    
    public Vector2 GetPosition() => currentPosition;
    public int GetHP() => currentHP;
}
```

---

### Step 3.2: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/MonsterSpawner.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç”Ÿæˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ç®¡ç†
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠ
- ç”»é¢å¤–ã¸ã®ç§»å‹•åˆ¤å®šã¨å‰Šé™¤
- é›£æ˜“åº¦ã®æ®µéšçš„å¢—åŠ 

---

### Step 3.3: å½“ãŸã‚Šåˆ¤å®šã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/MonsterHitDetector.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¤ãƒ³ã‚¯ãŒãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã«å½“ãŸã£ãŸã‹ã®åˆ¤å®š
- å½“ãŸã£ãŸæ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
- ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†ç”Ÿ

---

### Step 3.4: ã‚¹ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/ScoreManager.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ™‚ã®ã‚¹ã‚³ã‚¢è¨ˆç®—
- ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ ï¼ˆé€£ç¶šæ’ƒç ´ãƒœãƒ¼ãƒŠã‚¹ï¼‰
- ã‚¹ã‚³ã‚¢è¡¨ç¤º
- ãƒ©ãƒ³ã‚­ãƒ³ã‚°ä¿å­˜

---

## ğŸŒ Phase 4: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã®æ¬¡ï¼‰ï¼ˆ1ï½2æœˆï¼‰

**ç›®æ¨™**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹

### Step 4.1: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ã®å®Ÿè£…

**å®Ÿè£…å†…å®¹**:
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸï¼ˆUnity Netcode for GameObjects ã¾ãŸã¯ Mirror ã‚’ä½¿ç”¨ï¼‰
- å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ãƒ»æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®åŒæœŸ

**ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**:
- `NetworkPaintCanvas.cs` - å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
- `NetworkPlayerManager.cs` - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®åŒæœŸ
- `MatchmakingSystem.cs` - ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°

---

## ğŸ¨ Phase 5: UI/UXå®Ÿè£…ï¼ˆ1ï½2æœˆï¼‰

**ç›®æ¨™**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰å„ãƒ¢ãƒ¼ãƒ‰ã«é·ç§»ã§ãã‚‹

### Step 5.1: ã‚²ãƒ¼ãƒ ç”»é¢UI

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/GameHUD.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º
- å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¡—ã‚Šé¢ç©ï¼ˆãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ï¼‰è¡¨ç¤º
- ç¾åœ¨ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—è¡¨ç¤ºï¼ˆã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ/ã‚¹ãƒˆãƒªãƒ¼ãƒ ï¼‰
- ãƒŸãƒ‹ãƒãƒƒãƒ—ï¼ˆå¡—ã‚ŠçŠ¶æ³ã®å¯è¦–åŒ–ï¼‰

---

### Step 3.1.1: æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠUI

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/AttackTypeSelectionUI.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒãƒˆãƒ«é–‹å§‹å‰ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠç”»é¢
- ãƒãƒˆãƒ«ä¸­ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´UIï¼ˆè¨­å®šã§æœ‰åŠ¹åŒ–æ™‚ï¼‰
- ç¾åœ¨ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®è¦–è¦šçš„è¡¨ç¤º
- ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **è¨­å®šé€£å‹•**: `AttackTypeSelectionSettings`ã®è¨­å®šã«å¿œã˜ã¦UIã‚’è¡¨ç¤º/éè¡¨ç¤º
- **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•**: `AttackTypeManager`ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­ã—ã¦UIã‚’æ›´æ–°
- **Inspectorè¨­å®š**: UIè¦ç´ ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class AttackTypeSelectionUI : MonoBehaviour
{
    [Header("UI Elements")]
    [SerializeField] private GameObject selectionPanel; // ãƒãƒˆãƒ«å‰é¸æŠãƒ‘ãƒãƒ«
    [SerializeField] private Button impactShotButton;
    [SerializeField] private Button streamPaintButton;
    [SerializeField] private TextMeshProUGUI currentTypeText;
    [SerializeField] private TextMeshProUGUI randomTimerText; // ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰ç”¨
    
    [Header("References")]
    [SerializeField] private AttackTypeManager attackTypeManager;
    [SerializeField] private AttackTypeSelectionSettings settings;
    
    void Start()
    {
        // ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­
        AttackTypeManager.OnAttackTypeChanged += UpdateUI;
        AttackTypeManager.OnAttackTypeSelected += OnTypeSelected;
        
        // ãƒœã‚¿ãƒ³è¨­å®š
        if (impactShotButton != null)
            impactShotButton.onClick.AddListener(() => SelectType(AttackType.ImpactShot));
        if (streamPaintButton != null)
            streamPaintButton.onClick.AddListener(() => SelectType(AttackType.StreamPaint));
        
        // åˆæœŸè¡¨ç¤º
        UpdateUI(AttackType.None);
        
        // ãƒãƒˆãƒ«å‰é¸æŠãŒå¿…è¦ãªå ´åˆ
        if (settings != null && settings.mode == AttackTypeSelectionMode.Manual && settings.selectBeforeBattle)
        {
            ShowSelectionPanel();
        }
    }
    
    void OnDestroy()
    {
        AttackTypeManager.OnAttackTypeChanged -= UpdateUI;
        AttackTypeManager.OnAttackTypeSelected -= OnTypeSelected;
    }
    
    void Update()
    {
        // ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º
        if (settings != null && settings.mode == AttackTypeSelectionMode.RandomTimed)
        {
            UpdateRandomTimer();
        }
    }
    
    private void SelectType(AttackType type)
    {
        if (attackTypeManager != null)
        {
            attackTypeManager.SelectAttackType(type);
        }
    }
    
    private void UpdateUI(AttackType type)
    {
        if (currentTypeText != null)
        {
            currentTypeText.text = type == AttackType.ImpactShot ? "ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆ" : "ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆ";
        }
        
        // ãƒãƒˆãƒ«ä¸­ã®å¤‰æ›´ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ã€å¤‰æ›´ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
        if (settings != null && settings.allowChangeDuringBattle)
        {
            // ãƒãƒˆãƒ«ä¸­ã®å¤‰æ›´UIã‚’è¡¨ç¤º
        }
    }
    
    private void OnTypeSelected(AttackType type)
    {
        // é¸æŠå®Œäº†æ™‚ã®å‡¦ç†
        if (selectionPanel != null && settings != null && settings.selectBeforeBattle)
        {
            selectionPanel.SetActive(false);
            // ãƒãƒˆãƒ«é–‹å§‹ã‚’é€šçŸ¥
        }
    }
    
    private void ShowSelectionPanel()
    {
        if (selectionPanel != null)
        {
            selectionPanel.SetActive(true);
        }
    }
    
    private void UpdateRandomTimer()
    {
        // ãƒ©ãƒ³ãƒ€ãƒ å¤‰æ›´ã¾ã§ã®æ®‹ã‚Šæ™‚é–“ã‚’è¡¨ç¤ºï¼ˆå®Ÿè£…ã¯AttackTypeManagerã‹ã‚‰å–å¾—ï¼‰
        if (randomTimerText != null)
        {
            // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºã®å®Ÿè£…
        }
    }
}
```

---

### Step 5.2: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/MenuSystem.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆã‚·ãƒ³ã‚°ãƒ«/ãƒãƒ«ãƒ/è¨­å®šï¼‰
- ã‚²ãƒ¼ãƒ è¨­å®šï¼ˆãƒãƒƒãƒæ™‚é–“ã€å¡—ã‚Šå¼·åº¦ãªã©ï¼‰
- ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºç”»é¢ï¼ˆè‰²ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé¸æŠï¼‰

---

## ğŸ¨ Phase 6: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆ2æœˆï¼šé«˜å„ªå…ˆåº¦ï¼‰

**ç›®æ¨™**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ãŸç›®ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹

### Step 6.1: ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Customization/InkCustomizer.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²ã®é¸æŠï¼ˆã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ï¼‰
- ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®é©ç”¨
- è¨­å®šã®ä¿å­˜ï¼ˆPlayerPrefsï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ãƒ†ãƒ¼ãƒã‚·ã‚¹ãƒ†ãƒ **: `InkTheme`ï¼ˆScriptableObjectï¼‰ã§è‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ã¾ã¨ã‚ã¦ç®¡ç†
- **ãƒ—ãƒ¬ãƒãƒ–åŒ–**: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªè¦ç´ ã¯å…¨ã¦ãƒ—ãƒ¬ãƒãƒ–åŒ–
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼**: è¨­å®šå¤‰æ›´æ™‚ã«å³åº§ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
- **ãƒ—ãƒªã‚»ãƒƒãƒˆç®¡ç†**: è¤‡æ•°ã®ãƒ†ãƒ¼ãƒãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "InkTheme", menuName = "Game/Customization/Ink Theme")]
public class InkTheme : ScriptableObject
{
    [Header("Colors")]
    public Color primaryColor = Color.red;
    public Color secondaryColor = Color.blue;
    public Gradient colorGradient;
    
    [Header("Materials")]
    public InkMaterialData materialData;
    public Texture2D customTexture;
    
    [Header("Effects")]
    public InkEffectSettings effectSettings;
    
    [Header("Visual Style")]
    [Range(0f, 1f)] public float glossiness = 0.5f;
    [Range(0f, 1f)] public float transparency = 0.8f;
    public bool useGlow = true;
    public Color glowColor = Color.white;
}

public class InkCustomizer : MonoBehaviour
{
    [SerializeField] private List<InkTheme> availableThemes;
    [SerializeField] private InkTheme currentTheme;
    [SerializeField] private IInkEffect inkEffect;
    
    public static event Action<InkTheme> OnThemeChanged;
    
    public void ApplyTheme(InkTheme theme)
    {
        currentTheme = theme;
        
        // ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’é©ç”¨
        if (inkEffect != null && theme.materialData != null)
        {
            inkEffect.SetMaterial(theme.materialData.material);
            inkEffect.SetColor(theme.primaryColor);
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
        OnThemeChanged?.Invoke(theme);
        
        // ä¿å­˜
        SaveTheme(theme);
    }
    
    public void SetColor(Color color)
    {
        if (currentTheme != null)
        {
            currentTheme.primaryColor = color;
            inkEffect?.SetColor(color);
        }
    }
    
    public void SetTexture(Texture2D texture)
    {
        if (currentTheme != null && currentTheme.materialData != null)
        {
            currentTheme.materialData.texture = texture;
            // ãƒãƒ†ãƒªã‚¢ãƒ«ã«å³åº§ã«åæ˜ 
        }
    }
    
    private void SaveTheme(InkTheme theme)
    {
        // PlayerPrefsã¾ãŸã¯JSONã§ä¿å­˜
        string themeName = theme.name;
        PlayerPrefs.SetString("SelectedInkTheme", themeName);
    }
    
    public InkTheme LoadTheme()
    {
        string themeName = PlayerPrefs.GetString("SelectedInkTheme", "DefaultTheme");
        return availableThemes.Find(t => t.name == themeName);
    }
}
```

---

### Step 6.2: ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Customization/SoundCustomizer.cs`

**å®Ÿè£…å†…å®¹**:
- å™´å°„éŸ³ã®å¤‰æ›´
- ä¸Šå¡—ã‚ŠéŸ³ã®å¤‰æ›´
- BGMè¨­å®š

---
```csharp
[CreateAssetMenu(fileName = "SpawnSettings", menuName = "Game/SinglePlayer/Spawn Settings")]
public class SpawnSettings : ScriptableObject
{
    [Header("Spawn Timing")]
    [Range(0.5f, 10f)] public float spawnInterval = 2f;
    [Range(1, 10)] public int maxMonstersOnScreen = 5;
    
    [Header("Difficulty")]
    public AnimationCurve difficultyCurve; // æ™‚é–“çµŒéã«ã‚ˆã‚‹é›£æ˜“åº¦å¤‰åŒ–
    [Range(1f, 5f)] public float speedMultiplierMax = 3f;
}

public class MonsterSpawner : MonoBehaviour
{
    [SerializeField] private SpawnSettings settings;
    [SerializeField] private MonsterSettings monsterSettings;
    [SerializeField] private List<IMonsterMovement> movementPatterns;
    
    private float spawnTimer = 0f;
    private List<Monster> activeMonsters = new List<Monster>();
    private float gameTime = 0f;
    
    void Update()
    {
        gameTime += Time.deltaTime;
        spawnTimer += Time.deltaTime;
        
        // ç”Ÿæˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒã‚§ãƒƒã‚¯
        float currentInterval = settings.spawnInterval / GetDifficultyMultiplier();
        if (spawnTimer >= currentInterval && activeMonsters.Count < settings.maxMonstersOnScreen)
        {
            SpawnMonster();
            spawnTimer = 0f;
        }
        
        // ç”»é¢å¤–ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤
        RemoveOffScreenMonsters();
    }
    
    private void SpawnMonster()
    {
        GameObject monsterObj = Instantiate(monsterSettings.monsterPrefab);
        Monster monster = monsterObj.GetComponent<Monster>();
        
        // ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
        IMonsterMovement pattern = movementPatterns[Random.Range(0, movementPatterns.Count)];
        monster.SetMovementPattern(pattern);
        
        // ç”»é¢ç«¯ã‹ã‚‰å‡ºç¾
        Vector2 spawnPos = GetRandomSpawnPosition();
        monster.transform.position = spawnPos;
        
        activeMonsters.Add(monster);
        Monster.OnMonsterDefeated += OnMonsterDefeated;
    }
    
    private float GetDifficultyMultiplier()
    {
        return 1f + (settings.difficultyCurve.Evaluate(gameTime / 60f) * (settings.speedMultiplierMax - 1f));
    }
    
    private void OnMonsterDefeated(Monster monster)
    {
        activeMonsters.Remove(monster);
    }
}
```

---

### Step 3.3: å½“ãŸã‚Šåˆ¤å®šã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/MonsterHitDetector.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¤ãƒ³ã‚¯ãŒãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã«å½“ãŸã£ãŸã‹ã®åˆ¤å®š
- å½“ãŸã£ãŸæ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
- ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†ç”Ÿ

**å®Ÿè£…æ–¹é‡**:
```csharp
public class MonsterHitDetector : MonoBehaviour
{
    [SerializeField] private PaintSystem paintSystem;
    [SerializeField] private List<Monster> monsters;
    
    public static event Action<Vector2, Monster> OnMonsterHit;
    
    void Update()
    {
        // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰æœ€æ–°ã®å¡—ã‚Šä½ç½®ã‚’å–å¾—
        Vector2 lastPaintPos = paintSystem.GetLastPaintPosition();
        
        // å„ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨ã®è·é›¢ã‚’ãƒã‚§ãƒƒã‚¯
        foreach (Monster monster in monsters)
        {
            float distance = Vector2.Distance(lastPaintPos, monster.GetPosition());
            float hitRadius = monster.GetHitRadius();
            
            if (distance < hitRadius)
            {
                // ãƒ’ãƒƒãƒˆå‡¦ç†
                monster.TakeDamage(1);
                OnMonsterHit?.Invoke(lastPaintPos, monster);
            }
        }
    }
}
```

---

### Step 3.4: ã‚¹ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/ScoreManager.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ™‚ã®ã‚¹ã‚³ã‚¢è¨ˆç®—
- ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ ï¼ˆé€£ç¶šæ’ƒç ´ãƒœãƒ¼ãƒŠã‚¹ï¼‰
- ã‚¹ã‚³ã‚¢è¡¨ç¤º
- ãƒ©ãƒ³ã‚­ãƒ³ã‚°ä¿å­˜

**å®Ÿè£…æ–¹é‡**:
```csharp
[CreateAssetMenu(fileName = "ScoreSettings", menuName = "Game/SinglePlayer/Score Settings")]
public class ScoreSettings : ScriptableObject
{
    [Header("Score Values")]
    public int baseScorePerMonster = 100;
    public int comboBonusMultiplier = 10;
    [Range(2, 10)] public int maxCombo = 5;
}

public class ScoreManager : MonoBehaviour
{
    [SerializeField] private ScoreSettings settings;
    
    private int currentScore = 0;
    private int currentCombo = 0;
    
    public static event Action<int> OnScoreUpdated;
    public static event Action<int> OnComboUpdated;
    
    void Start()
    {
        Monster.OnMonsterDefeated += OnMonsterDefeated;
    }
    
    private void OnMonsterDefeated(Monster monster)
    {
        // ã‚³ãƒ³ãƒœåŠ ç®—
        currentCombo = Mathf.Min(currentCombo + 1, settings.maxCombo);
        
        // ã‚¹ã‚³ã‚¢è¨ˆç®—
        int scoreGain = settings.baseScorePerMonster + (currentCombo * settings.comboBonusMultiplier);
        currentScore += scoreGain;
        
        OnScoreUpdated?.Invoke(currentScore);
        OnComboUpdated?.Invoke(currentCombo);
    }
    
    public void ResetCombo()
    {
        currentCombo = 0;
        OnComboUpdated?.Invoke(0);
    }
}
```

---

## ğŸ› Phase 7: æœ€é©åŒ–ã¨ãƒã‚°ä¿®æ­£ï¼ˆ3æœˆï¼‰

**ç›®æ¨™**: ãƒªãƒªãƒ¼ã‚¹æº–å‚™å®Œäº†

### Step 7.1: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°é »åº¦ã®æœ€é©åŒ–
- ãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°ã®åŠ¹ç‡åŒ–
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®å‰Šæ¸›

### Step 7.2: ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
- æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®å¼·åº¦èª¿æ•´
- å¡—ã‚Šé€Ÿåº¦ã®èª¿æ•´
- ãƒãƒƒãƒæ™‚é–“ã®èª¿æ•´

### Step 7.3: ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ”¹å–„
- UIã®æ–‡å­—ã‚µã‚¤ã‚ºèª¿æ•´
- è‰²è¦šå¤šæ§˜æ€§ã¸ã®é…æ…®ï¼ˆè‰²ã ã‘ã§ãªãå½¢çŠ¶ã§ã‚‚åŒºåˆ¥ï¼‰
- æ“ä½œèª¬æ˜ã®æ˜ç¢ºåŒ–

---

## ğŸ® Phase 8: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦ï¼‰ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰ï¼ˆ3æœˆä»¥é™ï¼‰

**ç›®æ¨™**: åŒä¸€ç«¯æœ«ã§ã®2äººå¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹

**æ³¨æ„**: ä»–ã®æ©Ÿèƒ½ãŒå®Œæˆã—ã¦ã‹ã‚‰å®Ÿè£…ã™ã‚‹ã€‚å„ªå…ˆé †ä½ã¯æœ€ã‚‚ä½ã„ã€‚

### Step 8.1: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PlayerManager.cs`

**å®Ÿè£…å†…å®¹**:
- è¤‡æ•°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç®¡ç†ï¼ˆIDã€è‰²ã€ã‚¹ã‚³ã‚¢ï¼‰
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã”ã¨ã®å¡—ã‚Šé¢ç©ã®è¿½è·¡

```csharp
public class PlayerManager : MonoBehaviour
{
    public class Player
    {
        public int playerId;
        public Color playerColor;
        public float paintedArea;
        public string playerName;
    }
    
    private List<Player> players = new List<Player>();
    
    public void RegisterPlayer(int id, Color color);
    public Player GetPlayer(int id);
    public Player GetWinner(); // å¡—ã‚Šé¢ç©æœ€å¤§ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
}
```

---

### Step 8.2: å‹åˆ©æ¡ä»¶åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/VictoryCondition.cs`

**å®Ÿè£…å†…å®¹**:
- åˆ¶é™æ™‚é–“ã®ç®¡ç†
- å¡—ã‚Šé¢ç©ã®è¨ˆç®—ã¨æ¯”è¼ƒ
- å‹åˆ©åˆ¤å®šã¨çµæœè¡¨ç¤º

```csharp
public class VictoryCondition : MonoBehaviour
{
    public float matchDuration = 180f; // 3åˆ†
    private float remainingTime;
    
    void Update()
    {
        remainingTime -= Time.deltaTime;
        if (remainingTime <= 0f)
        {
            EndMatch();
        }
    }
    
    private void EndMatch()
    {
        Player winner = playerManager.GetWinner();
        // çµæœè¡¨ç¤ºUIã‚’è¡¨ç¤º
    }
}
```

---

### Step 8.3: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ã®å®Ÿè£…

**å®Ÿè£…å†…å®¹**:
- åŒä¸€ç«¯æœ«ã§ã®è¤‡æ•°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚­ãƒ¼å…¥åŠ›ã¾ãŸã¯è‡ªå‹•ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
- å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®éŸ³å£°å…¥åŠ›ã‚’å€‹åˆ¥ã«å‡¦ç†

**è€ƒæ…®äº‹é …**:
- ãƒã‚¤ã‚¯å…¥åŠ›ã®åˆ‡ã‚Šæ›¿ãˆï¼ˆè¤‡æ•°ãƒã‚¤ã‚¯å¯¾å¿œï¼‰
- ã¾ãŸã¯ã€éŸ³å£°ã®ç‰¹å¾´ï¼ˆãƒ”ãƒƒãƒ/ãƒœãƒªãƒ¥ãƒ¼ãƒ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è­˜åˆ¥

---

## ğŸ“ å®Ÿè£…ã®å„ªå…ˆé †ä½ï¼ˆè©³ç´°ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼‰

### ğŸ”´ Phase 1: ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæœ€å„ªå…ˆï¼‰
1. PaintCanvas ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 1.1.1ï¼‰
2. åº§æ¨™å¤‰æ›ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 1.1.2ï¼‰
3. ã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆStep 1.1.3ï¼‰
4. æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 1.2.1ï¼‰
5. å„é¸æŠãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…ï¼ˆStep 1.2.2ï¼‰
6. æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆè‡ªå‹•åˆ¤å®šç”¨ã€Step 1.2.3ï¼‰
7. æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¥å¡—ã‚Šãƒ­ã‚¸ãƒƒã‚¯ï¼ˆStep 1.2.4ï¼‰
8. ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼çµ±åˆï¼ˆStep 1.3ï¼‰

### ğŸŸ¢ Phase 2: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå®Ÿè£…é›£æ˜“åº¦ï¼šä½ï¼‰
9. ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿ä½¿ç”¨ï¼‰
10. ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨UIï¼ˆã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã€è‰²é¸æŠãªã©ï¼‰
11. ä¿å­˜æ©Ÿèƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

### ğŸŸ¡ Phase 3: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ï¼ˆå„ªå…ˆå®Ÿè£…ï¼‰
12. ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 5.1ï¼‰
13. ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 5.2ï¼‰
14. å½“ãŸã‚Šåˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 5.3ï¼‰
15. ã‚¹ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 5.4ï¼‰
16. ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ç”¨UIï¼ˆã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºï¼‰

### ğŸŸ¢ Phase 4: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã®æ¬¡ï¼‰
17. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å®Ÿè£…ï¼ˆStep 3.1ï¼‰
18. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸã‚·ã‚¹ãƒ†ãƒ 
19. ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°

### ğŸ”µ Phase 5: UI/UXå®Ÿè£…
20. ã‚²ãƒ¼ãƒ ç”»é¢UIï¼ˆStep 4.1ï¼‰
21. æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠUIï¼ˆStep 4.1.1ï¼‰
22. ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 4.2ï¼‰
23. ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### ğŸŸ£ Phase 6: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ 
24. ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼ˆStep 5.1ï¼‰
25. ã‚µã‚¦ãƒ³ãƒ‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼ˆStep 5.2ï¼‰

### âšª Phase 7: æœ€é©åŒ–ã¨ãƒã‚°ä¿®æ­£
26. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
27. ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
28. ãƒã‚°ä¿®æ­£

### ğŸ”´ Phase 8: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦ï¼‰ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰
29. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 3.1ï¼‰
30. å‹åˆ©æ¡ä»¶åˆ¤å®šï¼ˆStep 3.2ï¼‰
31. ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒå®Ÿè£…ï¼ˆStep 3.3ï¼‰
32. å¯¾æˆ¦ç”¨UIï¼ˆå¡—ã‚Šé¢ç©è¡¨ç¤ºã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰

---

## ğŸ”§ æŠ€è¡“çš„ãªè€ƒæ…®äº‹é …

### å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†æ–¹æ³•
- **Option 1**: Texture2Dï¼ˆå„ãƒ”ã‚¯ã‚»ãƒ«ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’è¨˜éŒ²ï¼‰
  - ãƒ¡ãƒªãƒƒãƒˆ: è¦–è¦šçš„ã€Unityæ¨™æº–
  - ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¤§ãã„
  
- **Option 2**: 2Dé…åˆ—ï¼ˆint[,]ï¼‰
  - ãƒ¡ãƒªãƒƒãƒˆ: è»½é‡ã€é«˜é€Ÿã‚¢ã‚¯ã‚»ã‚¹
  - ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ: å¯è¦–åŒ–ã«è¿½åŠ å‡¦ç†ãŒå¿…è¦

- **æ¨å¥¨**: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ï¼ˆå†…éƒ¨ã¯é…åˆ—ã€è¡¨ç¤ºã¯Texture2Dï¼‰

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸ
- å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã¯é »ç¹ã«æ›´æ–°ã•ã‚Œã‚‹ãŸã‚ã€å…¨ãƒ”ã‚¯ã‚»ãƒ«ã‚’åŒæœŸã™ã‚‹ã®ã¯éåŠ¹ç‡
- å·®åˆ†æ›´æ–°ï¼ˆå¤‰æ›´ã•ã‚ŒãŸé ˜åŸŸã®ã¿é€ä¿¡ï¼‰ã‚’å®Ÿè£…
- ã¾ãŸã¯ã€å¡—ã‚Šã‚³ãƒãƒ³ãƒ‰ï¼ˆä½ç½®ã€ã‚¿ã‚¤ãƒ—ã€å¼·åº¦ï¼‰ã®ã¿ã‚’åŒæœŸ

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- å¡—ã‚Šå‡¦ç†ã¯æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€æœ€é©åŒ–ãŒé‡è¦
- å¡—ã‚Šç¯„å›²ã‚’åˆ¶é™ï¼ˆç”»é¢å¤–ã¯å‡¦ç†ã—ãªã„ï¼‰
- æ›´æ–°é »åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆä¾‹: 60fps â†’ 30fpsã§å¡—ã‚Šæ›´æ–°ï¼‰

---

## ğŸ“š å‚è€ƒãƒªã‚½ãƒ¼ã‚¹

- Unity RenderTexture ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- Unity Netcode for GameObjectsï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒç”¨ï¼‰
- Unity Particle Systemï¼ˆã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ï¼‰
- Unity UI Toolkitï¼ˆUIå®Ÿè£…ç”¨ï¼‰

---

## âœ… å¤‰æ›´ã—ã‚„ã™ã•ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

å„å®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—ã§ã€ä»¥ä¸‹ã®é …ç›®ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

### è¨­è¨ˆãƒã‚§ãƒƒã‚¯
- [ ] **ScriptableObjectè¨­å®š**: èª¿æ•´ãŒå¿…è¦ãªå€¤ã¯å…¨ã¦ScriptableObjectã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **Inspectoræ¥ç¶š**: ä¾å­˜é–¢ä¿‚ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã‹ï¼Ÿï¼ˆFindObjectOfTypeã‚’é¿ã‘ã‚‹ï¼‰
- [ ] **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: å·®ã—æ›¿ãˆãŒå¿…è¦ãªæ©Ÿèƒ½ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ãŒåå¿œã™ã¹ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **Tooltip/Header**: å…¨ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«èª¬æ˜ã¨ãƒ˜ãƒƒãƒ€ãƒ¼ãŒä»˜ã„ã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **Rangeåˆ¶é™**: æ•°å€¤ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«é©åˆ‡ãªç¯„å›²åˆ¶é™ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ

### ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯
- [ ] **å˜ä¸€è²¬ä»»**: å„ã‚¯ãƒ©ã‚¹ã¯1ã¤ã®è²¬ä»»ã®ã¿ã‚’æŒã£ã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ä¾å­˜æ€§æ³¨å…¥**: ä¾å­˜é–¢ä¿‚ã¯å¤–éƒ¨ã‹ã‚‰æ³¨å…¥å¯èƒ½ã‹ï¼Ÿ
- [ ] **æ‹¡å¼µæ€§**: æ–°ã—ã„æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹éš›ã€æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ãŒæœ€å°é™ã‹ï¼Ÿ
- [ ] **ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§**: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆãŒæ›¸ãã‚„ã™ã„æ§‹é€ ã‹ï¼Ÿ

### ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ãƒã‚§ãƒƒã‚¯
- [ ] **è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«**: ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ã«ã‚³ãƒ¼ãƒ‰å¤‰æ›´ã¯ä¸è¦ã‹ï¼Ÿ
- [ ] **ãƒ—ãƒªã‚»ãƒƒãƒˆ**: è¤‡æ•°ã®ãƒãƒ©ãƒ³ã‚¹ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹ã‹ï¼Ÿ
- [ ] **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ èª¿æ•´**: å®Ÿè¡Œä¸­ã«è¨­å®šã‚’å¤‰æ›´ã—ã¦ãƒ†ã‚¹ãƒˆã§ãã‚‹ã‹ï¼Ÿï¼ˆEditoræ‹¡å¼µï¼‰

### ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯æŸ”è»Ÿæ€§ãƒã‚§ãƒƒã‚¯
- [ ] **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæŠ½è±¡åŒ–**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè£…ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ãƒãƒ†ãƒªã‚¢ãƒ«ç®¡ç†**: ãƒãƒ†ãƒªã‚¢ãƒ«ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€è‰²ã¯ScriptableObjectã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ãƒ—ãƒ¬ãƒãƒ–åŒ–**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ¬ãƒãƒ–åŒ–ã•ã‚Œã€Inspectorã§å·®ã—æ›¿ãˆå¯èƒ½ã‹ï¼Ÿ
- [ ] **å‹•çš„å¤‰æ›´**: å®Ÿè¡Œä¸­ã«ãƒãƒ†ãƒªã‚¢ãƒ«ã‚„è‰²ã‚’å¤‰æ›´ã§ãã‚‹APIãŒã‚ã‚‹ã‹ï¼Ÿ
- [ ] **ãƒ†ãƒ¼ãƒã‚·ã‚¹ãƒ†ãƒ **: ãƒ†ãƒ¼ãƒï¼ˆè‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰ã‚’ã¾ã¨ã‚ã¦ç®¡ç†ã§ãã‚‹ã‹ï¼Ÿ
- [ ] **ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**: Built-in/URP/HDRPã«å¯¾å¿œã§ãã‚‹è¨­è¨ˆã‹ï¼Ÿ
- [ ] **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºä¿å­˜**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºè¨­å®šãŒä¿å­˜ãƒ»èª­ã¿è¾¼ã¿å¯èƒ½ã‹ï¼Ÿ

---

## âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Phase 1 å®Œäº†æ¡ä»¶
- [ ] å£°ã‚’å‡ºã™ã¨ç”»é¢ã®æŒ‡å®šä½ç½®ã«è‰²ãŒå¡—ã‚‰ã‚Œã‚‹
- [ ] ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã¨ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆãŒæ­£ã—ãåˆ¤å®šã•ã‚Œã‚‹
- [ ] 2ç¨®é¡ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—ã§ç•°ãªã‚‹å¡—ã‚Šæ–¹ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] åŸºæœ¬çš„ãªã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ãŒå‹•ä½œã™ã‚‹

### Phase 2 å®Œäº†æ¡ä»¶ï¼ˆã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼‰
- [ ] å£°ã§è‡ªç”±ã«çµµã‚’æã‘ã‚‹
- [ ] ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢ã§ãã‚‹
- [ ] ã‚¤ãƒ³ã‚¯ã®è‰²ã‚’é¸æŠã§ãã‚‹ï¼ˆãƒœã‚¿ãƒ³ã€ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã€ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ‘ãƒ¬ãƒƒãƒˆã®ã„ãšã‚Œã‹ï¼‰
- [ ] æ¶ˆã—ã‚´ãƒ æ©Ÿèƒ½ãŒå‹•ä½œã™ã‚‹ï¼ˆå£°ã§æ¶ˆå»ä½ç½®ã‚’æŒ‡å®šï¼‰
- [ ] å·»ãæˆ»ã—æ©Ÿèƒ½ãŒå‹•ä½œã™ã‚‹ï¼ˆä¸€å›å‰ã®çŠ¶æ…‹ã«æˆ»ã‚‹ï¼‰
- [ ] ç”»åƒã‚’ä¿å­˜ã§ãã‚‹ï¼ˆPNGå½¢å¼ï¼‰
- [ ] ç”»åƒã‚’å…±æœ‰ã§ãã‚‹ï¼ˆãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ åˆ¥ã®å…±æœ‰æ©Ÿèƒ½ï¼‰
- [ ] ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ã§éŠã¹ã‚‹çŠ¶æ…‹ã«ãªã‚‹

### Phase 3 å®Œäº†æ¡ä»¶
- [ ] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒç”»é¢ã‚’ç§»å‹•ã™ã‚‹
- [ ] ã‚¤ãƒ³ã‚¯ãŒãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã«å½“ãŸã‚‹ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
- [ ] ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ™‚ã«ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã‚‹
- [ ] ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ã§éŠã¹ã‚‹çŠ¶æ…‹ã«ãªã‚‹

### Phase 4 å®Œäº†æ¡ä»¶
- [ ] ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹
- [ ] å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ãŒåŒæœŸã•ã‚Œã‚‹
- [ ] ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°ãŒå‹•ä½œã™ã‚‹

### Phase 5 å®Œäº†æ¡ä»¶
- [ ] ã‚²ãƒ¼ãƒ ç”»é¢ã«å¿…è¦ãªUIãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰å„ãƒ¢ãƒ¼ãƒ‰ã«é·ç§»ã§ãã‚‹
- [ ] è¨­å®šãŒä¿å­˜ãƒ»èª­ã¿è¾¼ã¾ã‚Œã‚‹

### Phase 6 å®Œäº†æ¡ä»¶
- [ ] ã‚¤ãƒ³ã‚¯ã®è‰²ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹
- [ ] ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã§ãã‚‹
- [ ] ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºè¨­å®šãŒä¿å­˜ã•ã‚Œã‚‹

### Phase 7 å®Œäº†æ¡ä»¶
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ãŒå®Œäº†ã—ã¦ã„ã‚‹
- [ ] ãƒã‚°ãŒä¿®æ­£ã•ã‚Œã¦ã„ã‚‹

### Phase 8 å®Œäº†æ¡ä»¶ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰
- [ ] è¤‡æ•°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§å¯¾æˆ¦ã§ãã‚‹
- [ ] å¡—ã‚Šé¢ç©ãŒæ­£ã—ãè¨ˆç®—ã•ã‚Œã‚‹
- [ ] åˆ¶é™æ™‚é–“çµ‚äº†æ™‚ã«å‹åˆ©åˆ¤å®šãŒè¡Œã‚ã‚Œã‚‹
- [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãŒå‹•ä½œã™ã‚‹


