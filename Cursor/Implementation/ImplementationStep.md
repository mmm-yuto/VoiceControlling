# VO!CE Paint Battle å®Ÿè£…æ‰‹é †æ›¸

## ğŸ¯ è¨­è¨ˆåŸå‰‡ï¼šå¤‰æ›´ã—ã‚„ã™ã„å®Ÿè£…

### åŸºæœ¬æ–¹é‡
å…¨ã¦ã®å®Ÿè£…ã«ãŠã„ã¦ã€**è¨­å®šå¤‰æ›´ãƒ»æ©Ÿèƒ½è¿½åŠ ãƒ»ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ã‚’å®¹æ˜“ã«ã™ã‚‹**ã“ã¨ã‚’æœ€å„ªå…ˆã¨ã—ã¾ã™ã€‚

### 1. ScriptableObjectã«ã‚ˆã‚‹è¨­å®šç®¡ç†
**ç›®çš„**: ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã›ãšã«Inspectorã§è¨­å®šã‚’èª¿æ•´å¯èƒ½ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- ã‚²ãƒ¼ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå¡—ã‚Šå¼·åº¦ã€æ”»æ’ƒåˆ¤å®šé–¾å€¤ã€ãƒãƒƒãƒæ™‚é–“ãªã©ï¼‰ã¯å…¨ã¦ScriptableObjectã§ç®¡ç†
- ãƒ—ãƒ¬ãƒãƒ–ã‚„ã‚·ãƒ¼ãƒ³ã«ç›´æ¥å€¤ã‚’æ›¸ã‹ãªã„
- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¤‡æ•°ä½œæˆã—ã€ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«ã™ã‚‹

**ä¾‹**:
```
Assets/ScriptableObjects/
â”œâ”€â”€ GameSettings.asset          // åŸºæœ¬ã‚²ãƒ¼ãƒ è¨­å®š
â”œâ”€â”€ PaintSettings.asset         // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ è¨­å®š
â”œâ”€â”€ AttackSettings.asset        // æ”»æ’ƒã‚¿ã‚¤ãƒ—è¨­å®š
â””â”€â”€ BalancePresets/             // ãƒãƒ©ãƒ³ã‚¹ãƒ—ãƒªã‚»ãƒƒãƒˆ
    â”œâ”€â”€ FastPaced.asset
    â”œâ”€â”€ Strategic.asset
    â””â”€â”€ Casual.asset
```

### 2. ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
**ç›®çš„**: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–“ã®çµåˆã‚’ç·©ãã—ã€æ©Ÿèƒ½è¿½åŠ ã‚’å®¹æ˜“ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- UnityEventã‚„C#ã®Action/Eventã‚’ä½¿ç”¨
- ç›´æ¥å‚ç…§ã§ã¯ãªãã€ã‚¤ãƒ™ãƒ³ãƒˆã§é€šä¿¡
- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã«ã™ã‚‹

**ä¾‹**:
```csharp
// å¡—ã‚Šã‚¤ãƒ™ãƒ³ãƒˆ
public static event Action<Vector2, int, float> OnPaint;
// æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
public static event Action<AttackType> OnAttackTypeChanged;
// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ã‚³ã‚¢æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆ
public static event Action<int, float> OnScoreUpdated;
```

### 3. ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹/æŠ½è±¡ã‚¯ãƒ©ã‚¹ã®æ´»ç”¨
**ç›®çš„**: å®Ÿè£…ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«ã—ã€æ‹¡å¼µæ€§ã‚’é«˜ã‚ã‚‹

**å®Ÿè£…æ–¹é‡**:
- æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šã€å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã€AIè¡Œå‹•ãªã©ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–
- æ–°ã—ã„æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚„AIè¡Œå‹•ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã ã‘

**ä¾‹**:
```csharp
// æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
public interface IAttackTypeDetector
{
    AttackType DetectAttackType(float volume, float pitch, float deltaTime);
}

// å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
public interface IPaintStrategy
{
    void Paint(Vector2 position, int playerId, float intensity);
}
```

### 4. ãƒ‡ãƒ¼ã‚¿ã¨ãƒ­ã‚¸ãƒƒã‚¯ã®åˆ†é›¢
**ç›®çš„**: ãƒãƒ©ãƒ³ã‚¹èª¿æ•´æ™‚ã«ãƒ­ã‚¸ãƒƒã‚¯ã‚’è§¦ã‚‰ãšã«æ¸ˆã‚€ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- è¨ˆç®—å¼ã®ä¿‚æ•°ã‚„é–¾å€¤ã¯å…¨ã¦ScriptableObjectã«
- ãƒ­ã‚¸ãƒƒã‚¯ã¯ãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã™ã‚‹ã ã‘
- è¨ˆç®—å¼è‡ªä½“ã‚‚è¨­å®šå¯èƒ½ã«ã™ã‚‹ï¼ˆä¾‹: AnimationCurveï¼‰

### 5. Inspectorã§èª¿æ•´å¯èƒ½ãªè¨­è¨ˆ
**ç›®çš„**: ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼ã§ãªãã¦ã‚‚èª¿æ•´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- å…¨ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«`[Header]`ã€`[Tooltip]`ã‚’ä»˜ã‘ã‚‹
- ç¯„å›²åˆ¶é™`[Range(min, max)]`ã‚’ä½¿ç”¨
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’é©åˆ‡ã«è¨­å®š

### 6. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã¨ä¾å­˜æ€§ã®æœ€å°åŒ–
**ç›®çš„**: ä¸€éƒ¨ã®å¤‰æ›´ãŒä»–ã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- å„ã‚·ã‚¹ãƒ†ãƒ ã¯ç‹¬ç«‹ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã—ã¦å®Ÿè£…
- ä¾å­˜é–¢ä¿‚ã¯æ˜ç¤ºçš„ã«ï¼ˆInspectorã§æ¥ç¶šã€ã¾ãŸã¯Service Locatorãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã¯æœ€å°é™ã«

### 7. ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã®æŸ”è»Ÿæ€§
**ç›®çš„**: è¦‹ãŸç›®ã‚’ç°¡å˜ã«å¤‰æ›´ãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

**å®Ÿè£…æ–¹é‡**:
- **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æŠ½è±¡åŒ–**: `IInkEffect`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè£…ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ãƒãƒ†ãƒªã‚¢ãƒ«ç®¡ç†**: `InkMaterialData`ï¼ˆScriptableObjectï¼‰ã§ãƒãƒ†ãƒªã‚¢ãƒ«ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€è‰²ã‚’ç®¡ç†
- **ãƒ—ãƒ¬ãƒãƒ–ãƒ™ãƒ¼ã‚¹**: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ¬ãƒãƒ–åŒ–ã—ã€Inspectorã§å·®ã—æ›¿ãˆå¯èƒ½ã«
- **å‹•çš„å¤‰æ›´**: å®Ÿè¡Œä¸­ã«ãƒãƒ†ãƒªã‚¢ãƒ«ã‚„è‰²ã‚’å¤‰æ›´ã§ãã‚‹APIã‚’æä¾›
- **ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å¯¾å¿œ**: Built-in/URP/HDRPã«å¯¾å¿œã§ãã‚‹è¨­è¨ˆ
- **ãƒ†ãƒ¼ãƒã‚·ã‚¹ãƒ†ãƒ **: UIãƒ†ãƒ¼ãƒã‚„ã‚¤ãƒ³ã‚¯ãƒ†ãƒ¼ãƒã‚’ScriptableObjectã§ç®¡ç†

**ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯è¨­å®šã®æ§‹é€ **:
```
Assets/ScriptableObjects/Graphics/
â”œâ”€â”€ InkEffectSettings.asset        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š
â”œâ”€â”€ InkMaterialData.asset          // ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
â”œâ”€â”€ PlayerColorTheme.asset         // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²ãƒ†ãƒ¼ãƒ
â”œâ”€â”€ UISettings.asset               // UIè¨­å®š
â””â”€â”€ Themes/                        // ãƒ†ãƒ¼ãƒãƒ—ãƒªã‚»ãƒƒãƒˆ
    â”œâ”€â”€ DefaultTheme.asset
    â”œâ”€â”€ NeonTheme.asset
    â””â”€â”€ PaintTheme.asset
```

---

## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²

### ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²ã®åŸºæœ¬æ–¹é‡

**åˆ†å‰²ã®åŸå‰‡**:
1. **æ©Ÿèƒ½ã”ã¨ã«åˆ†å‰²**: å„ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯1ã¤ã®è²¬ä»»ã‚’æŒã¤
2. **ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§æ•´ç†**: æ©Ÿèƒ½ã”ã¨ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’åˆ†ã‘ã‚‹
3. **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§æŠ½è±¡åŒ–**: å·®ã—æ›¿ãˆå¯èƒ½ãªæ©Ÿèƒ½ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–
4. **è¨­å®šã¯ScriptableObject**: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ScriptableObjectã§ç®¡ç†

### æ¨å¥¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
Assets/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ VoiceDetection/          // éŸ³å£°æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ—¢å­˜ï¼‰
â”‚   â”‚   â”œâ”€â”€ VoiceDetector.cs
â”‚   â”‚   â”œâ”€â”€ VolumeAnalyzer.cs
â”‚   â”‚   â”œâ”€â”€ ImprovedPitchAnalyzer.cs
â”‚   â”‚   â””â”€â”€ VoiceCalibrator.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ GameLogic/               // ã‚²ãƒ¼ãƒ ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”‚   â”œâ”€â”€ PaintCanvas.cs       // å¡—ã‚Šã‚­ãƒ£ãƒ³ãƒã‚¹
â”‚   â”‚   â”œâ”€â”€ PaintSystem.cs       // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ PaintBattleGameManager.cs  // ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
â”‚   â”‚   â”œâ”€â”€ VoiceToScreenMapper.cs      // åº§æ¨™å¤‰æ›
â”‚   â”‚   â”œâ”€â”€ AttackTypeManager.cs       // æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠãƒ»ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ AttackTypeDetector.cs      // æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆè‡ªå‹•åˆ¤å®šç”¨ï¼‰
â”‚   â”‚   â””â”€â”€ AttackTypeSelectors/       // é¸æŠãƒ¢ãƒ¼ãƒ‰å®Ÿè£…
â”‚   â”‚       â”œâ”€â”€ AutoAttackTypeSelector.cs
â”‚   â”‚       â”œâ”€â”€ ManualAttackTypeSelector.cs
â”‚   â”‚       â”œâ”€â”€ RandomTimedAttackTypeSelector.cs
â”‚   â”‚       â””â”€â”€ RandomOnPaintAttackTypeSelector.cs
â”‚   â”‚   â”œâ”€â”€ PlayerManager.cs            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ LocalPlayerManager.cs       // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç”¨
â”‚   â”‚   â”œâ”€â”€ VictoryCondition.cs         // å‹åˆ©æ¡ä»¶
â”‚   â”‚   â””â”€â”€ GameplayManager.cs          // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ Graphics/                 // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ InkEffect.cs          // ã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
â”‚   â”‚   â”œâ”€â”€ PaintRenderer.cs      // å¡—ã‚Šæç”»
â”‚   â”‚   â””â”€â”€ EffectPool.cs         // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«
â”‚   â”‚
â”‚   â”œâ”€â”€ Network/                   // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
â”‚   â”‚   â”œâ”€â”€ NetworkManager.cs     // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ NetworkPaintSync.cs   // å¡—ã‚Šãƒ‡ãƒ¼ã‚¿åŒæœŸ
â”‚   â”‚   â””â”€â”€ NetworkPlayerSync.cs  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŒæœŸ
â”‚   â”‚
â”‚   â”œâ”€â”€ SinglePlayer/              // ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¤‡æ•°ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œï¼‰
â”‚   â”‚   â”œâ”€â”€ SinglePlayerModeManager.cs  // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ ScoreManager.cs       // ã‚¹ã‚³ã‚¢ç®¡ç†ï¼ˆå…±é€šï¼‰
â”‚   â”‚   â”œâ”€â”€ Modes/                // å„ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰
â”‚   â”‚   â”‚   â”œâ”€â”€ MonsterHuntMode.cs      // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰
â”‚   â”‚   â”‚   â”œâ”€â”€ ColorDefenseMode.cs     // ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰
â”‚   â”‚   â”‚   â”œâ”€â”€ TracingMode.cs          // ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰
â”‚   â”‚   â”‚   â””â”€â”€ AIBattleMode.cs         // AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰
â”‚   â”‚   â”œâ”€â”€ Monster/              // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ç”¨
â”‚   â”‚   â”‚   â”œâ”€â”€ Monster.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ MonsterSpawner.cs
â”‚   â”‚   â”‚   â”œâ”€â”€ MonsterHitDetector.cs
â”‚   â”‚   â”‚   â””â”€â”€ MovementPatterns/
â”‚   â”‚   â”‚       â”œâ”€â”€ LinearMovement.cs
â”‚   â”‚   â”‚       â”œâ”€â”€ CurveMovement.cs
â”‚   â”‚   â”‚       â””â”€â”€ RandomMovement.cs
â”‚   â”‚   â”œâ”€â”€ ColorDefense/         // ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰ç”¨
â”‚   â”‚   â”‚   â””â”€â”€ ColorChangeArea.cs
â”‚   â”‚   â”œâ”€â”€ Tracing/              // ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ç”¨
â”‚   â”‚   â”‚   â””â”€â”€ TracingLine.cs
â”‚   â”‚   â””â”€â”€ AI/                   // AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ç”¨
â”‚   â”‚       â”œâ”€â”€ IAIPaintStrategy.cs
â”‚   â”‚       â”œâ”€â”€ RandomAIPaintStrategy.cs
â”‚   â”‚       â”œâ”€â”€ PatternAIPaintStrategy.cs
â”‚   â”‚       â”œâ”€â”€ AggressiveAIPaintStrategy.cs
â”‚   â”‚       â””â”€â”€ DefensiveAIPaintStrategy.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ UI/                        // UIã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ VoiceDisplay.cs       // éŸ³å£°è¡¨ç¤ºï¼ˆæ—¢å­˜ï¼‰
â”‚   â”‚   â”œâ”€â”€ VoiceScatterPlot.cs   // ã‚°ãƒ©ãƒ•è¡¨ç¤ºï¼ˆæ—¢å­˜ï¼‰
â”‚   â”‚   â”œâ”€â”€ GameHUD.cs            // ã‚²ãƒ¼ãƒ HUD
â”‚   â”‚   â”œâ”€â”€ AttackTypeSelectionUI.cs // æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠUI
â”‚   â”‚   â”œâ”€â”€ CreativeModeUI.cs     // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰UI
â”‚   â”‚   â”œâ”€â”€ MainMenuManager.cs    // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼
â”‚   â”‚   â”œâ”€â”€ SettingsPanel.cs     // è¨­å®šãƒ‘ãƒãƒ«
â”‚   â”‚   â”œâ”€â”€ CustomizationPanel.cs // ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‘ãƒãƒ«
â”‚   â”‚   â””â”€â”€ CalibrationPanel.cs  // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒãƒ«
â”‚   â”‚
â”‚   â”œâ”€â”€ Customization/             // ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”‚   â”œâ”€â”€ InkCustomizer.cs     // ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
â”‚   â”‚   â”œâ”€â”€ SoundCustomizer.cs   // ã‚µã‚¦ãƒ³ãƒ‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
â”‚   â”‚   â””â”€â”€ ThemeManager.cs      // ãƒ†ãƒ¼ãƒç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ SceneManagement/          // ã‚·ãƒ¼ãƒ³ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ SimpleSceneManager.cs
â”‚   â”‚   â””â”€â”€ GameDataManager.cs
â”‚   â”‚
â”‚   â”œâ”€â”€ Interfaces/               // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
â”‚   â”‚   â”œâ”€â”€ IPaintCanvas.cs
â”‚   â”‚   â”œâ”€â”€ IPaintStrategy.cs
â”‚   â”‚   â”œâ”€â”€ IAttackTypeDetector.cs
â”‚   â”‚   â”œâ”€â”€ IInkEffect.cs
â”‚   â”‚   â””â”€â”€ IPlayerManager.cs
â”‚   â”‚
â”‚   â””â”€â”€ Data/                     // ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ï¼ˆScriptableObjectï¼‰
â”‚       â”œâ”€â”€ Settings/
â”‚       â”‚   â”œâ”€â”€ GameSettings.cs
â”‚       â”‚   â”œâ”€â”€ PaintSettings.cs
â”‚       â”‚   â”œâ”€â”€ AttackSettings.cs
â”‚       â”‚   â””â”€â”€ AttackTypeSelectionSettings.cs
â”‚       â”œâ”€â”€ Graphics/
â”‚       â”‚   â”œâ”€â”€ InkEffectSettings.cs
â”‚       â”‚   â”œâ”€â”€ InkMaterialData.cs
â”‚       â”‚   â””â”€â”€ InkTheme.cs
â”‚       â”œâ”€â”€ Scene/
â”‚       â”‚   â”œâ”€â”€ SceneReference.cs
â”‚       â”‚   â””â”€â”€ GameData.cs
â”‚       â”œâ”€â”€ Creative/
â”‚       â”‚   â””â”€â”€ CreativeModeSettings.cs
â”‚       â””â”€â”€ SinglePlayer/
â”‚           â”œâ”€â”€ SinglePlayerGameModeSettings.cs  // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰è¨­å®šï¼ˆå…±é€šï¼‰
â”‚           â”œâ”€â”€ Modes/
â”‚           â”‚   â”œâ”€â”€ MonsterHuntSettings.cs
â”‚           â”‚   â”œâ”€â”€ ColorDefenseSettings.cs
â”‚           â”‚   â”œâ”€â”€ TracingSettings.cs
â”‚           â”‚   â”œâ”€â”€ TracingDrawingData.cs
â”‚           â”‚   â””â”€â”€ AIBattleSettings.cs
â”‚           â”œâ”€â”€ Monster/
â”‚           â”‚   â”œâ”€â”€ MonsterSettings.cs
â”‚           â”‚   â””â”€â”€ SpawnSettings.cs
â”‚           â””â”€â”€ ScoreSettings.cs
â”‚
â”œâ”€â”€ ScriptableObjects/            // ScriptableObjectã‚¢ã‚»ãƒƒãƒˆ
â”‚   â”œâ”€â”€ Settings/
â”‚   â”œâ”€â”€ Graphics/
â”‚   â””â”€â”€ Themes/
â”‚
â”œâ”€â”€ Prefabs/                      // ãƒ—ãƒ¬ãƒãƒ–
â”‚   â”œâ”€â”€ Effects/
â”‚   â”‚   â”œâ”€â”€ ImpactShotEffect.prefab
â”‚   â”‚   â””â”€â”€ StreamPaintEffect.prefab
â”‚   â””â”€â”€ UI/
â”‚
â””â”€â”€ Scenes/                       // ã‚·ãƒ¼ãƒ³
    â”œâ”€â”€ 00_MainMenu.unity
    â”œâ”€â”€ 01_Gameplay.unity
    â””â”€â”€ 99_Test.unity
```

### ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²ã®è©³ç´°

#### 1. VoiceDetection/ï¼ˆéŸ³å£°æ¤œå‡ºï¼‰
**å½¹å‰²**: ãƒã‚¤ã‚¯å…¥åŠ›ã‹ã‚‰éŸ³é‡ãƒ»ãƒ”ãƒƒãƒã‚’æ¤œå‡º

**åˆ†å‰²æ–¹é‡**:
- å„æ©Ÿèƒ½ã‚’ç‹¬ç«‹ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«
- æ—¢å­˜ã®å®Ÿè£…ã‚’ãã®ã¾ã¾ä½¿ç”¨

#### 2. GameLogic/ï¼ˆã‚²ãƒ¼ãƒ ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
**å½¹å‰²**: ã‚²ãƒ¼ãƒ ã®æ ¸ã¨ãªã‚‹ãƒ­ã‚¸ãƒƒã‚¯

**åˆ†å‰²æ–¹é‡**:
- **PaintCanvas.cs**: å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†ã®ã¿
- **PaintSystem.cs**: å¡—ã‚Šå‡¦ç†ã®å®Ÿè¡Œï¼ˆStrategy ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- **PaintBattleGameManager.cs**: å…¨ä½“ã®çµ±åˆãƒ»ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
- **AttackTypeManager.cs**: æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®é¸æŠãƒ»ç®¡ç†ï¼ˆè¤‡æ•°ã®é¸æŠãƒ¢ãƒ¼ãƒ‰ã«å¯¾å¿œï¼‰
- **AttackTypeDetector.cs**: æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆè‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
- **PlayerManager.cs**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…
- **LocalPlayerManager.cs**: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ç”¨ã®å®Ÿè£…

**ç†ç”±**: å„æ©Ÿèƒ½ã‚’ç‹¬ç«‹ã•ã›ã‚‹ã“ã¨ã§ã€ãƒ†ã‚¹ãƒˆãƒ»ä¿®æ­£ãƒ»æ‹¡å¼µãŒå®¹æ˜“

#### 3. Graphics/ï¼ˆã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ï¼‰
**å½¹å‰²**: è¦–è¦šçš„è¡¨ç¾

**åˆ†å‰²æ–¹é‡**:
- **InkEffect.cs**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†ç”Ÿãƒ»ç®¡ç†
- **PaintRenderer.cs**: å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®æç”»
- **EffectPool.cs**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

**ç†ç”±**: ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯å‡¦ç†ã‚’åˆ†é›¢ã—ã€ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å¤‰æ›´ã«å¯¾å¿œã—ã‚„ã™ã

#### 4. Network/ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
**å½¹å‰²**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤

**åˆ†å‰²æ–¹é‡**:
- **NetworkManager.cs**: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šç®¡ç†
- **NetworkPaintSync.cs**: å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
- **NetworkPlayerSync.cs**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®åŒæœŸ

**ç†ç”±**: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ©Ÿèƒ½ã‚’åˆ†é›¢ã—ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«å½±éŸ¿ã‚’ä¸ãˆãªã„

#### 5. SinglePlayer/ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ï¼‰
**å½¹å‰²**: è¤‡æ•°ã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’å®Ÿè£…ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ã€ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ã€ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã€AIå¯¾æˆ¦ï¼‰

**åˆ†å‰²æ–¹é‡**:
- **SinglePlayerModeManager.cs**: ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã®ç®¡ç†ãƒ»åˆ‡ã‚Šæ›¿ãˆ
- **Modes/**: å„ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ï¼‰
  - **MonsterHuntMode.cs**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰
  - **ColorDefenseMode.cs**: ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰
  - **TracingMode.cs**: ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰
  - **AIBattleMode.cs**: AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰
- **ScoreManager.cs**: ã‚¹ã‚³ã‚¢è¨ˆç®—ã€ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç®¡ç†ï¼ˆå…±é€šï¼‰
- **Monster/**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- **ColorDefense/**: ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- **Tracing/**: ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- **AI/**: AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ç”¨ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆAIæˆ¦ç•¥ã®å®Ÿè£…ï¼‰

**ç†ç”±**: å„ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’ç‹¬ç«‹ã•ã›ã€æ–°ã—ã„ãƒ¢ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã‚„ã™ãã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã«ã‚ˆã‚Šã€ãƒ¢ãƒ¼ãƒ‰é–“ã®åˆ‡ã‚Šæ›¿ãˆãŒå®¹æ˜“

#### 6. UI/ï¼ˆUIã‚·ã‚¹ãƒ†ãƒ ï¼‰
**å½¹å‰²**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

**åˆ†å‰²æ–¹é‡**:
- å„ç”»é¢ï¼ˆãƒ‘ãƒãƒ«ï¼‰ã”ã¨ã«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’åˆ†å‰²
- æ—¢å­˜ã®`VoiceDisplay`ã€`VoiceScatterPlot`ã¯ãã®ã¾ã¾ä½¿ç”¨

**ç†ç”±**: UIã®å¤‰æ›´ãŒä»–ã®ã‚·ã‚¹ãƒ†ãƒ ã«å½±éŸ¿ã—ãªã„ã‚ˆã†ã«

#### 7. Customization/ï¼ˆã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼‰
**å½¹å‰²**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

**åˆ†å‰²æ–¹é‡**:
- **InkCustomizer.cs**: ã‚¤ãƒ³ã‚¯é–¢é€£ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **SoundCustomizer.cs**: ã‚µã‚¦ãƒ³ãƒ‰é–¢é€£ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **ThemeManager.cs**: ãƒ†ãƒ¼ãƒã®ç®¡ç†

**ç†ç”±**: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ©Ÿèƒ½ã‚’ç‹¬ç«‹ã•ã›ã€æ‹¡å¼µã—ã‚„ã™ã

#### 8. Interfaces/ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰
**å½¹å‰²**: æŠ½è±¡åŒ–å®šç¾©

**åˆ†å‰²æ–¹é‡**:
- å„ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’1ãƒ•ã‚¡ã‚¤ãƒ«ã«1ã¤
- å®Ÿè£…ã¯åˆ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«

**ç†ç”±**: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®šç¾©ã‚’æ˜ç¢ºã«ã—ã€ä¾å­˜é–¢ä¿‚ã‚’æ•´ç†

#### 9. Data/ï¼ˆScriptableObjectï¼‰
**å½¹å‰²**: è¨­å®šãƒ‡ãƒ¼ã‚¿ã®å®šç¾©

**åˆ†å‰²æ–¹é‡**:
- æ©Ÿèƒ½ã”ã¨ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’åˆ†ã‘ã‚‹
- 1ã¤ã®ScriptableObjectã‚¯ãƒ©ã‚¹ = 1ãƒ•ã‚¡ã‚¤ãƒ«

**ç†ç”±**: è¨­å®šãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†ã‚’æ˜ç¢ºã«

### ã‚¹ã‚¯ãƒªãƒ—ãƒˆåˆ†å‰²ã®åˆ¤æ–­åŸºæº–

**1ã¤ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã¾ã¨ã‚ã‚‹ã¹ãå ´åˆ**:
- âœ… å¯†æ¥ã«é–¢é€£ã™ã‚‹æ©Ÿèƒ½ï¼ˆä¾‹: `PaintCanvas`ã¨ãã®æç”»å‡¦ç†ï¼‰
- âœ… å¸¸ã«ä¸€ç·’ã«ä½¿ã‚ã‚Œã‚‹æ©Ÿèƒ½
- âœ… å°è¦æ¨¡ãªãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹

**åˆ¥ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«åˆ†ã‘ã‚‹ã¹ãå ´åˆ**:
- âœ… **ç•°ãªã‚‹è²¬ä»»**: å¡—ã‚Šå‡¦ç†ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã¯åˆ¥
- âœ… **ç‹¬ç«‹ã—ã¦ãƒ†ã‚¹ãƒˆã—ãŸã„**: AIã¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¯åˆ¥
- âœ… **å·®ã—æ›¿ãˆå¯èƒ½ã«ã—ãŸã„**: Strategy ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å®Ÿè£…ã‚’åˆ†ã‘ã‚‹
- âœ… **é–‹ç™ºè€…ãŒç•°ãªã‚‹**: UIã¨ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã¯åˆ¥

### ä¾å­˜é–¢ä¿‚ã®ç®¡ç†

**ä¾å­˜é–¢ä¿‚ã®åŸå‰‡**:
- **ä¸Šä½å±¤ã‹ã‚‰ä¸‹ä½å±¤ã¸**: UI â†’ GameLogic â†’ VoiceDetection
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹çµŒç”±**: ç›´æ¥å‚ç…§ã§ã¯ãªãã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§æ¥ç¶š
- **Inspectorã§æ¥ç¶š**: ä¾å­˜é–¢ä¿‚ã¯Inspectorã§æ˜ç¤ºçš„ã«æ¥ç¶š

**ä¾å­˜é–¢ä¿‚ã®ä¾‹**:
```
UI/
  â””â”€â†’ GameLogic/ (ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹çµŒç”±)
        â””â”€â†’ VoiceDetection/
        â””â”€â†’ Graphics/
        â””â”€â†’ Network/ (æ¡ä»¶ä»˜ã)
        â””â”€â†’ AI/ (æ¡ä»¶ä»˜ã)
```

### å®Ÿè£…ã®å„ªå…ˆé †ä½ï¼ˆæ®µéšçš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼‰

**åŸºæœ¬æ–¹é‡**: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ã‚’å„ªå…ˆã—ã€ãã®æ¬¡ã«ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã‚’å®Ÿè£…ã€‚ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã¯æœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ã«ã™ã‚‹

1. **Phase 1: ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼‰**
   - `GameLogic/` - ã‚³ã‚¢ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã€æ”»æ’ƒã‚¿ã‚¤ãƒ—ï¼‰
   - `Graphics/` - åŸºæœ¬çš„ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
   - `Interfaces/` - ä¸»è¦ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
   - **ç›®æ¨™**: å£°ã§ç”»é¢ã«è‰²ã‚’å¡—ã‚Œã‚‹åŸºæœ¬æ©Ÿèƒ½ã‚’å®Œæˆ

2. **Phase 2: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå£°ã§çµµã‚’æããƒ¢ãƒ¼ãƒ‰ï¼‰ã€å®Ÿè£…é›£æ˜“åº¦ï¼šä½ã€‘**
   - `Creative/` - ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿ä½¿ç”¨ï¼‰
   - `UI/` - ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨ã®åŸºæœ¬UIï¼ˆã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã€è‰²é¸æŠãªã©ï¼‰
   - **ç›®æ¨™**: å£°ã§è‡ªç”±ã«çµµã‚’æã‘ã‚‹çŠ¶æ…‹ã«ã™ã‚‹
   - **ç‰¹å¾´**: ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰ã¯ä¸è¦ã€å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿ä½¿ç”¨

3. **Phase 3: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ï¼ˆå„ªå…ˆå®Ÿè£…ï¼‰**
   - `SinglePlayer/` - ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰
   - `UI/` - ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ç”¨ã®åŸºæœ¬UIï¼ˆã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰
   - **ç›®æ¨™**: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã§éŠã¹ã‚‹çŠ¶æ…‹ã«ã™ã‚‹

4. **Phase 4: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã®æ¬¡ï¼‰**
   - `Network/` - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å®Ÿè£…
   - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸã‚·ã‚¹ãƒ†ãƒ 
   - ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°
   - **ç›®æ¨™**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹

5. **Phase 5: UI/UXå®Ÿè£…**
   - `UI/GameHUD` - ã‚²ãƒ¼ãƒ ç”»é¢UI
   - `UI/MenuSystem` - ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 
   - `SceneManagement/` - ã‚·ãƒ¼ãƒ³ç®¡ç†
   - **ç›®æ¨™**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰å„ãƒ¢ãƒ¼ãƒ‰ã«é·ç§»ã§ãã‚‹

6. **Phase 6: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ **
   - `Customization/` - ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚µã‚¦ãƒ³ãƒ‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
   - **ç›®æ¨™**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ãŸç›®ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹

7. **Phase 7: æœ€é©åŒ–ã¨ãƒã‚°ä¿®æ­£**
   - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
   - ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
   - ãƒã‚°ä¿®æ­£
   - **ç›®æ¨™**: ãƒªãƒªãƒ¼ã‚¹æº–å‚™å®Œäº†

8. **Phase 8: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦ï¼‰ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰**
   - `GameLogic/PlayerManager` - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
   - `GameLogic/VictoryCondition` - å‹åˆ©æ¡ä»¶åˆ¤å®š
   - `UI/` - å¯¾æˆ¦ç”¨UIï¼ˆå¡—ã‚Šé¢ç©è¡¨ç¤ºã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰
   - **ç›®æ¨™**: åŒä¸€ç«¯æœ«ã§ã®2äººå¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹
   - **æ³¨æ„**: ä»–ã®æ©Ÿèƒ½ãŒå®Œæˆã—ã¦ã‹ã‚‰å®Ÿè£…ã™ã‚‹

---

## ğŸ“‹ ç¾åœ¨ã®å®Ÿè£…çŠ¶æ³

### âœ… å®Ÿè£…æ¸ˆã¿
- **éŸ³å£°æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ **
  - `VoiceDetector.cs` - ãƒã‚¤ã‚¯å…¥åŠ›ã®å–å¾—
  - `VolumeAnalyzer.cs` - éŸ³é‡ã®æ¤œå‡º
  - `ImprovedPitchAnalyzer.cs` - ãƒ”ãƒƒãƒã®é«˜ç²¾åº¦æ¤œå‡ºï¼ˆãƒ—ãƒªã‚¨ãƒ³ãƒ•ã‚¡ã‚·ã‚¹ã€DCé™¤å»ã€æ”¾ç‰©ç·šè£œé–“ï¼‰
  - `VoiceCalibrator.cs` - ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ï¼ˆãƒã‚¤ã‚ºè¨ˆæ¸¬ã€å‹•çš„é–¾å€¤è¨­å®šï¼‰

- **UIã‚·ã‚¹ãƒ†ãƒ **
  - `VoiceDisplay.cs` - éŸ³é‡ãƒ»ãƒ”ãƒƒãƒã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¡¨ç¤º
  - `VoiceScatterPlot.cs` - 2Dã‚°ãƒ©ãƒ•è¡¨ç¤ºï¼ˆVolumeÃ—Pitchã®å¯è¦–åŒ–ã€è»¸ã®é¸æŠå¯èƒ½ï¼‰

---

## ğŸ¬ ã‚·ãƒ¼ãƒ³æ§‹æˆã¨ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### ã‚·ãƒ¼ãƒ³åˆ†å‰²ã®æ–¹é‡ï¼ˆå°è¦æ¨¡ã‚²ãƒ¼ãƒ å‘ã‘ï¼‰

**åŸºæœ¬æ–¹é‡**: æœ€å°é™ã®ã‚·ãƒ¼ãƒ³åˆ†å‰²ã§ã€é–‹ç™ºåŠ¹ç‡ã¨ä¿å®ˆæ€§ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚‹

**ã‚·ãƒ¼ãƒ³ã‚’åˆ†ã‘ã‚‹ç†ç”±**:
1. **é–‹ç™ºåŠ¹ç‡**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¨ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚’åˆ†ã‘ã‚‹ã“ã¨ã§ã€ãƒ†ã‚¹ãƒˆãŒå®¹æ˜“
2. **ä¿å®ˆæ€§**: æ©Ÿèƒ½ã”ã¨ã«ã‚·ãƒ¼ãƒ³ãŒåˆ†ã‹ã‚Œã¦ã„ã‚‹ã¨ã€ãƒã‚°ä¿®æ­£ã‚„æ©Ÿèƒ½è¿½åŠ ãŒå®¹æ˜“
3. **ãƒ¡ãƒ¢ãƒªç®¡ç†**: ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ä¸­ã«ä¸è¦ãªãƒ¡ãƒ‹ãƒ¥ãƒ¼UIã‚’ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰

**æ³¨æ„**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€éåº¦ãªåˆ†å‰²ã¯é¿ã‘ã‚‹ã€‚ã‚·ãƒ¼ãƒ³é·ç§»ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¨é–‹ç™ºã®è¤‡é›‘ã•ã‚’è€ƒæ…®ã€‚

### æ¨å¥¨ã‚·ãƒ¼ãƒ³æ§‹æˆï¼ˆæœ€å°æ§‹æˆï¼‰

```
Assets/Scenes/
â”œâ”€â”€ 00_MainMenu.unity           // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ + è¨­å®š + ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼ˆçµ±åˆï¼‰
â”œâ”€â”€ 01_Gameplay.unity           // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ï¼ˆå…¨ãƒ¢ãƒ¼ãƒ‰å…±é€šï¼‰
â””â”€â”€ 99_Test.unity               // ãƒ†ã‚¹ãƒˆç”¨ã‚·ãƒ¼ãƒ³ï¼ˆé–‹ç™ºä¸­ã®ã¿ï¼‰
```

**æ§‹æˆã®è€ƒãˆæ–¹**:
- **ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€è¨­å®šã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’1ã¤ã®ã‚·ãƒ¼ãƒ³ã«çµ±åˆ
  - UIãƒ‘ãƒãƒ«ã§ç”»é¢ã‚’åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚·ãƒ¼ãƒ³é·ç§»ä¸è¦ï¼‰
  - ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå°ã•ã„ãŸã‚ã€çµ±åˆã—ã¦ã‚‚å•é¡Œãªã—
- **ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³**: ã‚·ãƒ³ã‚°ãƒ«ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å…¨ã¦ã‚’1ã¤ã®ã‚·ãƒ¼ãƒ³ã§å¯¾å¿œ
  - ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ‰ç„¡ã‚„è¨­å®šã§åˆ‡ã‚Šæ›¿ãˆ
  - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®è¿½åŠ /å‰Šé™¤ã§ã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚’åˆ‡ã‚Šæ›¿ãˆ

### å„ã‚·ãƒ¼ãƒ³ã®å½¹å‰²

#### 00_MainMenu.unityï¼ˆãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³ï¼‰
**ç›®çš„**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€è¨­å®šã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’çµ±åˆ

**å«ã¾ã‚Œã‚‹è¦ç´ **:
- **ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼UI**: ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰é¸æŠãƒœã‚¿ãƒ³
- **è¨­å®šãƒ‘ãƒãƒ«**: éŸ³é‡ã€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯å“è³ªãªã©ã®è¨­å®šï¼ˆUIãƒ‘ãƒãƒ«ã§è¡¨ç¤º/éè¡¨ç¤ºï¼‰
- **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‘ãƒãƒ«**: ã‚¤ãƒ³ã‚¯è‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£é¸æŠï¼ˆUIãƒ‘ãƒãƒ«ã§è¡¨ç¤º/éè¡¨ç¤ºï¼‰
- **ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒãƒ«**: éŸ³å£°å…¥åŠ›ã®ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆUIãƒ‘ãƒãƒ«ã§è¡¨ç¤º/éè¡¨ç¤ºï¼‰
- **ã‚·ãƒ¼ãƒ³ç®¡ç†**: ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ã¸ã®é·ç§»
- **æ°¸ç¶šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ**: è¨­å®šãƒ‡ãƒ¼ã‚¿ã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼ˆDontDestroyOnLoadï¼‰

**å®Ÿè£…æ–¹é‡**:
```csharp
public class MainMenuManager : MonoBehaviour
{
    [Header("UI Panels")]
    [SerializeField] private GameObject mainMenuPanel;
    [SerializeField] private GameObject settingsPanel;
    [SerializeField] private GameObject customizationPanel;
    [SerializeField] private GameObject calibrationPanel;
    
    [Header("Scene Management")]
    [SerializeField] private string gameplaySceneName = "01_Gameplay";
    
    void Start()
    {
        // åˆæœŸåŒ–å‡¦ç†
        LoadSettings();
        ShowMainMenu();
    }
    
    public void ShowMainMenu() => ShowPanel(mainMenuPanel);
    public void ShowSettings() => ShowPanel(settingsPanel);
    public void ShowCustomization() => ShowPanel(customizationPanel);
    public void ShowCalibration() => ShowPanel(calibrationPanel);
    
    private void ShowPanel(GameObject panel)
    {
        // å…¨ã¦ã®ãƒ‘ãƒãƒ«ã‚’éè¡¨ç¤ºã«ã—ã¦ã‹ã‚‰ã€æŒ‡å®šãƒ‘ãƒãƒ«ã®ã¿è¡¨ç¤º
        mainMenuPanel.SetActive(false);
        settingsPanel.SetActive(false);
        customizationPanel.SetActive(false);
        calibrationPanel.SetActive(false);
        panel.SetActive(true);
    }
    
    public void StartGame()
    {
        UnityEngine.SceneManagement.SceneManager.LoadScene(gameplaySceneName);
    }
}
```

#### 01_Gameplay.unityï¼ˆã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ï¼‰
**ç›®çš„**: å…¨ã¦ã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚·ãƒ³ã‚°ãƒ«ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ï¼‰ã‚’1ã¤ã®ã‚·ãƒ¼ãƒ³ã§å¯¾å¿œ

**è¨­è¨ˆæ–¹é‡**: 
- **åŒã˜ã‚·ãƒ¼ãƒ³ã‚’ä½¿ç”¨**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§åˆ¥ã‚·ãƒ¼ãƒ³ã«ã™ã‚‹å¿…è¦ã¯ãªã„
- **åˆæœŸåŒ–å‡¦ç†ã§åˆ†å²**: ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ã€ç•°ãªã‚‹åˆæœŸåŒ–å‡¦ç†ã‚’å®Ÿè¡Œ
- **ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ‰åŠ¹/ç„¡åŠ¹**: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é–¢é€£ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿æœ‰åŠ¹åŒ–

**å«ã¾ã‚Œã‚‹è¦ç´ **:
- **ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼**: ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®ç®¡ç†ã€ãƒ¢ãƒ¼ãƒ‰åˆæœŸåŒ–
- **å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ **: ã‚¤ãƒ³ã‚¯å¡—ã‚Šã¤ã¶ã—ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å…±é€šï¼‰
- **ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®ç®¡ç†ï¼ˆãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å®Ÿè£…ã‚’åˆ‡ã‚Šæ›¿ãˆï¼‰
- **ã‚²ãƒ¼ãƒ UI**: HUDã€ã‚¿ã‚¤ãƒãƒ¼ã€ã‚¹ã‚³ã‚¢è¡¨ç¤ºï¼ˆå…±é€šï¼‰
- **ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿æœ‰åŠ¹åŒ–

**å®Ÿè£…æ–¹é‡**:
```csharp
public enum GameMode
{
    Creative,       // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå£°ã§çµµã‚’æãï¼‰
    SinglePlayer,   // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰
    OfflineMulti,   // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰
    OnlineMulti     // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
}

public class GameplayManager : MonoBehaviour
{
    [Header("Game Mode")]
    [SerializeField] private GameMode currentMode = GameMode.OfflineMulti;
    
    [Header("Mode-Specific Components")]
    [SerializeField] private CreativeModeManager creativeModeManager; // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨
    [SerializeField] private MonsterSpawner monsterSpawner; // ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ç”¨
    [SerializeField] private NetworkManager networkManager; // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ç”¨
    [SerializeField] private LocalPlayerManager localPlayerManager; // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ç”¨
    
    [Header("Shared Components")]
    [SerializeField] private PaintSystem paintSystem;
    [SerializeField] private PaintCanvas canvas;
    [SerializeField] private GameHUD hud;
    
    void Start()
    {
        InitializeGameMode();
    }
    
    private void InitializeGameMode()
    {
        // å…¨ã¦ã®ãƒ¢ãƒ¼ãƒ‰å›ºæœ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ç„¡åŠ¹åŒ–
        if (creativeModeManager != null) creativeModeManager.gameObject.SetActive(false);
        if (monsterSpawner != null) monsterSpawner.gameObject.SetActive(false);
        if (networkManager != null) networkManager.gameObject.SetActive(false);
        if (localPlayerManager != null) localPlayerManager.gameObject.SetActive(false);
        
        // ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦åˆæœŸåŒ–
        switch (currentMode)
        {
            case GameMode.Creative:
                InitializeCreative();
                break;
            case GameMode.SinglePlayer:
                InitializeSinglePlayer();
                break;
            case GameMode.OfflineMulti:
                InitializeOfflineMulti();
                break;
            case GameMode.OnlineMulti:
                InitializeOnlineMulti();
                break;
        }
    }
    
    private void InitializeCreative()
    {
        // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’æœ‰åŠ¹åŒ–
        if (creativeModeManager != null)
        {
            creativeModeManager.gameObject.SetActive(true);
            creativeModeManager.Initialize();
        }
        // ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ãªã©ï¼‰ã¯ç„¡åŠ¹åŒ–
        if (monsterSpawner != null)
            monsterSpawner.gameObject.SetActive(false);
    }
    
    private void InitializeSinglePlayer()
    {
        // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ã‚’æœ‰åŠ¹åŒ–
        if (monsterSpawner != null)
        {
            monsterSpawner.gameObject.SetActive(true);
            monsterSpawner.Initialize();
        }
        // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚’ä½¿ç”¨ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1äººï¼‰
        if (localPlayerManager != null)
        {
            localPlayerManager.gameObject.SetActive(true);
            localPlayerManager.Initialize(1);
        }
    }
    
    private void InitializeOfflineMulti()
    {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ç„¡åŠ¹
        if (networkManager != null)
            networkManager.gameObject.SetActive(false);
            
        // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚’ä½¿ç”¨
        if (localPlayerManager != null)
        {
            localPlayerManager.gameObject.SetActive(true);
            localPlayerManager.Initialize(2); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°2ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼‰
        }
    }
    
    private void InitializeOnlineMulti()
    {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’æœ‰åŠ¹åŒ–
        if (networkManager != null)
        {
            networkManager.gameObject.SetActive(true);
            networkManager.Initialize();
        }
        
        // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã¯ç„¡åŠ¹ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç®¡ç†ã‚’ä½¿ç”¨ï¼‰
        if (localPlayerManager != null)
            localPlayerManager.gameObject.SetActive(false);
    }
}
```

**ã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®é•ã„**:

| é …ç›® | ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒ | ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒ |
|------|------------------|------------------|
| **ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†** | `LocalPlayerManager`ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰ | `NetworkManager`ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸï¼‰ |
| **å¡—ã‚Šãƒ‡ãƒ¼ã‚¿åŒæœŸ** | ä¸è¦ï¼ˆåŒä¸€ç«¯æœ«ï¼‰ | å¿…è¦ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çµŒç”±ï¼‰ |
| **åˆæœŸåŒ–å‡¦ç†** | ã‚·ãƒ³ãƒ—ãƒ«ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«åˆæœŸåŒ–ã®ã¿ï¼‰ | è¤‡é›‘ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã€ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°ï¼‰ |
| **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°** | ä¸è¦ | å¿…è¦ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ‡æ–­ãªã©ï¼‰ |

**ãƒ¡ãƒªãƒƒãƒˆï¼ˆåŒã˜ã‚·ãƒ¼ãƒ³ã‚’ä½¿ã†è¨­è¨ˆï¼‰**:
- âœ… **é–‹ç™ºåŠ¹ç‡**: ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ãŒå°‘ãªã„
- âœ… **ä¿å®ˆæ€§**: å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‚„UIã¯å…±é€šã§ç®¡ç†
- âœ… **ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§**: ãƒ¢ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã¦ãƒ†ã‚¹ãƒˆå¯èƒ½
- âœ… **å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã«é©ã—ã¦ã„ã‚‹**: ã‚·ãƒ¼ãƒ³é·ç§»ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ãŒãªã„

**æ³¨æ„ç‚¹**:
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆæœŸåŒ–å‡¦ç†ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿å®Ÿè¡Œ
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã—ã¦ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å®Ÿè£…ã‚’åˆ‡ã‚Šæ›¿ãˆ
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åˆ‡æ–­ãªã©ï¼‰ã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿å¿…è¦

#### 99_Test.unityï¼ˆãƒ†ã‚¹ãƒˆç”¨ã‚·ãƒ¼ãƒ³ï¼‰
**ç›®çš„**: é–‹ç™ºä¸­ã®æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ

**å«ã¾ã‚Œã‚‹è¦ç´ **:
- ãƒ†ã‚¹ãƒˆç”¨UI
- ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«
- å„ç¨®ã‚·ã‚¹ãƒ†ãƒ ã®å€‹åˆ¥ãƒ†ã‚¹ãƒˆï¼ˆéŸ³å£°æ¤œå‡ºã€å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ãªã©ï¼‰

**æ³¨æ„**: æœ¬ç•ªãƒ“ãƒ«ãƒ‰ã«ã¯å«ã‚ãªã„

### ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ï¼ˆç°¡æ˜“ç‰ˆï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SceneManagement/SimpleSceneManager.cs`

**å®Ÿè£…å†…å®¹**:
- åŸºæœ¬çš„ãªã‚·ãƒ¼ãƒ³é·ç§»ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ â†” ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ï¼‰
- å¿…è¦ã«å¿œã˜ã¦ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ã‚·ãƒ³ãƒ—ãƒ«ãªå®Ÿè£…**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯è¤‡é›‘ãªã‚·ã‚¹ãƒ†ãƒ ã¯ä¸è¦
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: å¿…è¦ã«å¿œã˜ã¦ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- **ç›´æ¥çš„ãªé·ç§»**: `SceneManager.LoadScene`ã§ååˆ†ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class SimpleSceneManager : MonoBehaviour
{
    [Header("Scene Names")]
    [SerializeField] private string mainMenuSceneName = "00_MainMenu";
    [SerializeField] private string gameplaySceneName = "01_Gameplay";
    
    [Header("Optional Loading Screen")]
    [SerializeField] private GameObject loadingScreenPrefab; // å¿…è¦ã«å¿œã˜ã¦
    
    public static event Action OnSceneChanged; // ã‚ªãƒ—ã‚·ãƒ§ãƒ³
    
    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã¸
    public void LoadGameplay()
    {
        if (loadingScreenPrefab != null)
        {
            StartCoroutine(LoadSceneWithLoading(gameplaySceneName));
        }
        else
        {
            UnityEngine.SceneManagement.SceneManager.LoadScene(gameplaySceneName);
            OnSceneChanged?.Invoke();
        }
    }
    
    // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‹ã‚‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸
    public void LoadMainMenu()
    {
        UnityEngine.SceneManagement.SceneManager.LoadScene(mainMenuSceneName);
        OnSceneChanged?.Invoke();
    }
    
    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ä»˜ãï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    private IEnumerator LoadSceneWithLoading(string sceneName)
    {
        GameObject loadingScreen = Instantiate(loadingScreenPrefab);
        AsyncOperation asyncLoad = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(sceneName);
        
        while (!asyncLoad.isDone)
        {
            yield return null;
        }
        
        if (loadingScreen != null)
            Destroy(loadingScreen);
            
        OnSceneChanged?.Invoke();
    }
}
```

**æ³¨æ„**: 
- å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€ã“ã®ç¨‹åº¦ã®å®Ÿè£…ã§ååˆ†
- å¿…è¦ã«å¿œã˜ã¦ã€å¾Œã‹ã‚‰æ©Ÿèƒ½ã‚’è¿½åŠ å¯èƒ½
- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ã¯ã€ã‚·ãƒ¼ãƒ³é·ç§»ãŒé…ã„å ´åˆã®ã¿å®Ÿè£…

### ã‚·ãƒ¼ãƒ³é–“ã®ãƒ‡ãƒ¼ã‚¿å—ã‘æ¸¡ã—

**å®Ÿè£…æ–¹é‡**: ScriptableObjectã‚’ä½¿ç”¨ã—ãŸå…±æœ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆDontDestroyOnLoadã§ä¿æŒï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SceneManagement/GameData.cs`

```csharp
[CreateAssetMenu(fileName = "GameData", menuName = "Game/Game Data")]
public class GameData : ScriptableObject
{
    // ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ‡ãƒ¼ã‚¿
    public InkTheme selectedTheme;
    public Color selectedColor;
    
    // ã‚²ãƒ¼ãƒ è¨­å®š
    public GameSettings gameSettings;
    
    // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿
    public float calibratedVolume;
    public float calibratedPitch;
    
    // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰
    public GameMode selectedGameMode = GameMode.OfflineMulti;
}

// ã‚·ãƒ¼ãƒ³é–“ã§ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
public class GameDataManager : MonoBehaviour
{
    public static GameDataManager Instance { get; private set; }
    
    [SerializeField] private GameData gameData;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    public GameData GetGameData() => gameData;
}
```

**ä½¿ç”¨æ–¹æ³•**:
- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³ã§è¨­å®šãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’å¤‰æ›´
- `GameDataManager.Instance.GetGameData()`ã§ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹
- ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ã§ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ä½¿ç”¨

### ã‚·ãƒ¼ãƒ³åˆ†å‰²ã®åˆ¤æ–­åŸºæº–ï¼ˆå°è¦æ¨¡ã‚²ãƒ¼ãƒ å‘ã‘ï¼‰

**ã‚·ãƒ¼ãƒ³ã‚’åˆ†ã‘ã‚‹ã¹ãå ´åˆ**:
- âœ… **ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¨ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤**: æ©Ÿèƒ½ãŒæ˜ç¢ºã«åˆ†é›¢ã•ã‚Œã¦ãŠã‚Šã€ãƒ†ã‚¹ãƒˆãŒå®¹æ˜“
- âœ… **ãƒªã‚½ãƒ¼ã‚¹ã®åˆ†é›¢**: ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ä¸­ã«ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIãŒä¸è¦

**ã‚·ãƒ¼ãƒ³ã‚’åˆ†ã‘ãªã„æ–¹ãŒè‰¯ã„å ´åˆ**:
- âŒ **è¨­å®šãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º**: UIãƒ‘ãƒãƒ«ã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ãªãŸã‚ã€åˆ¥ã‚·ãƒ¼ãƒ³ä¸è¦
- âŒ **ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³å†…ã®ãƒ‘ãƒãƒ«ã§ååˆ†
- âŒ **ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰**: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ‰åŠ¹/ç„¡åŠ¹ã§å¯¾å¿œå¯èƒ½

**çµè«–**: å°è¦æ¨¡ã‚²ãƒ¼ãƒ ã§ã¯ã€**ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¨ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®2ã‚·ãƒ¼ãƒ³**ã§ååˆ†

### å®Ÿè£…ã®å„ªå…ˆé †ä½

1. **Phase 1ï¼ˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼‰**: 
   - `01_Gameplay.unity` - ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã®ã¿ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ãªã—ã§ç›´æ¥èµ·å‹•ï¼‰
   - `99_Test.unity` - ãƒ†ã‚¹ãƒˆç”¨

2. **Phase 2ï¼ˆãƒ–ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒƒãƒ—ï¼‰**:
   - `00_MainMenu.unity` - ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ãƒ¼ãƒ³è¿½åŠ ï¼ˆè¨­å®šãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ»ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆï¼‰
   - `SimpleSceneManager.cs` - ã‚·ãƒ¼ãƒ³é·ç§»ã®å®Ÿè£…

3. **Phase 3ï¼ˆå®Œæˆï¼‰**:
   - `GameDataManager.cs` - ãƒ‡ãƒ¼ã‚¿å—ã‘æ¸¡ã—ã®å®Ÿè£…
   - ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç”»é¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰

---

## âœ… ä¼ç”»æ›¸ã¨ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯

### ç¢ºèªçµæœ

#### âœ… ä¸€è‡´ã—ã¦ã„ã‚‹è¦ç´ 

1. **æ“ä½œæ–¹æ³•ï¼ˆVolume/Pitchï¼‰**
   - ä¼ç”»æ›¸: ç¸¦è»¸=Volumeã€æ¨ªè»¸=Pitch
   - å®Ÿè£…: `VoiceToScreenMapper`ã§å®Ÿè£…æ¸ˆã¿ï¼ˆ`volumeOnYAxis = true`ï¼‰

2. **æ”»æ’ƒãƒ¡ã‚«ãƒ‹ã‚ºãƒ **
   - ä¼ç”»æ›¸: ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆã®2ç¨®é¡
   - å®Ÿè£…: `AttackTypeManager`ã§å®Ÿè£…æ¸ˆã¿ã€è¤‡æ•°ã®é¸æŠæ–¹æ³•ã«å¯¾å¿œï¼ˆè‡ªå‹•åˆ¤å®šã€æ‰‹å‹•é¸æŠã€æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
   - **é¸æŠã‚¿ã‚¤ãƒŸãƒ³ã‚°**: ãƒãƒˆãƒ«å‰é¸æŠã€ãƒãƒˆãƒ«ä¸­å¤‰æ›´ã€æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ãªã©ã€æŸ”è»Ÿã«å¯¾å¿œå¯èƒ½

3. **ä¸Šå¡—ã‚Šãƒ¡ã‚«ãƒ‹ã‚ºãƒ **
   - ä¼ç”»æ›¸: ã€Œã™ã§ã«è‰²ãŒå¡—ã‚‰ã‚Œã¦ã„ã‚‹ä½ç½®ã«ä¸Šå¡—ã‚Šã—ã¦é™£åœ°ã‚’å¥ªã„åˆã†ã€
   - å®Ÿè£…: `PaintCanvas.PaintAt()`ã§ä¸Šå¡—ã‚Šåˆ¤å®šã‚’å®Ÿè£…ï¼ˆå¼·åº¦ãƒ™ãƒ¼ã‚¹ï¼‰

4. **ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰**
   - ä¼ç”»æ›¸: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒã€ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰
   - å®Ÿè£…: å…¨ã¦å®Ÿè£…æ¸ˆã¿ï¼ˆ`GameplayManager`ã§ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆï¼‰

5. **å‹åˆ©æ¡ä»¶**
   - ä¼ç”»æ›¸: ã€Œåˆ¶é™æ™‚é–“çµ‚äº†æ™‚ã«ã€æœ€çµ‚çš„ã«æœ€ã‚‚åºƒç¯„å›²ã®é™£åœ°ï¼ˆè‰²ï¼‰ã‚’å¡—ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©ã€
   - å®Ÿè£…: `VictoryCondition`ã§å®Ÿè£…æ¸ˆã¿ï¼ˆ`GetPaintedArea()`ã§é¢ç©è¨ˆç®—ï¼‰

6. **ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰**
   - ä¼ç”»æ›¸: ã€Œæ•µã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’è‰²ã‚’å¡—ã‚‹ã“ã¨ã§å€’ã—ã¦ã„ãã€ï¼ˆæ›´æ–°: ç§»å‹•ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’ç‹™ã†ï¼‰
   - å®Ÿè£…: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ã¨ã—ã¦å®Ÿè£…æ¸ˆã¿

7. **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºè¦ç´ **
   - ä¼ç”»æ›¸: ã‚¤ãƒ³ã‚¯ï¼ˆè‰²ï¼‰ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã€ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
   - å®Ÿè£…: `InkCustomizer`ã€`SoundCustomizer`ã§å®Ÿè£…æ¸ˆã¿

#### ğŸ“ å®Ÿè£…ã®è©³ç´°

**ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚µã‚¤ã‚¯ãƒ«ï¼ˆä¼ç”»æ›¸ï¼‰**:
1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å£°ã‚’å‡ºã—ã¦ã€è‡ªåˆ†ãŒè‰²ã‚’å¡—ã‚ŠãŸã„ä½ç½®ã‚’éŸ³é‡ã¨ãƒ”ãƒƒãƒã§æŒ‡å®šã—ã€æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚’é¸æŠã™ã‚‹ã€‚
   â†’ âœ… å®Ÿè£…: `PaintBattleGameManager.Update()`ã§å®Ÿè£…

2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæŒ‡å®šã—ãŸä½ç½®ã«ã‚¤ãƒ³ã‚¯ãŒå™´å‡ºã•ã‚Œã€è‰²ãŒå¡—ã‚‰ã‚Œã‚‹ã€‚
   â†’ âœ… å®Ÿè£…: `PaintSystem`ã§å®Ÿè£…

3. ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€å£°ã¨ã‚¤ãƒ³ã‚¯ã‚¿ã‚¤ãƒ—ã‚’ä½¿ã„åˆ†ã‘ã€ã™ã§ã«è‰²ãŒå¡—ã‚‰ã‚Œã¦ã„ã‚‹ä½ç½®ã«ä¸Šå¡—ã‚Šã—ã¦é™£åœ°ã‚’å¥ªã„åˆã†ã€‚
   â†’ âœ… å®Ÿè£…: `PaintCanvas.PaintAt()`ã§ä¸Šå¡—ã‚Šåˆ¤å®šã‚’å®Ÿè£…

**çµè«–**: ä¼ç”»æ›¸ã®å†…å®¹ã¯å®Ÿè£…æ‰‹é †æ›¸ã«åæ˜ ã•ã‚Œã¦ã„ã¾ã™ã€‚

---

## ğŸ¯ Phase 1: ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆï½12æœˆï¼šãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—é–‹ç™ºï¼‰

**ç›®æ¨™**: å£°ã§ç”»é¢ã«è‰²ã‚’å¡—ã‚Œã‚‹åŸºæœ¬æ©Ÿèƒ½ã‚’å®Œæˆã•ã›ã‚‹

### Step 1.1: ç”»é¢ç€è‰²ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

**ç›®æ¨™**: å£°ã®ãƒ”ãƒƒãƒã¨ãƒœãƒªãƒ¥ãƒ¼ãƒ ã§ç”»é¢ä½ç½®ã‚’æŒ‡å®šã—ã€ãã®ä½ç½®ã«è‰²ã‚’å¡—ã‚‹

#### 1.1.1: PaintCanvas ã‚·ã‚¹ãƒ†ãƒ ã®ä½œæˆ
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintCanvas.cs`

**å®Ÿè£…å†…å®¹**:
- ç”»é¢å…¨ä½“ã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦ç®¡ç†ï¼ˆRenderTextureä½¿ç”¨æ¨å¥¨ï¼‰
- å„ãƒ”ã‚¯ã‚»ãƒ«ã«ã€Œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã€ã¨ã€Œå¡—ã‚Šå¼·åº¦ã€ã‚’è¨˜éŒ²
- 2Dé…åˆ—ã¾ãŸã¯Texture2Dã§å¡—ã‚ŠçŠ¶æ…‹ã‚’ç®¡ç†
- **ä¸Šå¡—ã‚Šãƒ¡ã‚«ãƒ‹ã‚ºãƒ **: æ—¢å­˜ã®è‰²ã‚’ä¸Šæ›¸ãã—ã¦é™£åœ°ã‚’å¥ªã„åˆã†ï¼ˆä¼ç”»æ›¸ã®ã‚³ã‚¢æ©Ÿèƒ½ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: `PaintSettings.asset`ã§å¡—ã‚Šå¼·åº¦ã€æ›´æ–°é »åº¦ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£è§£åƒåº¦ã‚’ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: å¡—ã‚Šå®Œäº†æ™‚ã«`OnPaintCompleted`ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ï¼ˆUIæ›´æ–°ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†ç”Ÿãªã©ï¼‰
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: `IPaintCanvas`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã—ã€å®Ÿè£…ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "PaintSettings", menuName = "Game/Paint Settings")]
public class PaintSettings : ScriptableObject
{
    [Header("Paint Properties")]
    [Range(0.1f, 5f)] public float baseIntensity = 1f;
    [Range(0.1f, 10f)] public float maxIntensity = 3f;
    [Range(1, 10)] public int updateRate = 1; // ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®æ›´æ–°é »åº¦
    
    [Header("Overpaint (ä¸Šå¡—ã‚Š) Properties")]
    [Range(0.5f, 3f)] public float overpaintThreshold = 1.5f; // ä¸Šå¡—ã‚Šã«å¿…è¦ãªå¼·åº¦å€ç‡
    [Tooltip("ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã®ä¸Šå¡—ã‚Šå€ç‡ï¼ˆä¼ç”»æ›¸: ä¸Šå¡—ã‚Šã—ã‚„ã™ã„ï¼‰")]
    [Range(1f, 5f)] public float impactOverpaintMultiplier = 2f;
    
    [Header("Canvas Properties")]
    public int textureWidth = 1920;
    public int textureHeight = 1080;
}

public interface IPaintCanvas
{
    void PaintAt(Vector2 screenPos, int playerId, float intensity, PaintType type);
    float GetPaintedArea(int playerId);
    void ResetCanvas();
}

public class PaintCanvas : MonoBehaviour, IPaintCanvas
{
    [SerializeField] private PaintSettings settings;
    
    public static event Action<Vector2, int, float> OnPaintCompleted;
    public static event Action<Vector2, int, int> OnTerritoryCaptured; // (position, newOwner, oldOwner)
    
    private int[,] playerIdData; // å„ãƒ”ã‚¯ã‚»ãƒ«ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ID
    private float[,] intensityData; // å„ãƒ”ã‚¯ã‚»ãƒ«ã®å¡—ã‚Šå¼·åº¦
    
    public void PaintAt(Vector2 screenPos, int playerId, float intensity, PaintType type)
    {
        // è¨­å®šã‹ã‚‰å¼·åº¦ã‚’å–å¾—
        float baseIntensity = intensity * settings.baseIntensity;
        
        // ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã¯ä¸Šå¡—ã‚Šå€ç‡ã‚’é©ç”¨ï¼ˆä¼ç”»æ›¸: ä¸Šå¡—ã‚Šã—ã‚„ã™ã„ï¼‰
        if (type == AttackType.ImpactShot)
        {
            baseIntensity *= settings.impactOverpaintMultiplier;
        }
        
        // ç”»é¢åº§æ¨™ã‚’ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã«å¤‰æ›
        int x = Mathf.RoundToInt(screenPos.x);
        int y = Mathf.RoundToInt(screenPos.y);
        
        // ç¯„å›²ãƒã‚§ãƒƒã‚¯
        if (x < 0 || x >= settings.textureWidth || y < 0 || y >= settings.textureHeight)
            return;
        
        // æ—¢å­˜ã®å¡—ã‚ŠçŠ¶æ…‹ã‚’ç¢ºèª
        int existingPlayerId = playerIdData[x, y];
        float existingIntensity = intensityData[x, y];
        
        // ä¸Šå¡—ã‚Šåˆ¤å®šï¼ˆä¼ç”»æ›¸: ã™ã§ã«è‰²ãŒå¡—ã‚‰ã‚Œã¦ã„ã‚‹ä½ç½®ã«ä¸Šå¡—ã‚Šï¼‰
        if (existingPlayerId != 0 && existingPlayerId != playerId)
        {
            // ä¸Šå¡—ã‚Šã«å¿…è¦ãªå¼·åº¦ã‚’ãƒã‚§ãƒƒã‚¯
            float requiredIntensity = existingIntensity * settings.overpaintThreshold;
            if (baseIntensity >= requiredIntensity)
            {
                // ä¸Šå¡—ã‚ŠæˆåŠŸï¼šé™£åœ°ã‚’å¥ªå–
                playerIdData[x, y] = playerId;
                intensityData[x, y] = baseIntensity;
                OnTerritoryCaptured?.Invoke(screenPos, playerId, existingPlayerId);
            }
            else
            {
                // ä¸Šå¡—ã‚Šå¤±æ•—ï¼šå¼·åº¦ãŒè¶³ã‚Šãªã„
                return;
            }
        }
        else
        {
            // ç©ºç™½ã¾ãŸã¯è‡ªåˆ†ã®è‰²ï¼šé€šå¸¸ã®å¡—ã‚Š
            playerIdData[x, y] = playerId;
            intensityData[x, y] = Mathf.Max(intensityData[x, y], baseIntensity);
        }
        
        OnPaintCompleted?.Invoke(screenPos, playerId, baseIntensity);
    }
    
    public float GetPaintedArea(int playerId) 
    {
        int count = 0;
        for (int x = 0; x < settings.textureWidth; x++)
        {
            for (int y = 0; y < settings.textureHeight; y++)
            {
                if (playerIdData[x, y] == playerId)
                    count++;
            }
        }
        return (float)count / (settings.textureWidth * settings.textureHeight);
    }
    
    public void ResetCanvas() 
    {
        // å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
        for (int x = 0; x < settings.textureWidth; x++)
        {
            for (int y = 0; y < settings.textureHeight; y++)
            {
                playerIdData[x, y] = 0;
                intensityData[x, y] = 0f;
            }
        }
    }
}
```

#### 1.1.2: åº§æ¨™å¤‰æ›ã‚·ã‚¹ãƒ†ãƒ 
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/VoiceToScreenMapper.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ”ãƒƒãƒãƒ»ãƒœãƒªãƒ¥ãƒ¼ãƒ å€¤ â†’ ç”»é¢åº§æ¨™ã¸ã®å¤‰æ›
- `VoiceScatterPlot`ã®ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class VoiceToScreenMapper : MonoBehaviour
{
    public bool volumeOnYAxis = true; // ä¼ç”»æ›¸: ç¸¦è»¸=Volume
    
    // ãƒ”ãƒƒãƒãƒ»ãƒœãƒªãƒ¥ãƒ¼ãƒ  â†’ ç”»é¢åº§æ¨™
    public Vector2 MapToScreenPosition(float pitch, float volume, 
                                       float minPitch, float maxPitch,
                                       float minVolume, float maxVolume);
}
```

#### 1.1.3: ã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å®Ÿè£…
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/InkEffect.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¤ãƒ³ã‚¯ã®è¦–è¦šçš„è¡¨ç¾ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã€ã‚¹ãƒ—ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰
- å¡—ã‚Šã¤ã¶ã—æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®æŠ½è±¡åŒ–**: `IInkEffect`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è¨­å®šã€ãƒãƒ†ãƒªã‚¢ãƒ«ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ãƒ—ãƒ¬ãƒãƒ–ãƒ™ãƒ¼ã‚¹**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ¬ãƒãƒ–åŒ–ã—ã€Inspectorã§å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ãƒãƒ†ãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ **: ã‚¤ãƒ³ã‚¯ã®è¦‹ãŸç›®ï¼ˆè‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ï¼‰ã‚’å‹•çš„ã«å¤‰æ›´å¯èƒ½ã«
- **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨æŸ”è»Ÿæ€§ã®ä¸¡ç«‹

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public interface IInkEffect
{
    void PlayEffect(Vector2 position, int playerId, AttackType type, float intensity);
    void StopEffect();
    void SetMaterial(Material material);
    void SetColor(Color color);
}

[CreateAssetMenu(fileName = "InkEffectSettings", menuName = "Game/Graphics/Ink Effect Settings")]
public class InkEffectSettings : ScriptableObject
{
    [Header("Impact Shot Effect")]
    public GameObject impactShotPrefab;
    public ParticleSystem impactParticles;
    [Range(0.1f, 5f)] public float impactScale = 1f;
    [Range(0f, 2f)] public float impactDuration = 0.5f;
    
    [Header("Stream Paint Effect")]
    public GameObject streamPrefab;
    public ParticleSystem streamParticles;
    [Range(0.1f, 3f)] public float streamWidth = 1f;
    
    [Header("Materials")]
    public Material defaultInkMaterial;
    public Texture2D defaultInkTexture;
    public Shader inkShader;
}

[CreateAssetMenu(fileName = "InkMaterialData", menuName = "Game/Graphics/Ink Material")]
public class InkMaterialData : ScriptableObject
{
    [Header("Visual Properties")]
    public Material material;
    public Texture2D texture;
    public Color tintColor = Color.white;
    [Range(0f, 1f)] public float metallic = 0f;
    [Range(0f, 1f)] public float smoothness = 0.5f;
    
    [Header("Animation")]
    public AnimationCurve intensityCurve; // å¼·åº¦ã«ã‚ˆã‚‹è¦‹ãŸç›®ã®å¤‰åŒ–
    public bool useFlowAnimation = true;
    [Range(0f, 5f)] public float flowSpeed = 1f;
}

public class InkEffect : MonoBehaviour, IInkEffect
{
    [SerializeField] private InkEffectSettings settings;
    [SerializeField] private InkMaterialData materialData;
    
    private Dictionary<int, ParticleSystem> activeEffects = new Dictionary<int, ParticleSystem>();
    private Material currentMaterial;
    
    public void PlayEffect(Vector2 position, int playerId, AttackType type, float intensity)
    {
        GameObject prefab = type == AttackType.ImpactShot 
            ? settings.impactShotPrefab 
            : settings.streamPrefab;
            
        if (prefab != null)
        {
            GameObject effect = Instantiate(prefab, position, Quaternion.identity);
            ParticleSystem ps = effect.GetComponent<ParticleSystem>();
            
            // ãƒãƒ†ãƒªã‚¢ãƒ«ã¨è‰²ã‚’é©ç”¨
            if (materialData != null)
            {
                ApplyMaterial(ps, materialData, playerId);
            }
            
            // å¼·åº¦ã«å¿œã˜ã¦ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´
            var main = ps.main;
            main.startSize = main.startSize.constant * intensity;
            
            activeEffects[playerId] = ps;
        }
    }
    
    private void ApplyMaterial(ParticleSystem ps, InkMaterialData data, int playerId)
    {
        var renderer = ps.GetComponent<ParticleSystemRenderer>();
        if (renderer != null && data.material != null)
        {
            // ãƒãƒ†ãƒªã‚¢ãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆï¼ˆå„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ï¼‰
            Material instance = new Material(data.material);
            instance.SetTexture("_MainTex", data.texture);
            instance.SetColor("_Color", data.tintColor);
            renderer.material = instance;
        }
    }
    
    public void SetMaterial(Material material)
    {
        currentMaterial = material;
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«é©ç”¨
        foreach (var effect in activeEffects.Values)
        {
            var renderer = effect.GetComponent<ParticleSystemRenderer>();
            if (renderer != null)
                renderer.material = material;
        }
    }
    
    public void SetColor(Color color)
    {
        if (materialData != null)
            materialData.tintColor = color;
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã«å³åº§ã«åæ˜ 
        foreach (var effect in activeEffects.Values)
        {
            var main = effect.main;
            main.startColor = color;
        }
    }
    
    public void StopEffect() { /* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆåœæ­¢å‡¦ç† */ }
}
```

---

### Step 1.2: æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

#### 1.2.1: æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/AttackTypeManager.cs`

**å®Ÿè£…å†…å®¹**:
- æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®é¸æŠæ–¹æ³•ã‚’æŸ”è»Ÿã«å¯¾å¿œï¼ˆæ‰‹å‹•é¸æŠã€è‡ªå‹•åˆ¤å®šã€æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
- é¸æŠã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®è¨­å®šï¼ˆãƒãƒˆãƒ«å‰ã€ãƒãƒˆãƒ«ä¸­ã€æ™‚é–“åˆ¶ãªã©ï¼‰
- æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®çŠ¶æ…‹ç®¡ç†

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **é¸æŠãƒ¢ãƒ¼ãƒ‰ã®æŠ½è±¡åŒ–**: `IAttackTypeSelector`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§é¸æŠæ–¹æ³•ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: é¸æŠãƒ¢ãƒ¼ãƒ‰ã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã€ãƒ©ãƒ³ãƒ€ãƒ é–“éš”ãªã©ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
- **æ‹¡å¼µæ€§**: æ–°ã—ã„é¸æŠæ–¹æ³•ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã ã‘

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public enum AttackTypeSelectionMode
{
    Auto,           // éŸ³å£°ã«ã‚ˆã‚‹è‡ªå‹•åˆ¤å®šï¼ˆæ—¢å­˜ï¼‰
    Manual,         // æ‰‹å‹•é¸æŠï¼ˆãƒãƒˆãƒ«å‰ã¾ãŸã¯ãƒãƒˆãƒ«ä¸­ï¼‰
    RandomTimed,    // æ™‚é–“åˆ¶ã§ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰æ›´
    RandomOnPaint   // å¡—ã‚‹ãŸã³ã«ãƒ©ãƒ³ãƒ€ãƒ 
}

[CreateAssetMenu(fileName = "AttackTypeSelectionSettings", menuName = "Game/Attack Type Selection Settings")]
public class AttackTypeSelectionSettings : ScriptableObject
{
    [Header("Selection Mode")]
    public AttackTypeSelectionMode mode = AttackTypeSelectionMode.Auto;
    
    [Header("Manual Selection")]
    [Tooltip("ãƒãƒˆãƒ«é–‹å§‹å‰ã«é¸æŠã™ã‚‹ã‹")]
    public bool selectBeforeBattle = true;
    [Tooltip("ãƒãƒˆãƒ«ä¸­ã«å¤‰æ›´å¯èƒ½ã‹")]
    public bool allowChangeDuringBattle = false;
    
    [Header("Random Timed Mode")]
    [Range(1f, 30f)] public float randomChangeInterval = 5f; // ãƒ©ãƒ³ãƒ€ãƒ å¤‰æ›´ã®é–“éš”ï¼ˆç§’ï¼‰
    [Range(0f, 1f)] public float impactShotProbability = 0.5f; // ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã®ç¢ºç‡
    
    [Header("Auto Detection (æ—¢å­˜ã®éŸ³å£°åˆ¤å®š)")]
    public AttackSettings autoDetectionSettings; // æ—¢å­˜ã®AttackSettingsã‚’å‚ç…§
}

public interface IAttackTypeSelector
{
    AttackType GetCurrentType();
    void Initialize(AttackTypeSelectionSettings settings);
    void Update(float deltaTime);
    void SetManualType(AttackType type); // æ‰‹å‹•é¸æŠç”¨
}

public class AttackTypeManager : MonoBehaviour
{
    [SerializeField] private AttackTypeSelectionSettings settings;
    [SerializeField] private IAttackTypeSelector selector;
    
    private AttackType currentType = AttackType.None;
    
    public static event Action<AttackType> OnAttackTypeChanged;
    public static event Action<AttackType> OnAttackTypeSelected; // æ‰‹å‹•é¸æŠæ™‚
    
    void Start()
    {
        InitializeSelector();
    }
    
    void Update()
    {
        if (selector != null)
        {
            selector.Update(Time.deltaTime);
            AttackType newType = selector.GetCurrentType();
            if (newType != currentType)
            {
                currentType = newType;
                OnAttackTypeChanged?.Invoke(currentType);
            }
        }
    }
    
    private void InitializeSelector()
    {
        // é¸æŠãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’åˆæœŸåŒ–
        switch (settings.mode)
        {
            case AttackTypeSelectionMode.Auto:
                selector = gameObject.AddComponent<AutoAttackTypeSelector>();
                break;
            case AttackTypeSelectionMode.Manual:
                selector = gameObject.AddComponent<ManualAttackTypeSelector>();
                break;
            case AttackTypeSelectionMode.RandomTimed:
                selector = gameObject.AddComponent<RandomTimedAttackTypeSelector>();
                break;
            case AttackTypeSelectionMode.RandomOnPaint:
                selector = gameObject.AddComponent<RandomOnPaintAttackTypeSelector>();
                break;
        }
        
        if (selector != null)
        {
            selector.Initialize(settings);
        }
    }
    
    // æ‰‹å‹•é¸æŠç”¨ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆUIã‹ã‚‰å‘¼ã³å‡ºã—ï¼‰
    public void SelectAttackType(AttackType type)
    {
        if (selector is ManualAttackTypeSelector manualSelector)
        {
            manualSelector.SetManualType(type);
            OnAttackTypeSelected?.Invoke(type);
        }
    }
    
    public AttackType GetCurrentType() => currentType;
}
```

#### 1.2.2: å„é¸æŠãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/AttackTypeSelectors/`

**å®Ÿè£…å†…å®¹**:
- è‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰ï¼ˆæ—¢å­˜ã®éŸ³å£°åˆ¤å®šï¼‰
- æ‰‹å‹•é¸æŠãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒãƒˆãƒ«å‰/ãƒãƒˆãƒ«ä¸­ï¼‰
- æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰
- å¡—ã‚‹ãŸã³ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
// è‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰ï¼ˆæ—¢å­˜ã®å®Ÿè£…ã‚’å†åˆ©ç”¨ï¼‰
public class AutoAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private IAttackTypeDetector detector;
    private AttackTypeSelectionSettings settings;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        detector = gameObject.AddComponent<AttackTypeDetector>();
        // æ—¢å­˜ã®AttackSettingsã‚’é©ç”¨
    }
    
    public AttackType GetCurrentType()
    {
        return detector?.CurrentType ?? AttackType.None;
    }
    
    public void Update(float deltaTime) { /* è‡ªå‹•åˆ¤å®šã¯DetectorãŒå‡¦ç† */ }
    public void SetManualType(AttackType type) { /* ç„¡åŠ¹ */ }
}

// æ‰‹å‹•é¸æŠãƒ¢ãƒ¼ãƒ‰
public class ManualAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private AttackType selectedType = AttackType.ImpactShot;
    private AttackTypeSelectionSettings settings;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        // ãƒãƒˆãƒ«é–‹å§‹å‰ã®é¸æŠã‚’å¾…ã¤
        if (settings.selectBeforeBattle)
        {
            selectedType = AttackType.None; // æœªé¸æŠçŠ¶æ…‹
        }
    }
    
    public AttackType GetCurrentType() => selectedType;
    
    public void Update(float deltaTime) { /* æ‰‹å‹•é¸æŠãªã®ã§æ›´æ–°ä¸è¦ */ }
    
    public void SetManualType(AttackType type)
    {
        if (settings.allowChangeDuringBattle || selectedType == AttackType.None)
        {
            selectedType = type;
        }
    }
}

// æ™‚é–“åˆ¶ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰
public class RandomTimedAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private AttackType currentType = AttackType.ImpactShot;
    private AttackTypeSelectionSettings settings;
    private float timer = 0f;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        RandomizeType();
    }
    
    public AttackType GetCurrentType() => currentType;
    
    public void Update(float deltaTime)
    {
        timer += deltaTime;
        if (timer >= settings.randomChangeInterval)
        {
            RandomizeType();
            timer = 0f;
        }
    }
    
    private void RandomizeType()
    {
        currentType = Random.value < settings.impactShotProbability 
            ? AttackType.ImpactShot 
            : AttackType.StreamPaint;
    }
    
    public void SetManualType(AttackType type) { /* ç„¡åŠ¹ */ }
}

// å¡—ã‚‹ãŸã³ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰
public class RandomOnPaintAttackTypeSelector : MonoBehaviour, IAttackTypeSelector
{
    private AttackType currentType = AttackType.ImpactShot;
    private AttackTypeSelectionSettings settings;
    
    public void Initialize(AttackTypeSelectionSettings settings)
    {
        this.settings = settings;
        RandomizeType();
        
        // å¡—ã‚Šã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­
        PaintCanvas.OnPaintCompleted += OnPaint;
    }
    
    void OnDestroy()
    {
        PaintCanvas.OnPaintCompleted -= OnPaint;
    }
    
    private void OnPaint(Vector2 pos, int playerId, float intensity)
    {
        RandomizeType();
    }
    
    public AttackType GetCurrentType() => currentType;
    
    public void Update(float deltaTime) { /* ä¸è¦ */ }
    
    private void RandomizeType()
    {
        currentType = Random.value < settings.impactShotProbability 
            ? AttackType.ImpactShot 
            : AttackType.StreamPaint;
    }
    
    public void SetManualType(AttackType type) { /* ç„¡åŠ¹ */ }
}
```

#### 1.2.3: æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ï¼ˆè‡ªå‹•åˆ¤å®šç”¨ã€æ—¢å­˜ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/AttackTypeDetector.cs`

**å®Ÿè£…å†…å®¹**:
- **ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆ**: éŸ³é‡ã®æ€¥æ¿€ãªå¤‰åŒ–ï¼ˆå¾®åˆ†å€¤ãŒé–¾å€¤è¶…ï¼‰ã‚’æ¤œå‡º
- **ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆ**: ä¸€å®šæ™‚é–“ä»¥ä¸Šã€éŸ³é‡ãŒå®‰å®šã—ã¦ç¶™ç¶šã—ã¦ã„ã‚‹çŠ¶æ…‹ã‚’æ¤œå‡º
- **æ³¨æ„**: è‡ªå‹•åˆ¤å®šãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿ä½¿ç”¨ã•ã‚Œã‚‹

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: `IAttackTypeDetector`ã‚’å®Ÿè£…ã—ã€åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: é–¾å€¤ã€åˆ¤å®šæ™‚é–“ã€å±¥æ­´ã‚µã‚¤ã‚ºã‚’å…¨ã¦è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
- **æ‹¡å¼µæ€§**: æ–°ã—ã„æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã™ã‚‹ã ã‘

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "AttackSettings", menuName = "Game/Attack Settings")]
public class AttackSettings : ScriptableObject
{
    [Header("Impact Shot Detection")]
    [Range(0.01f, 1f)] public float impactVolumeThreshold = 0.3f; // éŸ³é‡æ€¥ä¸Šæ˜‡ã®é–¾å€¤
    [Range(0.01f, 0.5f)] public float impactTimeWindow = 0.1f; // åˆ¤å®šæ™‚é–“çª“
    
    [Header("Stream Paint Detection")]
    [Range(0.1f, 3f)] public float streamMinDuration = 0.5f; // æœ€å°ç¶™ç¶šæ™‚é–“
    [Range(0.01f, 0.2f)] public float streamVolumeVariance = 0.05f; // è¨±å®¹éŸ³é‡å¤‰å‹•
    [Range(5, 30)] public int streamHistorySize = 10; // å±¥æ­´ã‚µã‚¤ã‚º
    
    [Header("Smoothing")]
    [Range(0f, 1f)] public float typeChangeSmoothing = 0.2f; // ã‚¿ã‚¤ãƒ—å¤‰æ›´ã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
}

public interface IAttackTypeDetector
{
    AttackType DetectAttackType(float volume, float pitch, float deltaTime);
    AttackType CurrentType { get; }
}

public enum AttackType
{
    None,
    ImpactShot,
    StreamPaint
}

public class AttackTypeDetector : MonoBehaviour, IAttackTypeDetector
{
    [SerializeField] private AttackSettings settings;
    
    public static event Action<AttackType> OnAttackTypeChanged;
    
    private Queue<float> volumeHistory = new Queue<float>();
    private float lastVolume = 0f;
    private AttackType currentType = AttackType.None;
    
    public AttackType CurrentType => currentType;
    
    public AttackType DetectAttackType(float currentVolume, float pitch, float deltaTime)
    {
        AttackType detectedType = AttackType.None;
        
        if (IsImpactShot(currentVolume))
            detectedType = AttackType.ImpactShot;
        else if (IsStreamPaint())
            detectedType = AttackType.StreamPaint;
        
        // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
        if (detectedType != currentType)
        {
            currentType = detectedType;
            OnAttackTypeChanged?.Invoke(currentType);
        }
        
        return currentType;
    }
    
    private bool IsImpactShot(float currentVolume)
    {
        float volumeDelta = currentVolume - lastVolume;
        return volumeDelta > settings.impactVolumeThreshold;
    }
    
    private bool IsStreamPaint()
    {
        if (volumeHistory.Count < settings.streamHistorySize) return false;
        // å®‰å®šæ€§ãƒã‚§ãƒƒã‚¯ï¼ˆè¨­å®šã‹ã‚‰é–¾å€¤ã‚’å–å¾—ï¼‰
        // ...
        return true;
    }
}
```

#### 1.2.2: æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¥ã®å¡—ã‚Šãƒ­ã‚¸ãƒƒã‚¯
**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintSystem.cs`

**å®Ÿè£…å†…å®¹**:
- **ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆ**: æŒ‡å®šä½ç½®ã«é«˜å¯†åº¦ã®å††çŠ¶ã‚¤ãƒ³ã‚¯ã‚’å¡—ã‚‹ï¼ˆåŠå¾„å›ºå®šã€å¼·åº¦é«˜ï¼‰
- **ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆ**: å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®è»Œè·¡ã«æ²¿ã£ã¦é€£ç¶šçš„ã«ã‚¤ãƒ³ã‚¯ã‚’å¡—ã‚‹ï¼ˆç·šçŠ¶/é¢çŠ¶ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **Strategy ãƒ‘ã‚¿ãƒ¼ãƒ³**: å„æ”»æ’ƒã‚¿ã‚¤ãƒ—ã‚’`IPaintStrategy`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§å®Ÿè£…
- **ScriptableObjectè¨­å®š**: åŠå¾„ã€å¼·åº¦ã€è»Œè·¡ã®é•·ã•ãªã©ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **Inspectorã§å·®ã—æ›¿ãˆ**: å¡—ã‚Šæˆ¦ç•¥ã‚’Inspectorã§é¸æŠå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public interface IPaintStrategy
{
    void Paint(Vector2 position, int playerId, float intensity, IPaintCanvas canvas);
}

[CreateAssetMenu(fileName = "ImpactShotSettings", menuName = "Game/Paint/Impact Shot")]
public class ImpactShotSettings : ScriptableObject
{
    [Range(10f, 200f)] public float radius = 50f;
    [Range(1f, 5f)] public float intensityMultiplier = 2f;
}

public class ImpactShotStrategy : ScriptableObject, IPaintStrategy
{
    [SerializeField] private ImpactShotSettings settings;
    
    public void Paint(Vector2 position, int playerId, float intensity, IPaintCanvas canvas)
    {
        // è¨­å®šã‹ã‚‰åŠå¾„ã¨å¼·åº¦ã‚’å–å¾—ã—ã¦å¡—ã‚‹
        float finalIntensity = intensity * settings.intensityMultiplier;
        // å††çŠ¶ã«å¡—ã‚‹å‡¦ç†
    }
}

public class PaintSystem : MonoBehaviour
{
    [SerializeField] private IPaintStrategy impactShotStrategy;
    [SerializeField] private IPaintStrategy streamPaintStrategy;
    [SerializeField] private IPaintCanvas canvas;
    
    private Vector2 lastPaintPosition;
    private Queue<Vector2> paintTrail = new Queue<Vector2>();
    
    public void PaintImpactShot(Vector2 position, int playerId, float intensity)
    {
        impactShotStrategy?.Paint(position, playerId, intensity, canvas);
    }
    
    public void PaintStream(Vector2 currentPosition, int playerId, float intensity)
    {
        streamPaintStrategy?.Paint(currentPosition, playerId, intensity, canvas);
        UpdatePaintTrail(currentPosition);
    }
    
    private void UpdatePaintTrail(Vector2 position) { /* ... */ }
}
```

---

### Step 1.3: ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®çµ±åˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PaintBattleGameManager.cs`

**å®Ÿè£…å†…å®¹**:
- éŸ³å£°æ¤œå‡º â†’ åº§æ¨™å¤‰æ› â†’ æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®š â†’ å¡—ã‚Šå‡¦ç†ã®çµ±åˆ
- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®ç®¡ç†

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **Inspectorã§æ¥ç¶š**: å…¨ã¦ã®ä¾å­˜ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’Inspectorã§æ¥ç¶šï¼ˆFindObjectOfTypeã‚’é¿ã‘ã‚‹ï¼‰
- **ScriptableObjectè¨­å®š**: ã‚²ãƒ¼ãƒ å…¨ä½“ã®è¨­å®šã‚’`GameSettings.asset`ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•**: å„ã‚¹ãƒ†ãƒƒãƒ—ã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ã€ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ãŒåå¿œå¯èƒ½ã«
- **çŠ¶æ…‹ç®¡ç†**: ã‚²ãƒ¼ãƒ çŠ¶æ…‹ï¼ˆPlaying, Paused, Endedï¼‰ã‚’æ˜ç¢ºã«ç®¡ç†

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "GameSettings", menuName = "Game/Game Settings")]
public class GameSettings : ScriptableObject
{
    [Header("Game Flow")]
    public float matchDuration = 180f;
    public int maxPlayers = 2;
    
    [Header("Paint Settings")]
    public PaintSettings paintSettings;
    public AttackSettings attackSettings;
    
    [Header("Balance")]
    [Range(0.5f, 2f)] public float paintSpeedMultiplier = 1f;
}

public class PaintBattleGameManager : MonoBehaviour
{
    [Header("Dependencies")] // Inspectorã§æ¥ç¶š
    [SerializeField] private VoiceToScreenMapper mapper;
    [SerializeField] private AttackTypeManager attackTypeManager; // æ”»æ’ƒã‚¿ã‚¤ãƒ—ç®¡ç†
    [SerializeField] private PaintSystem paintSystem;
    [SerializeField] private IPaintCanvas canvas;
    [SerializeField] private ImprovedPitchAnalyzer pitchAnalyzer;
    [SerializeField] private VolumeAnalyzer volumeAnalyzer;
    
    [Header("Settings")]
    [SerializeField] private GameSettings settings;
    
    private int currentPlayerId = 0;
    
    public static event Action<float, float> OnVoiceInput; // pitch, volume
    public static event Action<Vector2> OnPositionMapped;
    public static event Action<AttackType> OnAttackDetected;
    
    void Start()
    {
        // æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­
        if (attackTypeManager != null)
        {
            AttackTypeManager.OnAttackTypeChanged += OnAttackTypeChanged;
        }
    }
    
    void OnDestroy()
    {
        if (attackTypeManager != null)
        {
            AttackTypeManager.OnAttackTypeChanged -= OnAttackTypeChanged;
        }
    }
    
    void Update()
    {
        if (!IsGameActive()) return;
        
        // 1. éŸ³å£°ãƒ‡ãƒ¼ã‚¿å–å¾—
        float pitch = pitchAnalyzer.lastDetectedPitch;
        float volume = volumeAnalyzer.lastDetectedVolume;
        OnVoiceInput?.Invoke(pitch, volume);
        
        // 2. åº§æ¨™å¤‰æ›
        Vector2 screenPos = mapper.MapToScreenPosition(
            pitch, volume, 
            pitchAnalyzer.minFrequency, pitchAnalyzer.maxFrequency,
            0f, volumeAnalyzer.maxVolume
        );
        OnPositionMapped?.Invoke(screenPos);
        
        // 3. æ”»æ’ƒã‚¿ã‚¤ãƒ—å–å¾—ï¼ˆé¸æŠãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦è‡ªå‹•/æ‰‹å‹•/ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
        AttackType type = attackTypeManager != null 
            ? attackTypeManager.GetCurrentType() 
            : AttackType.None;
        OnAttackDetected?.Invoke(type);
        
        // 4. å¡—ã‚Šå‡¦ç†ï¼ˆStrategy ãƒ‘ã‚¿ãƒ¼ãƒ³ã§åˆ†å²ä¸è¦ï¼‰
        if (type != AttackType.None)
        {
            float intensity = volume * settings.paintSpeedMultiplier;
            paintSystem.Paint(screenPos, currentPlayerId, intensity, type);
        }
    }
    
    private void OnAttackTypeChanged(AttackType newType)
    {
        OnAttackDetected?.Invoke(newType);
    }
    
    private bool IsGameActive() { /* çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ */ }
}
```

---

## ğŸ¨ Phase 2: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå£°ã§çµµã‚’æããƒ¢ãƒ¼ãƒ‰ï¼‰ã€å®Ÿè£…é›£æ˜“åº¦ï¼šä½ã€‘

**ç›®æ¨™**: å£°ã§è‡ªç”±ã«çµµã‚’æã‘ã‚‹çŠ¶æ…‹ã«ã™ã‚‹

**ç‰¹å¾´**:
- Phase 1ã®å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‚’ãã®ã¾ã¾ä½¿ç”¨
- ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ã€å‹åˆ©æ¡ä»¶ï¼‰ã¯ä¸è¦
- ã‚·ãƒ³ãƒ—ãƒ«ãªUIï¼ˆã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã€è‰²é¸æŠãªã©ï¼‰ã®ã¿
- å®Ÿè£…é›£æ˜“åº¦ãŒä½ã„ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ãŒå®Œæˆã—ã¦ã„ã‚Œã°å®Ÿè£…å¯èƒ½ï¼‰

### Step 2.1: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Creative/CreativeModeManager.cs`

**å®Ÿè£…å†…å®¹**:
- Phase 1ã®`PaintCanvas`ã¨`PaintBattleGameManager`ã‚’ãã®ã¾ã¾ä½¿ç”¨
- ã‚²ãƒ¼ãƒ è¦ç´ ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã€ã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰ã¯ç„¡åŠ¹åŒ–
- å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿æœ‰åŠ¹åŒ–

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨ã®è¨­å®šï¼ˆè‰²ã€å¡—ã‚Šå¼·åº¦ãªã©ï¼‰ã‚’ç®¡ç†
- **ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ**: `GameMode`enumã«`Creative`ã‚’è¿½åŠ 
- **ã‚·ãƒ³ãƒ—ãƒ«ãªå®Ÿè£…**: æ—¢å­˜ã®ã‚·ã‚¹ãƒ†ãƒ ã‚’å†åˆ©ç”¨ã—ã€æœ€å°é™ã®è¿½åŠ ã®ã¿

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "CreativeModeSettings", menuName = "Game/Creative Mode Settings")]
public class CreativeModeSettings : ScriptableObject
{
    [Header("Paint Settings")]
    public PaintSettings paintSettings; // Phase 1ã®PaintSettingsã‚’å‚ç…§
    
    [Header("Color Selection")]
    public Color[] availableColors = new Color[] 
    { 
        Color.red, Color.blue, Color.green, Color.yellow, 
        Color.cyan, Color.magenta, Color.white, Color.black 
    };
    [Range(0.1f, 2f)] public float paintIntensity = 1f;
}

public class CreativeModeManager : MonoBehaviour
{
    [Header("Settings")]
    [SerializeField] private CreativeModeSettings settings;
    
    [Header("References")]
    [SerializeField] private PaintCanvas paintCanvas;
    [SerializeField] private PaintBattleGameManager paintGameManager;
    
    [Header("UI References")]
    [SerializeField] private Button clearButton;
    [SerializeField] private Button[] colorButtons; // è‰²é¸æŠãƒœã‚¿ãƒ³
    
    private int currentColorIndex = 0;
    private int currentPlayerId = 1; // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ã¯1ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã¿
    
    void Start()
    {
        InitializeCreativeMode();
    }
    
    private void InitializeCreativeMode()
    {
        // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‚’æœ‰åŠ¹åŒ–
        if (paintCanvas != null)
            paintCanvas.gameObject.SetActive(true);
        if (paintGameManager != null)
            paintGameManager.gameObject.SetActive(true);
        
        // è‰²é¸æŠãƒœã‚¿ãƒ³ã®è¨­å®š
        if (colorButtons != null)
        {
            for (int i = 0; i < colorButtons.Length && i < settings.availableColors.Length; i++)
            {
                int colorIndex = i; // ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å¯¾ç­–
                colorButtons[i].onClick.AddListener(() => SelectColor(colorIndex));
                
                // ãƒœã‚¿ãƒ³ã®è‰²ã‚’è¨­å®š
                var colors = colorButtons[i].colors;
                colors.normalColor = settings.availableColors[i];
                colorButtons[i].colors = colors;
            }
        }
        
        // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã®è¨­å®š
        if (clearButton != null)
            clearButton.onClick.AddListener(ClearCanvas);
    }
    
    private void SelectColor(int colorIndex)
    {
        currentColorIndex = colorIndex;
        // ã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®è‰²ã‚’å¤‰æ›´ï¼ˆPhase 4ã®InkEffectã‚’ä½¿ç”¨ï¼‰
        // InkEffect.SetColor(settings.availableColors[colorIndex]);
    }
    
    private void ClearCanvas()
    {
        if (paintCanvas != null)
            paintCanvas.ResetCanvas();
    }
    
    // ç¾åœ¨é¸æŠä¸­ã®è‰²ã‚’å–å¾—
    public Color GetCurrentColor()
    {
        return settings.availableColors[currentColorIndex];
    }
    
    public CreativeModeSettings GetSettings()
    {
        return settings;
    }
}
```

### Step 2.2: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨UI

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/CreativeModeUI.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
- è‰²é¸æŠãƒœã‚¿ãƒ³ï¼ˆ8è‰²ç¨‹åº¦ï¼‰
- ã‚·ãƒ³ãƒ—ãƒ«ãªUIï¼ˆã‚²ãƒ¼ãƒ è¦ç´ ã¯ä¸è¦ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **Inspectorè¨­å®š**: UIè¦ç´ ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: è‰²ã®ãƒªã‚¹ãƒˆã¯`CreativeModeSettings`ã§ç®¡ç†
- **æœ€å°é™ã®å®Ÿè£…**: å¿…è¦æœ€å°é™ã®UIã®ã¿

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class CreativeModeUI : MonoBehaviour
{
    [Header("UI Elements")]
    [SerializeField] private Button clearButton;
    [SerializeField] private Transform colorButtonParent;
    [SerializeField] private GameObject colorButtonPrefab;
    
    [Header("References")]
    [SerializeField] private CreativeModeManager creativeManager;
    
    void Start()
    {
        InitializeUI();
    }
    
    private void InitializeUI()
    {
        // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã®è¨­å®š
        if (clearButton != null && creativeManager != null)
        {
            clearButton.onClick.AddListener(() => creativeManager.ClearCanvas());
        }
        
        // è‰²é¸æŠãƒœã‚¿ãƒ³ã®ç”Ÿæˆï¼ˆCreativeModeSettingsã‹ã‚‰è‰²ã‚’å–å¾—ï¼‰
        if (creativeManager != null && colorButtonPrefab != null && colorButtonParent != null)
        {
            var settings = creativeManager.GetSettings();
            if (settings != null)
            {
                foreach (Color color in settings.availableColors)
                {
                    GameObject buttonObj = Instantiate(colorButtonPrefab, colorButtonParent);
                    Button button = buttonObj.GetComponent<Button>();
                    
                    // ãƒœã‚¿ãƒ³ã®è‰²ã‚’è¨­å®š
                    var colors = button.colors;
                    colors.normalColor = color;
                    button.colors = colors;
                }
            }
        }
    }
}
```

### Step 2.3: ä¿å­˜æ©Ÿèƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Creative/CreativeModeSaveSystem.cs`

**å®Ÿè£…å†…å®¹**:
- æã„ãŸçµµã‚’ç”»åƒã¨ã—ã¦ä¿å­˜ï¼ˆTexture2Dã‚’PNGã«å¤‰æ›ï¼‰
- ä¿å­˜ã—ãŸçµµã‚’èª­ã¿è¾¼ã‚“ã§è¡¨ç¤ºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: ä¿å­˜å…ˆãƒ‘ã‚¹ã€ãƒ•ã‚¡ã‚¤ãƒ«åå½¢å¼ã‚’è¨­å®šå¯èƒ½ã«
- **ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½**: æœ€åˆã¯å®Ÿè£…ã›ãšã€å¾Œã‹ã‚‰è¿½åŠ å¯èƒ½

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class CreativeModeSaveSystem : MonoBehaviour
{
    [Header("Save Settings")]
    [SerializeField] private string saveDirectory = "Screenshots";
    [SerializeField] private string fileNameFormat = "Creative_{0:yyyyMMdd_HHmmss}.png";
    
    [Header("References")]
    [SerializeField] private PaintCanvas paintCanvas;
    [SerializeField] private Button saveButton;
    
    void Start()
    {
        if (saveButton != null)
            saveButton.onClick.AddListener(SaveCanvas);
    }
    
    public void SaveCanvas()
    {
        // PaintCanvasã®ãƒ‡ãƒ¼ã‚¿ã‚’Texture2Dã«å¤‰æ›
        // Texture2Dã‚’PNGã¨ã—ã¦ä¿å­˜
        // å®Ÿè£…ã¯å¾Œã‹ã‚‰è¿½åŠ ï¼ˆPhase 2ã§ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    }
}
```

---

## ğŸ¯ Phase 3: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¤‡æ•°ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œï¼‰ï¼ˆå„ªå…ˆå®Ÿè£…ï¼‰ï¼ˆ1æœˆï¼‰

**ç›®æ¨™**: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã§éŠã¹ã‚‹çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³å®Ÿè£…ã¯ä¸è¦ï¼‰

**ç‰¹å¾´**:
- è¤‡æ•°ã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’å®Ÿè£…å¯èƒ½ãªè¨­è¨ˆ
- å„ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã¯ç‹¬ç«‹ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã—ã¦å®Ÿè£…
- ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã«ã‚ˆã‚Šã€æ–°ã—ã„ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã‚„ã™ã

**å®Ÿè£…ã™ã‚‹ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰**ï¼ˆå„ªå…ˆé †ä½é †ï¼‰:
1. **ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰**ã€å„ªå…ˆåº¦é«˜ã€‘: ãƒ©ãƒ³ãƒ€ãƒ ãªå ´æ‰€ã®è‰²ãŒå¤‰ã‚ã‚‹ã®ã‚’é˜²ã
2. **ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰**: ç§»å‹•ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’æ’ƒç ´ã™ã‚‹
3. **ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰**: é€æ˜ãªçµµã®ç·šã‚’ãªãã£ã¦ç‚¹æ•°ã‚’ç²å¾—
4. **AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰**: AIã¨è‰²å¡—ã‚Šå¯¾æ±º

### Step 3.0: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆã‚·ã‚¹ãƒ†ãƒ ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/SinglePlayerModeManager.cs`

**å®Ÿè£…å†…å®¹**:
- è¤‡æ•°ã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’ç®¡ç†
- ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
- å„ãƒ¢ãƒ¼ãƒ‰ã®åˆæœŸåŒ–ãƒ»çµ‚äº†å‡¦ç†

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: `ISinglePlayerGameMode`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§å„ãƒ¢ãƒ¼ãƒ‰ã‚’æŠ½è±¡åŒ–
- **ScriptableObjectè¨­å®š**: ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®šã‚’ç®¡ç†
- **Inspectorè¨­å®š**: å„ãƒ¢ãƒ¼ãƒ‰ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’Inspectorã§æ¥ç¶šå¯èƒ½ã«
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public enum SinglePlayerGameModeType
{
    MonsterHunt,      // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰
    ColorDefense,     // ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰
    Tracing,          // ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰
    AIBattle         // AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰
}

public interface ISinglePlayerGameMode
{
    void Initialize(SinglePlayerGameModeSettings settings);
    void StartGame();
    void Update(float deltaTime);
    void EndGame();
    void Pause();
    void Resume();
    int GetScore();
    float GetProgress(); // 0.0ï½1.0ã®é€²æ—
    bool IsGameOver();
    SinglePlayerGameModeType GetModeType();
}

[CreateAssetMenu(fileName = "SinglePlayerGameModeSettings", menuName = "Game/SinglePlayer/Game Mode Settings")]
public class SinglePlayerGameModeSettings : ScriptableObject
{
    [Header("Mode Selection")]
    public SinglePlayerGameModeType selectedMode = SinglePlayerGameModeType.ColorDefense; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰ï¼ˆå„ªå…ˆåº¦é«˜ï¼‰
    
    [Header("Common Settings")]
    [Range(30f, 300f)] public float gameDuration = 180f; // ã‚²ãƒ¼ãƒ æ™‚é–“ï¼ˆç§’ï¼‰
    [Range(1, 10)] public int difficultyLevel = 1;
    
    [Header("Mode-Specific Settings")]
    public MonsterHuntSettings monsterHuntSettings;
    public ColorDefenseSettings colorDefenseSettings;
    public TracingSettings tracingSettings;
    public AIBattleSettings aiBattleSettings;
}

public class SinglePlayerModeManager : MonoBehaviour
{
    [Header("Settings")]
    [SerializeField] private SinglePlayerGameModeSettings settings;
    
    [Header("Mode Components")]
    [SerializeField] private MonsterHuntMode monsterHuntMode;
    [SerializeField] private ColorDefenseMode colorDefenseMode;
    [SerializeField] private TracingMode tracingMode;
    [SerializeField] private AIBattleMode aiBattleMode;
    
    [Header("Shared Components")]
    [SerializeField] private PaintCanvas paintCanvas;
    [SerializeField] private ScoreManager scoreManager;
    
    private ISinglePlayerGameMode currentMode;
    
    public static event Action<SinglePlayerGameModeType> OnModeChanged;
    public static event Action<int> OnScoreUpdated;
    public static event Action<float> OnProgressUpdated;
    
    void Start()
    {
        InitializeMode();
    }
    
    private void InitializeMode()
    {
        // å…¨ã¦ã®ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹åŒ–
        DisableAllModes();
        
        // é¸æŠã•ã‚ŒãŸãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹åŒ–
        switch (settings.selectedMode)
    {
            case SinglePlayerGameModeType.MonsterHunt:
                currentMode = monsterHuntMode;
                break;
            case SinglePlayerGameModeType.ColorDefense:
                currentMode = colorDefenseMode;
                break;
            case SinglePlayerGameModeType.Tracing:
                currentMode = tracingMode;
                break;
            case SinglePlayerGameModeType.AIBattle:
                currentMode = aiBattleMode;
                break;
        }
        
        if (currentMode != null)
        {
            currentMode.Initialize(settings);
            currentMode.StartGame();
            OnModeChanged?.Invoke(settings.selectedMode);
        }
    }
    
    void Update()
    {
        if (currentMode != null)
        {
            currentMode.Update(Time.deltaTime);
            
            // ã‚¹ã‚³ã‚¢ã¨é€²æ—ã‚’æ›´æ–°
            OnScoreUpdated?.Invoke(currentMode.GetScore());
            OnProgressUpdated?.Invoke(currentMode.GetProgress());
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
            if (currentMode.IsGameOver())
            {
                currentMode.EndGame();
        }
    }
    }
    
    private void DisableAllModes()
    {
        if (monsterHuntMode != null) monsterHuntMode.gameObject.SetActive(false);
        if (colorDefenseMode != null) colorDefenseMode.gameObject.SetActive(false);
        if (tracingMode != null) tracingMode.gameObject.SetActive(false);
        if (aiBattleMode != null) aiBattleMode.gameObject.SetActive(false);
        }
    
    public void ChangeMode(SinglePlayerGameModeType newMode)
    {
        if (currentMode != null)
        {
            currentMode.EndGame();
        }
        
        settings.selectedMode = newMode;
        InitializeMode();
    }
}
```

---

### Step 3.1: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ï¼ˆMonster Hunt Modeï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/Modes/MonsterHuntMode.cs`

**å®Ÿè£…å†…å®¹**:
- ç§»å‹•ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’æ’ƒç ´ã™ã‚‹ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç”Ÿæˆãƒ»ç®¡ç†
- å½“ãŸã‚Šåˆ¤å®š
- ã‚¹ã‚³ã‚¢è¨ˆç®—

### Step 3.1.1: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/Monster.cs`

**å®Ÿè£…å†…å®¹**:
- ç”»é¢ã‚’ç§»å‹•ã™ã‚‹ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®å®Ÿè£…
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç›´ç·šã€æ›²ç·šã€ãƒ©ãƒ³ãƒ€ãƒ ãªã©ï¼‰
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®HP/è€ä¹…å€¤ç®¡ç†
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®è¦–è¦šçš„è¡¨ç¾

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ã€ç§»å‹•é€Ÿåº¦ã€HPãªã©ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æŠ½è±¡åŒ–**: `IMonsterMovement`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "MonsterSettings", menuName = "Game/SinglePlayer/Monster Settings")]
public class MonsterSettings : ScriptableObject
{
    [Header("Monster Properties")]
    [Range(1, 10)] public int maxHP = 3;
    [Range(10f, 500f)] public float moveSpeed = 100f;
    [Range(0.5f, 5f)] public float spawnInterval = 2f;
    
    [Header("Visual")]
    public GameObject monsterPrefab;
    public Color monsterColor = Color.red;
    [Range(20f, 200f)] public float monsterSize = 50f;
}

public interface IMonsterMovement
{
    Vector2 GetNextPosition(Vector2 currentPos, float deltaTime);
    void Initialize(Vector2 startPos, Vector2 targetPos);
}

public class Monster : MonoBehaviour
{
    [SerializeField] private MonsterSettings settings;
    [SerializeField] private IMonsterMovement movementPattern;
    
    private int currentHP;
    private Vector2 currentPosition;
    
    public static event Action<Monster> OnMonsterDefeated;
    public static event Action<Monster> OnMonsterSpawned;
    
    void Start()
        {
        currentHP = settings.maxHP;
        OnMonsterSpawned?.Invoke(this);
    }
    
    void Update()
    {
        // ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã£ã¦ç§»å‹•
        if (movementPattern != null)
        {
            currentPosition = movementPattern.GetNextPosition(currentPosition, Time.deltaTime);
            transform.position = currentPosition;
    }
    }
    
    // ã‚¤ãƒ³ã‚¯ãŒå½“ãŸã£ãŸæ™‚ã®å‡¦ç†
    public void TakeDamage(int damage)
    {
        currentHP -= damage;
        if (currentHP <= 0)
            {
            Defeat();
        }
    }
    
    private void Defeat()
    {
        OnMonsterDefeated?.Invoke(this);
        // ã‚¹ã‚³ã‚¢åŠ ç®—ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå†ç”Ÿãªã©
        Destroy(gameObject);
    }
    
    public Vector2 GetPosition() => currentPosition;
    public int GetHP() => currentHP;
}
```

---

### Step 3.2: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/MonsterSpawner.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç”Ÿæˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ç®¡ç†
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠ
- ç”»é¢å¤–ã¸ã®ç§»å‹•åˆ¤å®šã¨å‰Šé™¤
- é›£æ˜“åº¦ã®æ®µéšçš„å¢—åŠ 

---

### Step 3.3: å½“ãŸã‚Šåˆ¤å®šã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/MonsterHitDetector.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¤ãƒ³ã‚¯ãŒãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã«å½“ãŸã£ãŸã‹ã®åˆ¤å®š
- å½“ãŸã£ãŸæ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
- ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†ç”Ÿ

---

### Step 3.4: ã‚¹ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/ScoreManager.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ™‚ã®ã‚¹ã‚³ã‚¢è¨ˆç®—
- ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ ï¼ˆé€£ç¶šæ’ƒç ´ãƒœãƒ¼ãƒŠã‚¹ï¼‰
- ã‚¹ã‚³ã‚¢è¡¨ç¤º
- ãƒ©ãƒ³ã‚­ãƒ³ã‚°ä¿å­˜

---

## ğŸŒ Phase 4: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã®æ¬¡ï¼‰ï¼ˆ1ï½2æœˆï¼‰

**ç›®æ¨™**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹

### Step 4.1: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ã®å®Ÿè£…

**å®Ÿè£…å†…å®¹**:
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸï¼ˆUnity Netcode for GameObjects ã¾ãŸã¯ Mirror ã‚’ä½¿ç”¨ï¼‰
- å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ãƒ»æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®åŒæœŸ

**ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**:
- `NetworkPaintCanvas.cs` - å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®åŒæœŸ
- `NetworkPlayerManager.cs` - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®åŒæœŸ
- `MatchmakingSystem.cs` - ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°

---

## ğŸ¨ Phase 5: UI/UXå®Ÿè£…ï¼ˆ1ï½2æœˆï¼‰

**ç›®æ¨™**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰å„ãƒ¢ãƒ¼ãƒ‰ã«é·ç§»ã§ãã‚‹

### Step 5.1: ã‚²ãƒ¼ãƒ ç”»é¢UI

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/GameHUD.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º
- å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¡—ã‚Šé¢ç©ï¼ˆãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ï¼‰è¡¨ç¤º
- ç¾åœ¨ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—è¡¨ç¤ºï¼ˆã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ/ã‚¹ãƒˆãƒªãƒ¼ãƒ ï¼‰
- ãƒŸãƒ‹ãƒãƒƒãƒ—ï¼ˆå¡—ã‚ŠçŠ¶æ³ã®å¯è¦–åŒ–ï¼‰

---

### Step 3.1.1: æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠUI

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/AttackTypeSelectionUI.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒãƒˆãƒ«é–‹å§‹å‰ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠç”»é¢
- ãƒãƒˆãƒ«ä¸­ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—å¤‰æ›´UIï¼ˆè¨­å®šã§æœ‰åŠ¹åŒ–æ™‚ï¼‰
- ç¾åœ¨ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®è¦–è¦šçš„è¡¨ç¤º
- ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **è¨­å®šé€£å‹•**: `AttackTypeSelectionSettings`ã®è¨­å®šã«å¿œã˜ã¦UIã‚’è¡¨ç¤º/éè¡¨ç¤º
- **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•**: `AttackTypeManager`ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­ã—ã¦UIã‚’æ›´æ–°
- **Inspectorè¨­å®š**: UIè¦ç´ ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
public class AttackTypeSelectionUI : MonoBehaviour
{
    [Header("UI Elements")]
    [SerializeField] private GameObject selectionPanel; // ãƒãƒˆãƒ«å‰é¸æŠãƒ‘ãƒãƒ«
    [SerializeField] private Button impactShotButton;
    [SerializeField] private Button streamPaintButton;
    [SerializeField] private TextMeshProUGUI currentTypeText;
    [SerializeField] private TextMeshProUGUI randomTimerText; // ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰ç”¨
    
    [Header("References")]
    [SerializeField] private AttackTypeManager attackTypeManager;
    [SerializeField] private AttackTypeSelectionSettings settings;
    
    void Start()
    {
        // ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­
        AttackTypeManager.OnAttackTypeChanged += UpdateUI;
        AttackTypeManager.OnAttackTypeSelected += OnTypeSelected;
        
        // ãƒœã‚¿ãƒ³è¨­å®š
        if (impactShotButton != null)
            impactShotButton.onClick.AddListener(() => SelectType(AttackType.ImpactShot));
        if (streamPaintButton != null)
            streamPaintButton.onClick.AddListener(() => SelectType(AttackType.StreamPaint));
        
        // åˆæœŸè¡¨ç¤º
        UpdateUI(AttackType.None);
        
        // ãƒãƒˆãƒ«å‰é¸æŠãŒå¿…è¦ãªå ´åˆ
        if (settings != null && settings.mode == AttackTypeSelectionMode.Manual && settings.selectBeforeBattle)
        {
            ShowSelectionPanel();
        }
    }
    
    void OnDestroy()
    {
        AttackTypeManager.OnAttackTypeChanged -= UpdateUI;
        AttackTypeManager.OnAttackTypeSelected -= OnTypeSelected;
    }
    
    void Update()
    {
        // ãƒ©ãƒ³ãƒ€ãƒ ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º
        if (settings != null && settings.mode == AttackTypeSelectionMode.RandomTimed)
        {
            UpdateRandomTimer();
        }
    }
    
    private void SelectType(AttackType type)
    {
        if (attackTypeManager != null)
        {
            attackTypeManager.SelectAttackType(type);
        }
    }
    
    private void UpdateUI(AttackType type)
    {
        if (currentTypeText != null)
        {
            currentTypeText.text = type == AttackType.ImpactShot ? "ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆ" : "ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆ";
        }
        
        // ãƒãƒˆãƒ«ä¸­ã®å¤‰æ›´ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ã€å¤‰æ›´ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
        if (settings != null && settings.allowChangeDuringBattle)
        {
            // ãƒãƒˆãƒ«ä¸­ã®å¤‰æ›´UIã‚’è¡¨ç¤º
        }
    }
    
    private void OnTypeSelected(AttackType type)
    {
        // é¸æŠå®Œäº†æ™‚ã®å‡¦ç†
        if (selectionPanel != null && settings != null && settings.selectBeforeBattle)
        {
            selectionPanel.SetActive(false);
            // ãƒãƒˆãƒ«é–‹å§‹ã‚’é€šçŸ¥
        }
    }
    
    private void ShowSelectionPanel()
    {
        if (selectionPanel != null)
        {
            selectionPanel.SetActive(true);
        }
    }
    
    private void UpdateRandomTimer()
    {
        // ãƒ©ãƒ³ãƒ€ãƒ å¤‰æ›´ã¾ã§ã®æ®‹ã‚Šæ™‚é–“ã‚’è¡¨ç¤ºï¼ˆå®Ÿè£…ã¯AttackTypeManagerã‹ã‚‰å–å¾—ï¼‰
        if (randomTimerText != null)
        {
            // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºã®å®Ÿè£…
        }
    }
}
```

---

### Step 5.2: ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/UI/MenuSystem.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆã‚·ãƒ³ã‚°ãƒ«/ãƒãƒ«ãƒ/è¨­å®šï¼‰
- ã‚²ãƒ¼ãƒ è¨­å®šï¼ˆãƒãƒƒãƒæ™‚é–“ã€å¡—ã‚Šå¼·åº¦ãªã©ï¼‰
- ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºç”»é¢ï¼ˆè‰²ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé¸æŠï¼‰

---

## ğŸ¨ Phase 6: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆ2æœˆï¼šé«˜å„ªå…ˆåº¦ï¼‰

**ç›®æ¨™**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ãŸç›®ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹

### Step 6.1: ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Customization/InkCustomizer.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è‰²ã®é¸æŠï¼ˆã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ï¼‰
- ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®é©ç”¨
- è¨­å®šã®ä¿å­˜ï¼ˆPlayerPrefsï¼‰

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ãƒ†ãƒ¼ãƒã‚·ã‚¹ãƒ†ãƒ **: `InkTheme`ï¼ˆScriptableObjectï¼‰ã§è‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ã¾ã¨ã‚ã¦ç®¡ç†
- **ãƒ—ãƒ¬ãƒãƒ–åŒ–**: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªè¦ç´ ã¯å…¨ã¦ãƒ—ãƒ¬ãƒãƒ–åŒ–
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼**: è¨­å®šå¤‰æ›´æ™‚ã«å³åº§ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
- **ãƒ—ãƒªã‚»ãƒƒãƒˆç®¡ç†**: è¤‡æ•°ã®ãƒ†ãƒ¼ãƒãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«

**ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰**:
```csharp
[CreateAssetMenu(fileName = "InkTheme", menuName = "Game/Customization/Ink Theme")]
public class InkTheme : ScriptableObject
{
    [Header("Colors")]
    public Color primaryColor = Color.red;
    public Color secondaryColor = Color.blue;
    public Gradient colorGradient;
    
    [Header("Materials")]
    public InkMaterialData materialData;
    public Texture2D customTexture;
    
    [Header("Effects")]
    public InkEffectSettings effectSettings;
    
    [Header("Visual Style")]
    [Range(0f, 1f)] public float glossiness = 0.5f;
    [Range(0f, 1f)] public float transparency = 0.8f;
    public bool useGlow = true;
    public Color glowColor = Color.white;
}

public class InkCustomizer : MonoBehaviour
{
    [SerializeField] private List<InkTheme> availableThemes;
    [SerializeField] private InkTheme currentTheme;
    [SerializeField] private IInkEffect inkEffect;
    
    public static event Action<InkTheme> OnThemeChanged;
    
    public void ApplyTheme(InkTheme theme)
    {
        currentTheme = theme;
        
        // ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’é©ç”¨
        if (inkEffect != null && theme.materialData != null)
        {
            inkEffect.SetMaterial(theme.materialData.material);
            inkEffect.SetColor(theme.primaryColor);
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
        OnThemeChanged?.Invoke(theme);
        
        // ä¿å­˜
        SaveTheme(theme);
    }
    
    public void SetColor(Color color)
    {
        if (currentTheme != null)
        {
            currentTheme.primaryColor = color;
            inkEffect?.SetColor(color);
        }
    }
    
    public void SetTexture(Texture2D texture)
    {
        if (currentTheme != null && currentTheme.materialData != null)
        {
            currentTheme.materialData.texture = texture;
            // ãƒãƒ†ãƒªã‚¢ãƒ«ã«å³åº§ã«åæ˜ 
        }
    }
    
    private void SaveTheme(InkTheme theme)
    {
        // PlayerPrefsã¾ãŸã¯JSONã§ä¿å­˜
        string themeName = theme.name;
        PlayerPrefs.SetString("SelectedInkTheme", themeName);
    }
    
    public InkTheme LoadTheme()
    {
        string themeName = PlayerPrefs.GetString("SelectedInkTheme", "DefaultTheme");
        return availableThemes.Find(t => t.name == themeName);
    }
}
```

---

### Step 6.2: ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/Customization/SoundCustomizer.cs`

**å®Ÿè£…å†…å®¹**:
- å™´å°„éŸ³ã®å¤‰æ›´
- ä¸Šå¡—ã‚ŠéŸ³ã®å¤‰æ›´
- BGMè¨­å®š

---
```csharp
[CreateAssetMenu(fileName = "SpawnSettings", menuName = "Game/SinglePlayer/Spawn Settings")]
public class SpawnSettings : ScriptableObject
{
    [Header("Spawn Timing")]
    [Range(0.5f, 10f)] public float spawnInterval = 2f;
    [Range(1, 10)] public int maxMonstersOnScreen = 5;
    
    [Header("Difficulty")]
    public AnimationCurve difficultyCurve; // æ™‚é–“çµŒéã«ã‚ˆã‚‹é›£æ˜“åº¦å¤‰åŒ–
    [Range(1f, 5f)] public float speedMultiplierMax = 3f;
}

public class MonsterSpawner : MonoBehaviour
{
    [SerializeField] private SpawnSettings settings;
    [SerializeField] private MonsterSettings monsterSettings;
    [SerializeField] private List<IMonsterMovement> movementPatterns;
    
    private float spawnTimer = 0f;
    private List<Monster> activeMonsters = new List<Monster>();
    private float gameTime = 0f;
    
    void Update()
    {
        gameTime += Time.deltaTime;
        spawnTimer += Time.deltaTime;
        
        // ç”Ÿæˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒã‚§ãƒƒã‚¯
        float currentInterval = settings.spawnInterval / GetDifficultyMultiplier();
        if (spawnTimer >= currentInterval && activeMonsters.Count < settings.maxMonstersOnScreen)
        {
            SpawnMonster();
            spawnTimer = 0f;
        }
        
        // ç”»é¢å¤–ã®ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å‰Šé™¤
        RemoveOffScreenMonsters();
    }
    
    private void SpawnMonster()
    {
        GameObject monsterObj = Instantiate(monsterSettings.monsterPrefab);
        Monster monster = monsterObj.GetComponent<Monster>();
        
        // ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
        IMonsterMovement pattern = movementPatterns[Random.Range(0, movementPatterns.Count)];
        monster.SetMovementPattern(pattern);
        
        // ç”»é¢ç«¯ã‹ã‚‰å‡ºç¾
        Vector2 spawnPos = GetRandomSpawnPosition();
        monster.transform.position = spawnPos;
        
        activeMonsters.Add(monster);
        Monster.OnMonsterDefeated += OnMonsterDefeated;
    }
    
    private float GetDifficultyMultiplier()
    {
        return 1f + (settings.difficultyCurve.Evaluate(gameTime / 60f) * (settings.speedMultiplierMax - 1f));
    }
    
    private void OnMonsterDefeated(Monster monster)
    {
        activeMonsters.Remove(monster);
    }
}
```

---

### Step 3.3: å½“ãŸã‚Šåˆ¤å®šã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/MonsterHitDetector.cs`

**å®Ÿè£…å†…å®¹**:
- ã‚¤ãƒ³ã‚¯ãŒãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã«å½“ãŸã£ãŸã‹ã®åˆ¤å®š
- å½“ãŸã£ãŸæ™‚ã®ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
- ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å†ç”Ÿ

**å®Ÿè£…æ–¹é‡**:
```csharp
public class MonsterHitDetector : MonoBehaviour
{
    [SerializeField] private PaintSystem paintSystem;
    [SerializeField] private List<Monster> monsters;
    
    public static event Action<Vector2, Monster> OnMonsterHit;
    
    void Update()
    {
        // å¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰æœ€æ–°ã®å¡—ã‚Šä½ç½®ã‚’å–å¾—
        Vector2 lastPaintPos = paintSystem.GetLastPaintPosition();
        
        // å„ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨ã®è·é›¢ã‚’ãƒã‚§ãƒƒã‚¯
        foreach (Monster monster in monsters)
        {
            float distance = Vector2.Distance(lastPaintPos, monster.GetPosition());
            float hitRadius = monster.GetHitRadius();
            
            if (distance < hitRadius)
            {
                // ãƒ’ãƒƒãƒˆå‡¦ç†
                monster.TakeDamage(1);
                OnMonsterHit?.Invoke(lastPaintPos, monster);
            }
        }
    }
}
```

---

### Step 3.1.4: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/Modes/MonsterHuntMode.cs`

**å®Ÿè£…å†…å®¹**:
- `ISinglePlayerGameMode`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…
- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰ã®ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯
- ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´æ™‚ï¼‰

**å®Ÿè£…æ–¹é‡**:
```csharp
[CreateAssetMenu(fileName = "MonsterHuntSettings", menuName = "Game/SinglePlayer/Modes/Monster Hunt Settings")]
public class MonsterHuntSettings : ScriptableObject
{
    [Header("Monster Properties")]
    [Range(1, 10)] public int maxHP = 3;
    [Range(10f, 500f)] public float moveSpeed = 100f;
    [Range(0.5f, 5f)] public float spawnInterval = 2f;
    [Range(1, 10)] public int maxMonstersOnScreen = 5;
    
    [Header("Score")]
    public int baseScorePerMonster = 100;
    public int comboBonusMultiplier = 10;
    [Range(2, 10)] public int maxCombo = 5;
    
    [Header("Visual")]
    public GameObject monsterPrefab;
    public Color monsterColor = Color.red;
    [Range(20f, 200f)] public float monsterSize = 50f;
}

public class MonsterHuntMode : MonoBehaviour, ISinglePlayerGameMode
{
    [SerializeField] private MonsterHuntSettings settings;
    [SerializeField] private MonsterSpawner spawner;
    [SerializeField] private MonsterHitDetector hitDetector;
    [SerializeField] private PaintCanvas paintCanvas;
    
    private int currentScore = 0;
    private int currentCombo = 0;
    private float gameTime = 0f;
    private float gameDuration = 180f;
    private bool isGameActive = false;
    
    public SinglePlayerGameModeType GetModeType() => SinglePlayerGameModeType.MonsterHunt;
    
    public void Initialize(SinglePlayerGameModeSettings modeSettings)
    {
        gameDuration = modeSettings.gameDuration;
        // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–
        if (spawner != null)
            spawner.Initialize(settings);
    }
    
    public void StartGame()
    {
        isGameActive = true;
        gameTime = 0f;
        currentScore = 0;
        currentCombo = 0;
        
        // ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­
        Monster.OnMonsterDefeated += OnMonsterDefeated;
    }
    
    public void Update(float deltaTime)
    {
        if (!isGameActive) return;
        
        gameTime += deltaTime;
        
        // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆãƒ»æ›´æ–°
        if (spawner != null)
            spawner.Update(deltaTime);
        
        // å½“ãŸã‚Šåˆ¤å®š
        if (hitDetector != null)
            hitDetector.Update(deltaTime);
    }
    
    public void EndGame()
    {
        isGameActive = false;
        Monster.OnMonsterDefeated -= OnMonsterDefeated;
    }
    
    public void Pause() { isGameActive = false; }
    public void Resume() { isGameActive = true; }
    
    public int GetScore() => currentScore;
    
    public float GetProgress() => Mathf.Clamp01(gameTime / gameDuration);
    
    public bool IsGameOver() => gameTime >= gameDuration;
    
    private void OnMonsterDefeated(Monster monster)
    {
        // ã‚³ãƒ³ãƒœåŠ ç®—
        currentCombo = Mathf.Min(currentCombo + 1, settings.maxCombo);
        
        // ã‚¹ã‚³ã‚¢è¨ˆç®—
        int scoreGain = settings.baseScorePerMonster + (currentCombo * settings.comboBonusMultiplier);
        currentScore += scoreGain;
    }
}
```

---

### Step 3.2: ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰ï¼ˆColor Defense Modeï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/Modes/ColorDefenseMode.cs`

**å®Ÿè£…å†…å®¹**:
- ãƒ©ãƒ³ãƒ€ãƒ ãªå ´æ‰€ã®è‰²ãŒå¾ã€…ã«å¤‰ã‚ã£ã¦ã„ãã®ã‚’ã€å£°ã‚’å‡ºã—ã¦è‰²ã‚’å¡—ã£ã¦é˜²ã
- è‰²ãŒå¤‰ã‚ã‚‹é ˜åŸŸã®ç”Ÿæˆãƒ»ç®¡ç†
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¡—ã£ãŸé ˜åŸŸã¨ã®åˆ¤å®š
- é˜²ã’ãŸé ˜åŸŸæ•°ã§ã‚¹ã‚³ã‚¢è¨ˆç®—

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: è‰²å¤‰åŒ–ã®é€Ÿåº¦ã€é ˜åŸŸã®æ•°ã€ã‚µã‚¤ã‚ºãªã©ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: é ˜åŸŸãŒå®Œå…¨ã«å¤‰è‰²ã—ãŸæ™‚ã€é˜²ã’ãŸæ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«

**å®Ÿè£…æ–¹é‡**:
```csharp
[CreateAssetMenu(fileName = "ColorDefenseSettings", menuName = "Game/SinglePlayer/Modes/Color Defense Settings")]
public class ColorDefenseSettings : ScriptableObject
{
    [Header("Color Change Properties")]
    [Range(0.1f, 5f)] public float colorChangeSpeed = 1f; // è‰²ãŒå¤‰ã‚ã‚‹é€Ÿåº¦
    [Range(0.1f, 1f)] public float colorChangeRate = 0.5f; // 1ç§’ã‚ãŸã‚Šã®å¤‰åŒ–ç‡
    public Color targetColor = Color.red; // å¤‰åŒ–ã™ã‚‹è‰²
    
    [Header("Area Properties")]
    [Range(1, 20)] public int maxAreasOnScreen = 5;
    [Range(50f, 300f)] public float areaSize = 100f;
    [Range(1f, 10f)] public float spawnInterval = 3f;
    
    [Header("Score")]
    public int scorePerDefendedArea = 50;
    public int penaltyPerChangedArea = -20;
}

public class ColorDefenseMode : MonoBehaviour, ISinglePlayerGameMode
{
    [SerializeField] private ColorDefenseSettings settings;
    [SerializeField] private PaintCanvas paintCanvas;
    
    private List<ColorChangeArea> activeAreas = new List<ColorChangeArea>();
    private float spawnTimer = 0f;
    private int currentScore = 0;
    private float gameTime = 0f;
    private float gameDuration = 180f;
    private bool isGameActive = false;
    
    public SinglePlayerGameModeType GetModeType() => SinglePlayerGameModeType.ColorDefense;
    
    public void Initialize(SinglePlayerGameModeSettings modeSettings)
    {
        gameDuration = modeSettings.gameDuration;
    }
    
    public void StartGame()
    {
        isGameActive = true;
        gameTime = 0f;
        currentScore = 0;
        activeAreas.Clear();
        spawnTimer = 0f;
    }
    
    public void Update(float deltaTime)
    {
        if (!isGameActive) return;
        
        gameTime += deltaTime;
        spawnTimer += deltaTime;
        
        // æ–°ã—ã„é ˜åŸŸã‚’ç”Ÿæˆ
        if (spawnTimer >= settings.spawnInterval && activeAreas.Count < settings.maxAreasOnScreen)
        {
            SpawnColorChangeArea();
            spawnTimer = 0f;
        }
        
        // å„é ˜åŸŸã®æ›´æ–°
        for (int i = activeAreas.Count - 1; i >= 0; i--)
        {
            ColorChangeArea area = activeAreas[i];
            area.Update(deltaTime, paintCanvas);
            
            // å®Œå…¨ã«å¤‰è‰²ã—ãŸå ´åˆ
            if (area.IsFullyChanged())
            {
                currentScore += settings.penaltyPerChangedArea;
                activeAreas.RemoveAt(i);
                Destroy(area.gameObject);
            }
            // å®Œå…¨ã«é˜²ã’ãŸå ´åˆ
            else if (area.IsFullyDefended())
            {
                currentScore += settings.scorePerDefendedArea;
                activeAreas.RemoveAt(i);
                Destroy(area.gameObject);
            }
        }
    }
    
    private void SpawnColorChangeArea()
    {
        GameObject areaObj = new GameObject("ColorChangeArea");
        ColorChangeArea area = areaObj.AddComponent<ColorChangeArea>();
        area.Initialize(settings, GetRandomPosition());
        activeAreas.Add(area);
    }
    
    private Vector2 GetRandomPosition()
    {
        return new Vector2(
            Random.Range(100f, Screen.width - 100f),
            Random.Range(100f, Screen.height - 100f)
        );
    }
    
    public void EndGame() { isGameActive = false; }
    public void Pause() { isGameActive = false; }
    public void Resume() { isGameActive = true; }
    public int GetScore() => currentScore;
    public float GetProgress() => Mathf.Clamp01(gameTime / gameDuration);
    public bool IsGameOver() => gameTime >= gameDuration;
}

// è‰²ãŒå¤‰ã‚ã‚‹é ˜åŸŸã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
public class ColorChangeArea : MonoBehaviour
{
    private ColorDefenseSettings settings;
    private Vector2 centerPosition;
    private float changeProgress = 0f; // 0.0ï½1.0
    private float defendedProgress = 0f; // 0.0ï½1.0
    
    public void Initialize(ColorDefenseSettings settings, Vector2 position)
    {
        this.settings = settings;
        this.centerPosition = position;
        changeProgress = 0f;
        defendedProgress = 0f;
    }
    
    public void Update(float deltaTime, PaintCanvas canvas)
    {
        // è‰²å¤‰åŒ–ã®é€²è¡Œ
        changeProgress += settings.colorChangeRate * deltaTime;
        changeProgress = Mathf.Clamp01(changeProgress);
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¡—ã£ãŸé ˜åŸŸã‚’ãƒã‚§ãƒƒã‚¯
        CheckPlayerPaint(canvas);
    }
    
    private void CheckPlayerPaint(PaintCanvas canvas)
    {
        // é ˜åŸŸå†…ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¡—ã‚Šå…·åˆã‚’ãƒã‚§ãƒƒã‚¯
        // å¡—ã‚‰ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã—ã¦ã€defendedProgressã‚’æ›´æ–°
        int totalPixels = GetTotalPixelsInArea();
        int paintedPixels = GetPaintedPixelsInArea(canvas);
        defendedProgress = (float)paintedPixels / totalPixels;
    }
    
    public bool IsFullyChanged() => changeProgress >= 1f && defendedProgress < 0.5f;
    public bool IsFullyDefended() => defendedProgress >= 0.9f;
    
    private int GetTotalPixelsInArea() { /* å®Ÿè£… */ return 0; }
    private int GetPaintedPixelsInArea(PaintCanvas canvas) { /* å®Ÿè£… */ return 0; }
}
```

---

### Step 3.3: ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆTracing Modeï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/Modes/TracingMode.cs`

**å®Ÿè£…å†…å®¹**:
- é€æ˜ãªçµµãŒä¸‹ã«æ›¸ã„ã¦ã‚ã£ã¦ã€ãã®ç·šã‚’ãªãã‚‹
- ãªãã‚ŒãŸåº¦åˆã„ãŒç‚¹æ•°ã«ãªã‚‹
- ç·šã®åˆ¤å®šã¨ç²¾åº¦è¨ˆç®—

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **ScriptableObjectè¨­å®š**: ç·šã®å¤ªã•ã€è¨±å®¹èª¤å·®ã€ã‚¹ã‚³ã‚¢è¨ˆç®—å¼ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **çµµã®ãƒ‡ãƒ¼ã‚¿**: çµµã®ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šã€ç‚¹åˆ—ãªã©ï¼‰ã‚’ScriptableObjectã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: ç·šã‚’ãªãã£ãŸæ™‚ã€å®Œæˆåº¦ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«

**å®Ÿè£…æ–¹é‡**:
```csharp
[CreateAssetMenu(fileName = "TracingSettings", menuName = "Game/SinglePlayer/Modes/Tracing Settings")]
public class TracingSettings : ScriptableObject
{
    [Header("Line Properties")]
    [Range(10f, 100f)] public float lineTolerance = 30f; // ç·šã‹ã‚‰ã®è¨±å®¹è·é›¢
    [Range(5f, 50f)] public float lineWidth = 20f;
    
    [Header("Score")]
    public int baseScorePerLine = 100;
    [Range(0.5f, 1f)] public float perfectThreshold = 0.95f; // å®Œç’§ãªãªãã‚Šã®é–¾å€¤
    public int perfectBonus = 50;
    
    [Header("Drawing Data")]
    public TracingDrawingData drawingData; // ãªãã‚‹çµµã®ãƒ‡ãƒ¼ã‚¿
}

[CreateAssetMenu(fileName = "TracingDrawingData", menuName = "Game/SinglePlayer/Modes/Tracing Drawing Data")]
public class TracingDrawingData : ScriptableObject
{
    public List<TracingLine> lines = new List<TracingLine>();
}

[System.Serializable]
public class TracingLine
{
    public List<Vector2> points = new List<Vector2>(); // ç·šã®ç‚¹åˆ—
    public float lineWidth = 20f;
}

public class TracingMode : MonoBehaviour, ISinglePlayerGameMode
{
    [SerializeField] private TracingSettings settings;
    [SerializeField] private PaintCanvas paintCanvas;
    
    private List<TracingLine> lines;
    private Dictionary<TracingLine, float> lineProgress = new Dictionary<TracingLine, float>();
    private int currentScore = 0;
    private float gameTime = 0f;
    private float gameDuration = 180f;
    private bool isGameActive = false;
    
    public SinglePlayerGameModeType GetModeType() => SinglePlayerGameModeType.Tracing;
    
    public void Initialize(SinglePlayerGameModeSettings modeSettings)
    {
        gameDuration = modeSettings.gameDuration;
        lines = new List<TracingLine>(settings.drawingData.lines);
        
        // å„ç·šã®é€²æ—ã‚’åˆæœŸåŒ–
        foreach (var line in lines)
        {
            lineProgress[line] = 0f;
        }
    }
    
    public void StartGame()
    {
        isGameActive = true;
        gameTime = 0f;
        currentScore = 0;
    }
    
    public void Update(float deltaTime)
    {
        if (!isGameActive) return;
        
        gameTime += deltaTime;
        
        // å„ç·šã®ãªãã‚Šå…·åˆã‚’ãƒã‚§ãƒƒã‚¯
        foreach (var line in lines)
        {
            float progress = CalculateLineProgress(line);
            lineProgress[line] = progress;
            
            // ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆé€²æ—ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚ã®ã¿ï¼‰
            if (progress > 0.9f && !lineProgress.ContainsKey(line))
            {
                CalculateLineScore(line, progress);
            }
        }
    }
    
    private float CalculateLineProgress(TracingLine line)
    {
        float totalLength = GetLineLength(line);
        float tracedLength = GetTracedLength(line, paintCanvas);
        return tracedLength / totalLength;
    }
    
    private void CalculateLineScore(TracingLine line, float progress)
    {
        int score = settings.baseScorePerLine;
        
        // å®Œç’§ãªãªãã‚Šã®å ´åˆã€ãƒœãƒ¼ãƒŠã‚¹è¿½åŠ 
        if (progress >= settings.perfectThreshold)
        {
            score += settings.perfectBonus;
        }
        
        // é€²æ—ã«å¿œã˜ã¦ã‚¹ã‚³ã‚¢ã‚’èª¿æ•´
        score = Mathf.RoundToInt(score * progress);
        currentScore += score;
    }
    
    private float GetLineLength(TracingLine line)
    {
        float length = 0f;
        for (int i = 1; i < line.points.Count; i++)
        {
            length += Vector2.Distance(line.points[i - 1], line.points[i]);
        }
        return length;
    }
    
    private float GetTracedLength(TracingLine line, PaintCanvas canvas)
    {
        float tracedLength = 0f;
        for (int i = 1; i < line.points.Count; i++)
        {
            Vector2 start = line.points[i - 1];
            Vector2 end = line.points[i];
            
            // ç·šåˆ†ä¸Šã®ç‚¹ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚ˆã£ã¦å¡—ã‚‰ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            int segments = Mathf.CeilToInt(Vector2.Distance(start, end) / settings.lineTolerance);
            for (int j = 0; j <= segments; j++)
            {
                float t = (float)j / segments;
                Vector2 point = Vector2.Lerp(start, end, t);
                
                // ã“ã®ç‚¹ãŒå¡—ã‚‰ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                if (IsPointPainted(point, canvas))
                {
                    tracedLength += Vector2.Distance(start, end) / segments;
                }
            }
        }
        return tracedLength;
    }
    
    private bool IsPointPainted(Vector2 point, PaintCanvas canvas)
    {
        // ç‚¹ã®å‘¨å›²ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆè¨±å®¹èª¤å·®å†…ï¼‰
        int playerId = canvas.GetPlayerIdAt(point);
        return playerId > 0; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¡—ã£ã¦ã„ã‚‹
    }
    
    public void EndGame() { isGameActive = false; }
    public void Pause() { isGameActive = false; }
    public void Resume() { isGameActive = true; }
    public int GetScore() => currentScore;
    public float GetProgress() => Mathf.Clamp01(gameTime / gameDuration);
    public bool IsGameOver() => gameTime >= gameDuration;
}
```

---

### Step 3.4: AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰ï¼ˆAI Battle Modeï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/Modes/AIBattleMode.cs`

**å®Ÿè£…å†…å®¹**:
- AIã¨è‰²å¡—ã‚Šå¯¾æ±º
- AIã®å¡—ã‚Šæˆ¦ç•¥ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½å¾“ãªã©ï¼‰
- å¡—ã‚Šé¢ç©ã®æ¯”è¼ƒã§å‹æ•—åˆ¤å®š
- ã‚¿ã‚¤ãƒãƒ¼åˆ¶é™

**å¤‰æ›´ã—ã‚„ã™ã•ã®è€ƒæ…®äº‹é …**:
- **AIæˆ¦ç•¥ã®æŠ½è±¡åŒ–**: `IAIPaintStrategy`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§AIã®è¡Œå‹•ã‚’å·®ã—æ›¿ãˆå¯èƒ½ã«
- **ScriptableObjectè¨­å®š**: AIã®é›£æ˜“åº¦ã€å¡—ã‚Šé€Ÿåº¦ã€æˆ¦ç•¥ã‚¿ã‚¤ãƒ—ã‚’è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ç®¡ç†
- **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: AIãŒå¡—ã£ãŸæ™‚ã€å‹æ•—ãŒæ±ºã¾ã£ãŸæ™‚ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«

**å®Ÿè£…æ–¹é‡**:
```csharp
[CreateAssetMenu(fileName = "AIBattleSettings", menuName = "Game/SinglePlayer/Modes/AI Battle Settings")]
public class AIBattleSettings : ScriptableObject
{
    [Header("AI Properties")]
    public AIDifficulty difficulty = AIDifficulty.Medium;
    [Range(0.1f, 2f)] public float aiPaintSpeed = 1f; // AIã®å¡—ã‚Šé€Ÿåº¦å€ç‡
    public AIPaintStrategyType strategyType = AIPaintStrategyType.Random;
    
    [Header("Game Rules")]
    [Range(30f, 300f)] public float battleDuration = 180f;
    [Range(0.1f, 1f)] public float victoryThreshold = 0.6f; // å‹åˆ©ã«å¿…è¦ãªå¡—ã‚Šé¢ç©ã®å‰²åˆ
    
    [Header("Score")]
    public int winScore = 1000;
    public int loseScore = 100;
}

public enum AIDifficulty
{
    Easy,    // é…ã„ã€å˜ç´”ãªæˆ¦ç•¥
    Medium,  // æ™®é€šã®é€Ÿåº¦ã€ä¸­ç¨‹åº¦ã®æˆ¦ç•¥
    Hard     // é€Ÿã„ã€è¤‡é›‘ãªæˆ¦ç•¥
}

public enum AIPaintStrategyType
{
    Random,      // ãƒ©ãƒ³ãƒ€ãƒ ã«å¡—ã‚‹
    Pattern,     // ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å¡—ã‚‹
    Aggressive,  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é ˜åŸŸã‚’å¥ªã†
    Defensive    // è‡ªåˆ†ã®é ˜åŸŸã‚’å®ˆã‚‹
}

public interface IAIPaintStrategy
{
    Vector2 GetNextPaintPosition(PaintCanvas canvas, float deltaTime);
    void Initialize(AIBattleSettings settings);
}

public class AIBattleMode : MonoBehaviour, ISinglePlayerGameMode
{
    [SerializeField] private AIBattleSettings settings;
    [SerializeField] private PaintCanvas paintCanvas;
    [SerializeField] private IAIPaintStrategy aiStrategy;
    
    private const int PLAYER_ID = 1;
    private const int AI_ID = 2;
    
    private int currentScore = 0;
    private float gameTime = 0f;
    private float aiPaintTimer = 0f;
    private bool isGameActive = false;
    private bool isPlayerWon = false;
    
    public SinglePlayerGameModeType GetModeType() => SinglePlayerGameModeType.AIBattle;
    
    public void Initialize(SinglePlayerGameModeSettings modeSettings)
    {
        settings.battleDuration = modeSettings.gameDuration;
        
        // AIæˆ¦ç•¥ã‚’åˆæœŸåŒ–
        InitializeAIStrategy();
    }
    
    private void InitializeAIStrategy()
    {
        switch (settings.strategyType)
        {
            case AIPaintStrategyType.Random:
                aiStrategy = gameObject.AddComponent<RandomAIPaintStrategy>();
                break;
            case AIPaintStrategyType.Pattern:
                aiStrategy = gameObject.AddComponent<PatternAIPaintStrategy>();
                break;
            case AIPaintStrategyType.Aggressive:
                aiStrategy = gameObject.AddComponent<AggressiveAIPaintStrategy>();
                break;
            case AIPaintStrategyType.Defensive:
                aiStrategy = gameObject.AddComponent<DefensiveAIPaintStrategy>();
                break;
        }
        
        if (aiStrategy != null)
        {
            aiStrategy.Initialize(settings);
        }
    }
    
    public void StartGame()
    {
        isGameActive = true;
        gameTime = 0f;
        currentScore = 0;
        aiPaintTimer = 0f;
        isPlayerWon = false;
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
        if (paintCanvas != null)
            paintCanvas.ResetCanvas();
    }
    
    public void Update(float deltaTime)
    {
        if (!isGameActive) return;
        
        gameTime += deltaTime;
        aiPaintTimer += deltaTime;
        
        // AIã®å¡—ã‚Šå‡¦ç†
        float aiPaintInterval = 1f / settings.aiPaintSpeed; // é›£æ˜“åº¦ã«å¿œã˜ã¦èª¿æ•´
        if (aiPaintTimer >= aiPaintInterval && aiStrategy != null)
        {
            Vector2 aiPaintPos = aiStrategy.GetNextPaintPosition(paintCanvas, deltaTime);
            if (paintCanvas != null)
            {
                paintCanvas.PaintAt(aiPaintPos, AI_ID, 1f, GetAIColor());
            }
            aiPaintTimer = 0f;
        }
        
        // å‹æ•—åˆ¤å®š
        CheckVictory();
    }
    
    private void CheckVictory()
    {
        if (paintCanvas == null) return;
        
        float playerArea = paintCanvas.GetPaintedArea(PLAYER_ID);
        float aiArea = paintCanvas.GetPaintedArea(AI_ID);
        float totalArea = playerArea + aiArea;
        
        if (totalArea > 0.1f) // ã‚ã‚‹ç¨‹åº¦å¡—ã‚‰ã‚ŒãŸå ´åˆ
        {
            float playerRatio = playerArea / totalArea;
            
            if (playerRatio >= settings.victoryThreshold)
            {
                isPlayerWon = true;
                currentScore = settings.winScore;
                EndGame();
    }
            else if (aiArea / totalArea >= settings.victoryThreshold)
            {
                isPlayerWon = false;
                currentScore = settings.loseScore;
                EndGame();
            }
        }
    }
    
    private Color GetAIColor()
    {
        // AIã®è‰²ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨åŒºåˆ¥ã§ãã‚‹è‰²ï¼‰
        return Color.blue;
    }
    
    public void EndGame() { isGameActive = false; }
    public void Pause() { isGameActive = false; }
    public void Resume() { isGameActive = true; }
    public int GetScore() => currentScore;
    public float GetProgress() => Mathf.Clamp01(gameTime / settings.battleDuration);
    public bool IsGameOver() => gameTime >= settings.battleDuration || isPlayerWon || currentScore > 0;
}

// AIæˆ¦ç•¥ã®å®Ÿè£…ä¾‹ï¼šãƒ©ãƒ³ãƒ€ãƒ æˆ¦ç•¥
public class RandomAIPaintStrategy : MonoBehaviour, IAIPaintStrategy
{
    private AIBattleSettings settings;
    
    public void Initialize(AIBattleSettings settings)
    {
        this.settings = settings;
    }
    
    public Vector2 GetNextPaintPosition(PaintCanvas canvas, float deltaTime)
    {
        // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã‚’è¿”ã™
        return new Vector2(
            Random.Range(0f, Screen.width),
            Random.Range(0f, Screen.height)
        );
    }
}
```

---

### Step 3.5: ã‚¹ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå…±é€šï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/SinglePlayer/ScoreManager.cs`

**å®Ÿè£…å†…å®¹**:
- å…¨ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰å…±é€šã®ã‚¹ã‚³ã‚¢ç®¡ç†
- ã‚¹ã‚³ã‚¢è¡¨ç¤º
- ãƒ©ãƒ³ã‚­ãƒ³ã‚°ä¿å­˜

**å®Ÿè£…æ–¹é‡**:
```csharp
[CreateAssetMenu(fileName = "ScoreSettings", menuName = "Game/SinglePlayer/Score Settings")]
public class ScoreSettings : ScriptableObject
{
    [Header("Ranking")]
    public int maxRankingEntries = 10;
    public string rankingKeyPrefix = "SinglePlayerRanking_";
}

public class ScoreManager : MonoBehaviour
{
    [SerializeField] private ScoreSettings settings;
    
    public static event Action<int> OnScoreUpdated;
    public static event Action<List<RankingEntry>> OnRankingUpdated;
    
    public void SaveScore(int score, SinglePlayerGameModeType modeType)
    {
        string key = $"{settings.rankingKeyPrefix}{modeType}";
        // PlayerPrefsã¾ãŸã¯JSONã§ä¿å­˜
        // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’æ›´æ–°
    }
    
    public List<RankingEntry> GetRanking(SinglePlayerGameModeType modeType)
    {
        string key = $"{settings.rankingKeyPrefix}{modeType}";
        // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’èª­ã¿è¾¼ã‚“ã§è¿”ã™
        return new List<RankingEntry>();
    }
}

[System.Serializable]
public class RankingEntry
{
    public int score;
    public System.DateTime dateTime;
    public SinglePlayerGameModeType modeType;
}
```

---

## ğŸ› Phase 7: æœ€é©åŒ–ã¨ãƒã‚°ä¿®æ­£ï¼ˆ3æœˆï¼‰

**ç›®æ¨™**: ãƒªãƒªãƒ¼ã‚¹æº–å‚™å®Œäº†

### Step 7.1: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°é »åº¦ã®æœ€é©åŒ–
- ãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°ã®åŠ¹ç‡åŒ–
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®å‰Šæ¸›

### Step 7.2: ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
- æ”»æ’ƒã‚¿ã‚¤ãƒ—ã®å¼·åº¦èª¿æ•´
- å¡—ã‚Šé€Ÿåº¦ã®èª¿æ•´
- ãƒãƒƒãƒæ™‚é–“ã®èª¿æ•´

### Step 7.3: ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£æ”¹å–„
- UIã®æ–‡å­—ã‚µã‚¤ã‚ºèª¿æ•´
- è‰²è¦šå¤šæ§˜æ€§ã¸ã®é…æ…®ï¼ˆè‰²ã ã‘ã§ãªãå½¢çŠ¶ã§ã‚‚åŒºåˆ¥ï¼‰
- æ“ä½œèª¬æ˜ã®æ˜ç¢ºåŒ–

---

## ğŸ® Phase 8: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦ï¼‰ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰ï¼ˆ3æœˆä»¥é™ï¼‰

**ç›®æ¨™**: åŒä¸€ç«¯æœ«ã§ã®2äººå¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹

**æ³¨æ„**: ä»–ã®æ©Ÿèƒ½ãŒå®Œæˆã—ã¦ã‹ã‚‰å®Ÿè£…ã™ã‚‹ã€‚å„ªå…ˆé †ä½ã¯æœ€ã‚‚ä½ã„ã€‚

### Step 8.1: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/PlayerManager.cs`

**å®Ÿè£…å†…å®¹**:
- è¤‡æ•°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç®¡ç†ï¼ˆIDã€è‰²ã€ã‚¹ã‚³ã‚¢ï¼‰
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã”ã¨ã®å¡—ã‚Šé¢ç©ã®è¿½è·¡

```csharp
public class PlayerManager : MonoBehaviour
{
    public class Player
    {
        public int playerId;
        public Color playerColor;
        public float paintedArea;
        public string playerName;
    }
    
    private List<Player> players = new List<Player>();
    
    public void RegisterPlayer(int id, Color color);
    public Player GetPlayer(int id);
    public Player GetWinner(); // å¡—ã‚Šé¢ç©æœ€å¤§ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
}
```

---

### Step 8.2: å‹åˆ©æ¡ä»¶åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Script/GameLogic/VictoryCondition.cs`

**å®Ÿè£…å†…å®¹**:
- åˆ¶é™æ™‚é–“ã®ç®¡ç†
- å¡—ã‚Šé¢ç©ã®è¨ˆç®—ã¨æ¯”è¼ƒ
- å‹åˆ©åˆ¤å®šã¨çµæœè¡¨ç¤º

```csharp
public class VictoryCondition : MonoBehaviour
{
    public float matchDuration = 180f; // 3åˆ†
    private float remainingTime;
    
    void Update()
    {
        remainingTime -= Time.deltaTime;
        if (remainingTime <= 0f)
        {
            EndMatch();
        }
    }
    
    private void EndMatch()
    {
        Player winner = playerManager.GetWinner();
        // çµæœè¡¨ç¤ºUIã‚’è¡¨ç¤º
    }
}
```

---

### Step 8.3: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãƒ—ãƒ¬ã‚¤ã®å®Ÿè£…

**å®Ÿè£…å†…å®¹**:
- åŒä¸€ç«¯æœ«ã§ã®è¤‡æ•°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚­ãƒ¼å…¥åŠ›ã¾ãŸã¯è‡ªå‹•ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
- å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®éŸ³å£°å…¥åŠ›ã‚’å€‹åˆ¥ã«å‡¦ç†

**è€ƒæ…®äº‹é …**:
- ãƒã‚¤ã‚¯å…¥åŠ›ã®åˆ‡ã‚Šæ›¿ãˆï¼ˆè¤‡æ•°ãƒã‚¤ã‚¯å¯¾å¿œï¼‰
- ã¾ãŸã¯ã€éŸ³å£°ã®ç‰¹å¾´ï¼ˆãƒ”ãƒƒãƒ/ãƒœãƒªãƒ¥ãƒ¼ãƒ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è­˜åˆ¥

---

## ğŸ“ å®Ÿè£…ã®å„ªå…ˆé †ä½ï¼ˆè©³ç´°ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆï¼‰

### ğŸ”´ Phase 1: ã‚³ã‚¢ã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæœ€å„ªå…ˆï¼‰
1. PaintCanvas ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 1.1.1ï¼‰
2. åº§æ¨™å¤‰æ›ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 1.1.2ï¼‰
3. ã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆStep 1.1.3ï¼‰
4. æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 1.2.1ï¼‰
5. å„é¸æŠãƒ¢ãƒ¼ãƒ‰ã®å®Ÿè£…ï¼ˆStep 1.2.2ï¼‰
6. æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆè‡ªå‹•åˆ¤å®šç”¨ã€Step 1.2.3ï¼‰
7. æ”»æ’ƒã‚¿ã‚¤ãƒ—åˆ¥å¡—ã‚Šãƒ­ã‚¸ãƒƒã‚¯ï¼ˆStep 1.2.4ï¼‰
8. ã‚²ãƒ¼ãƒ ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼çµ±åˆï¼ˆStep 1.3ï¼‰

### ğŸŸ¢ Phase 2: ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆå®Ÿè£…é›£æ˜“åº¦ï¼šä½ï¼‰
9. ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆå¡—ã‚Šã‚·ã‚¹ãƒ†ãƒ ã®ã¿ä½¿ç”¨ï¼‰
10. ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ç”¨UIï¼ˆã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã€è‰²é¸æŠãªã©ï¼‰
11. ä¿å­˜æ©Ÿèƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

### ğŸŸ¡ Phase 3: ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ï¼ˆå„ªå…ˆå®Ÿè£…ï¼‰
12. ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆStep 3.0ï¼‰
13. **ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰**ï¼ˆStep 3.2ï¼‰ã€å„ªå…ˆåº¦é«˜ã€‘
14. **ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰**:
    - ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 3.1.1ï¼‰
    - ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ç”Ÿæˆãƒ»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 3.1.2ï¼‰
    - å½“ãŸã‚Šåˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 3.1.3ï¼‰
    - ãƒ¢ãƒ¼ãƒ‰å®Ÿè£…ï¼ˆStep 3.1.4ï¼‰
15. **ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰**ï¼ˆStep 3.3ï¼‰
16. **AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰**ï¼ˆStep 3.4ï¼‰
17. ã‚¹ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå…±é€šï¼‰ï¼ˆStep 3.5ï¼‰
18. ã‚·ãƒ³ã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ç”¨UIï¼ˆã‚¹ã‚³ã‚¢ã€ã‚¿ã‚¤ãƒãƒ¼ã€ãƒ¢ãƒ¼ãƒ‰é¸æŠè¡¨ç¤ºï¼‰

### ğŸŸ¢ Phase 4: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ã®æ¬¡ï¼‰
19. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å®Ÿè£…ï¼ˆStep 4.1ï¼‰
20. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸã‚·ã‚¹ãƒ†ãƒ 
21. ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°

### ğŸ”µ Phase 5: UI/UXå®Ÿè£…
22. ã‚²ãƒ¼ãƒ ç”»é¢UIï¼ˆStep 5.1ï¼‰
23. æ”»æ’ƒã‚¿ã‚¤ãƒ—é¸æŠUIï¼ˆStep 5.1.1ï¼‰
24. ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 5.2ï¼‰
25. ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### ğŸŸ£ Phase 6: ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ 
26. ã‚¤ãƒ³ã‚¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼ˆStep 6.1ï¼‰
27. ã‚µã‚¦ãƒ³ãƒ‰ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼ˆStep 6.2ï¼‰

### âšª Phase 7: æœ€é©åŒ–ã¨ãƒã‚°ä¿®æ­£
28. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
29. ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
30. ãƒã‚°ä¿®æ­£

### ğŸ”´ Phase 8: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦ï¼‰ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰
31. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆStep 8.1ï¼‰
32. å‹åˆ©æ¡ä»¶åˆ¤å®šï¼ˆStep 8.2ï¼‰
33. ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒå®Ÿè£…ï¼ˆStep 8.3ï¼‰
34. å¯¾æˆ¦ç”¨UIï¼ˆå¡—ã‚Šé¢ç©è¡¨ç¤ºã€ã‚¿ã‚¤ãƒãƒ¼ï¼‰

---

## ğŸ”§ æŠ€è¡“çš„ãªè€ƒæ…®äº‹é …

### å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†æ–¹æ³•
- **Option 1**: Texture2Dï¼ˆå„ãƒ”ã‚¯ã‚»ãƒ«ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’è¨˜éŒ²ï¼‰
  - ãƒ¡ãƒªãƒƒãƒˆ: è¦–è¦šçš„ã€Unityæ¨™æº–
  - ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¤§ãã„
  
- **Option 2**: 2Dé…åˆ—ï¼ˆint[,]ï¼‰
  - ãƒ¡ãƒªãƒƒãƒˆ: è»½é‡ã€é«˜é€Ÿã‚¢ã‚¯ã‚»ã‚¹
  - ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ: å¯è¦–åŒ–ã«è¿½åŠ å‡¦ç†ãŒå¿…è¦

- **æ¨å¥¨**: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ï¼ˆå†…éƒ¨ã¯é…åˆ—ã€è¡¨ç¤ºã¯Texture2Dï¼‰

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åŒæœŸ
- å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ã¯é »ç¹ã«æ›´æ–°ã•ã‚Œã‚‹ãŸã‚ã€å…¨ãƒ”ã‚¯ã‚»ãƒ«ã‚’åŒæœŸã™ã‚‹ã®ã¯éåŠ¹ç‡
- å·®åˆ†æ›´æ–°ï¼ˆå¤‰æ›´ã•ã‚ŒãŸé ˜åŸŸã®ã¿é€ä¿¡ï¼‰ã‚’å®Ÿè£…
- ã¾ãŸã¯ã€å¡—ã‚Šã‚³ãƒãƒ³ãƒ‰ï¼ˆä½ç½®ã€ã‚¿ã‚¤ãƒ—ã€å¼·åº¦ï¼‰ã®ã¿ã‚’åŒæœŸ

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- å¡—ã‚Šå‡¦ç†ã¯æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€æœ€é©åŒ–ãŒé‡è¦
- å¡—ã‚Šç¯„å›²ã‚’åˆ¶é™ï¼ˆç”»é¢å¤–ã¯å‡¦ç†ã—ãªã„ï¼‰
- æ›´æ–°é »åº¦ã‚’ä¸‹ã’ã‚‹ï¼ˆä¾‹: 60fps â†’ 30fpsã§å¡—ã‚Šæ›´æ–°ï¼‰

---

## ğŸ“š å‚è€ƒãƒªã‚½ãƒ¼ã‚¹

- Unity RenderTexture ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- Unity Netcode for GameObjectsï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒç”¨ï¼‰
- Unity Particle Systemï¼ˆã‚¤ãƒ³ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ï¼‰
- Unity UI Toolkitï¼ˆUIå®Ÿè£…ç”¨ï¼‰

---

## âœ… å¤‰æ›´ã—ã‚„ã™ã•ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

å„å®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—ã§ã€ä»¥ä¸‹ã®é …ç›®ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š

### è¨­è¨ˆãƒã‚§ãƒƒã‚¯
- [ ] **ScriptableObjectè¨­å®š**: èª¿æ•´ãŒå¿…è¦ãªå€¤ã¯å…¨ã¦ScriptableObjectã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **Inspectoræ¥ç¶š**: ä¾å­˜é–¢ä¿‚ã¯Inspectorã§æ¥ç¶šå¯èƒ½ã‹ï¼Ÿï¼ˆFindObjectOfTypeã‚’é¿ã‘ã‚‹ï¼‰
- [ ] **ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–**: å·®ã—æ›¿ãˆãŒå¿…è¦ãªæ©Ÿèƒ½ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«**: ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ãŒåå¿œã™ã¹ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã—ã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **Tooltip/Header**: å…¨ã¦ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«èª¬æ˜ã¨ãƒ˜ãƒƒãƒ€ãƒ¼ãŒä»˜ã„ã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **Rangeåˆ¶é™**: æ•°å€¤ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«é©åˆ‡ãªç¯„å›²åˆ¶é™ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ

### ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯
- [ ] **å˜ä¸€è²¬ä»»**: å„ã‚¯ãƒ©ã‚¹ã¯1ã¤ã®è²¬ä»»ã®ã¿ã‚’æŒã£ã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ä¾å­˜æ€§æ³¨å…¥**: ä¾å­˜é–¢ä¿‚ã¯å¤–éƒ¨ã‹ã‚‰æ³¨å…¥å¯èƒ½ã‹ï¼Ÿ
- [ ] **æ‹¡å¼µæ€§**: æ–°ã—ã„æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹éš›ã€æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã®å¤‰æ›´ãŒæœ€å°é™ã‹ï¼Ÿ
- [ ] **ãƒ†ã‚¹ãƒˆå®¹æ˜“æ€§**: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆãŒæ›¸ãã‚„ã™ã„æ§‹é€ ã‹ï¼Ÿ

### ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ãƒã‚§ãƒƒã‚¯
- [ ] **è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«**: ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ã«ã‚³ãƒ¼ãƒ‰å¤‰æ›´ã¯ä¸è¦ã‹ï¼Ÿ
- [ ] **ãƒ—ãƒªã‚»ãƒƒãƒˆ**: è¤‡æ•°ã®ãƒãƒ©ãƒ³ã‚¹ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ç°¡å˜ã«åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹ã‹ï¼Ÿ
- [ ] **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ èª¿æ•´**: å®Ÿè¡Œä¸­ã«è¨­å®šã‚’å¤‰æ›´ã—ã¦ãƒ†ã‚¹ãƒˆã§ãã‚‹ã‹ï¼Ÿï¼ˆEditoræ‹¡å¼µï¼‰

### ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯æŸ”è»Ÿæ€§ãƒã‚§ãƒƒã‚¯
- [ ] **ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæŠ½è±¡åŒ–**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå®Ÿè£…ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ãƒãƒ†ãƒªã‚¢ãƒ«ç®¡ç†**: ãƒãƒ†ãƒªã‚¢ãƒ«ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€è‰²ã¯ScriptableObjectã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
- [ ] **ãƒ—ãƒ¬ãƒãƒ–åŒ–**: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ¬ãƒãƒ–åŒ–ã•ã‚Œã€Inspectorã§å·®ã—æ›¿ãˆå¯èƒ½ã‹ï¼Ÿ
- [ ] **å‹•çš„å¤‰æ›´**: å®Ÿè¡Œä¸­ã«ãƒãƒ†ãƒªã‚¢ãƒ«ã‚„è‰²ã‚’å¤‰æ›´ã§ãã‚‹APIãŒã‚ã‚‹ã‹ï¼Ÿ
- [ ] **ãƒ†ãƒ¼ãƒã‚·ã‚¹ãƒ†ãƒ **: ãƒ†ãƒ¼ãƒï¼ˆè‰²ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰ã‚’ã¾ã¨ã‚ã¦ç®¡ç†ã§ãã‚‹ã‹ï¼Ÿ
- [ ] **ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**: Built-in/URP/HDRPã«å¯¾å¿œã§ãã‚‹è¨­è¨ˆã‹ï¼Ÿ
- [ ] **ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºä¿å­˜**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºè¨­å®šãŒä¿å­˜ãƒ»èª­ã¿è¾¼ã¿å¯èƒ½ã‹ï¼Ÿ

---

## âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Phase 1 å®Œäº†æ¡ä»¶
- [ ] å£°ã‚’å‡ºã™ã¨ç”»é¢ã®æŒ‡å®šä½ç½®ã«è‰²ãŒå¡—ã‚‰ã‚Œã‚‹
- [ ] ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚·ãƒ§ãƒƒãƒˆã¨ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒšã‚¤ãƒ³ãƒˆãŒæ­£ã—ãåˆ¤å®šã•ã‚Œã‚‹
- [ ] 2ç¨®é¡ã®æ”»æ’ƒã‚¿ã‚¤ãƒ—ã§ç•°ãªã‚‹å¡—ã‚Šæ–¹ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] åŸºæœ¬çš„ãªã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ãŒå‹•ä½œã™ã‚‹

### Phase 2 å®Œäº†æ¡ä»¶ï¼ˆã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼‰
- [ ] å£°ã§è‡ªç”±ã«çµµã‚’æã‘ã‚‹
- [ ] ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢ã§ãã‚‹
- [ ] ã‚¤ãƒ³ã‚¯ã®è‰²ã‚’é¸æŠã§ãã‚‹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- [ ] ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ã§éŠã¹ã‚‹çŠ¶æ…‹ã«ãªã‚‹

### Phase 3 å®Œäº†æ¡ä»¶
- [ ] ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒå‹•ä½œã™ã‚‹
- [ ] ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆãŒå¯èƒ½
- [ ] **ã‚«ãƒ©ãƒ¼ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ãƒ¢ãƒ¼ãƒ‰**ã€å„ªå…ˆåº¦é«˜ã€‘: ãƒ©ãƒ³ãƒ€ãƒ ãªå ´æ‰€ã®è‰²ãŒå¤‰ã‚ã‚Šã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¡—ã£ã¦é˜²ã’ã‚‹
- [ ] **ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´ãƒ¢ãƒ¼ãƒ‰**: ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒç”»é¢ã‚’ç§»å‹•ã—ã€ã‚¤ãƒ³ã‚¯ãŒå½“ãŸã‚‹ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€æ’ƒç ´æ™‚ã«ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã‚‹
- [ ] **ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰**: é€æ˜ãªçµµã®ç·šã‚’ãªãã£ã¦ç‚¹æ•°ã‚’ç²å¾—ã§ãã‚‹
- [ ] **AIå¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰**: AIã¨è‰²å¡—ã‚Šå¯¾æ±ºãŒã§ãã‚‹
- [ ] å„ãƒ¢ãƒ¼ãƒ‰ã§ã‚¹ã‚³ã‚¢ãŒæ­£ã—ãè¨ˆç®—ã•ã‚Œã‚‹
- [ ] ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãŒä¿å­˜ãƒ»è¡¨ç¤ºã•ã‚Œã‚‹

### Phase 4 å®Œäº†æ¡ä»¶
- [ ] ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦ãŒå¯èƒ½ã«ãªã‚‹
- [ ] å¡—ã‚Šãƒ‡ãƒ¼ã‚¿ãŒåŒæœŸã•ã‚Œã‚‹
- [ ] ãƒãƒƒãƒãƒ¡ã‚¤ã‚­ãƒ³ã‚°ãŒå‹•ä½œã™ã‚‹

### Phase 5 å®Œäº†æ¡ä»¶
- [ ] ã‚²ãƒ¼ãƒ ç”»é¢ã«å¿…è¦ãªUIãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰å„ãƒ¢ãƒ¼ãƒ‰ã«é·ç§»ã§ãã‚‹
- [ ] è¨­å®šãŒä¿å­˜ãƒ»èª­ã¿è¾¼ã¾ã‚Œã‚‹

### Phase 6 å®Œäº†æ¡ä»¶
- [ ] ã‚¤ãƒ³ã‚¯ã®è‰²ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹
- [ ] ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã§ãã‚‹
- [ ] ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºè¨­å®šãŒä¿å­˜ã•ã‚Œã‚‹

### Phase 7 å®Œäº†æ¡ä»¶
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ãŒå®Œäº†ã—ã¦ã„ã‚‹
- [ ] ãƒã‚°ãŒä¿®æ­£ã•ã‚Œã¦ã„ã‚‹

### Phase 8 å®Œäº†æ¡ä»¶ï¼ˆæœ€ã‚‚ä½ã„å„ªå…ˆé †ä½ï¼‰
- [ ] è¤‡æ•°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§å¯¾æˆ¦ã§ãã‚‹
- [ ] å¡—ã‚Šé¢ç©ãŒæ­£ã—ãè¨ˆç®—ã•ã‚Œã‚‹
- [ ] åˆ¶é™æ™‚é–“çµ‚äº†æ™‚ã«å‹åˆ©åˆ¤å®šãŒè¡Œã‚ã‚Œã‚‹
- [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒãƒ«ãƒãŒå‹•ä½œã™ã‚‹


