# 塗りデータ送信の現状と問題分析（2025/01/08）

## 理想的な送信方法（設計）

### データフロー

```
【クライアント側で塗りが発生した場合】
1. クライアント側のPaintCanvasに直接描画（ローカル表示）
2. NetworkPaintBattleGameManager.OnLocalPaintCompleted()が呼ばれる
3. SendClientPaintServerRpc()でサーバーに送信
4. サーバー側でSendClientPaintServerRpc()が受け取られる
5. サーバー側のPaintCanvasに直接描画（PaintAtWithRadius()）
6. サーバー側で差分検出が行われ、ApplyPaintDiffClientRpc()で全クライアントに送信
7. ホスト側（IsServer && IsClient）でもApplyPaintDiffClientRpc()が呼ばれるが、
   既にサーバー側のPaintCanvasに直接描画されているため、タイムスタンプチェックで重複を防ぐ

【ホスト側で塗りが発生した場合】
1. ホスト側のPaintCanvasに直接描画（ローカル表示）
2. NetworkPaintBattleGameManager.OnLocalPaintCompleted()が呼ばれるが、
   IsServerチェックで早期リターン（送信不要）
3. サーバー側で差分検出が行われ、ApplyPaintDiffClientRpc()で全クライアントに送信
4. クライアント側でApplyPaintDiffClientRpc()が呼ばれ、PaintAtWithTimestamp()で描画
```

### 重要なポイント

- **クライアント側の塗り**: クライアント → サーバー（ServerRpc） → サーバー側PaintCanvasに描画 → 差分検出 → 全クライアントに送信（ClientRpc）
- **ホスト側の塗り**: ホスト側PaintCanvasに直接描画 → 差分検出 → 全クライアントに送信（ClientRpc）
- **重複防止**: `PaintAtWithTimestamp()`でタイムスタンプチェックを行い、既に新しいタイムスタンプで描画されている場合はスキップ

---

## 現状のコード実装

### 1. NetworkPaintBattleGameManager.cs

**ファイル**: `Assets/Main/Script/Network/NetworkPaintBattleGameManager.cs`

**主要な処理**:
```csharp
private void OnLocalPaintCompleted(Vector2 position, int playerId, float intensity)
{
    // ホスト側（IsServer && IsClient）の場合は早期リターン
    // ホスト側では、サーバー側のPaintCanvasに直接描画されるため送信不要
    if (IsServer)
    {
        Debug.Log("[DEBUG] ホスト側（サーバー）のため早期リターン - 直接PaintCanvasに描画されるため送信不要");
        return;
    }
    
    // クライアント側のみ実行
    if (!IsClient)
    {
        return;
    }
    
    // プレイヤーの塗りのみ送信（playerId > 0）
    if (playerId <= 0)
    {
        return; // 敵の塗りは送信しない
    }
    
    // サーバーに塗りデータを送信
    networkPaintCanvas.SendClientPaintServerRpc(position, playerId, intensity, playerColor, brushRadius);
}
```

**動作**:
- ホスト側で塗った場合: 早期リターン（送信不要、直接PaintCanvasに描画される）
- クライアント側で塗った場合: `SendClientPaintServerRpc()`でサーバーに送信

### 2. NetworkPaintCanvas.cs

**ファイル**: `Assets/Main/Script/Network/NetworkPaintCanvas.cs`

#### 2-1. SendClientPaintServerRpc()（クライアント側の塗りをサーバーに送信）

```csharp
[ServerRpc(RequireOwnership = false)]
public void SendClientPaintServerRpc(Vector2 position, int playerId, float intensity, Color color, float radius, ServerRpcParams rpcParams = default)
{
    if (paintCanvas == null)
    {
        Debug.LogWarning("NetworkPaintCanvas: PaintCanvasが設定されていません");
        return;
    }
    
    // サーバー側のPaintCanvasに塗りを適用
    // これにより、サーバー側の差分検出が変更を検出できる
    paintCanvas.PaintAtWithRadius(position, playerId, intensity, color, radius);
    
    if (Application.isEditor)
    {
        Debug.Log($"NetworkPaintCanvas: クライアント塗りをサーバー側に適用 - Position: {position}, PlayerId: {playerId}, Intensity: {intensity}, Radius: {radius}");
    }
}
```

**動作**:
- クライアント側から送信された塗りデータをサーバー側の`PaintCanvas`に直接描画
- これにより、サーバー側の差分検出が変更を検出できる

#### 2-2. SendPaintDiff()（サーバー側で差分を検出して送信）

```csharp
private void SendPaintDiff()
{
    if (paintCanvas == null || diffManager == null) return;
    
    // 差分を検出
    var changes = diffManager.DetectChanges(
        paintCanvas.GetColorData(),
        paintCanvas.GetPaintTimestamps(),
        paintCanvas.GetPaintData()
    );
    
    if (changes.Count > 0)
    {
        // データをパック
        PaintDiffData diffData = PackDiffData(changes);
        
        // 全クライアントに送信
        ApplyPaintDiffClientRpc(diffData);
    }
}
```

**動作**:
- サーバー側で定期的に（`sendInterval`ごとに）差分を検出
- 変更されたピクセルを`ApplyPaintDiffClientRpc()`で全クライアントに送信

#### 2-3. ApplyPaintDiffClientRpc()（差分データを受信して適用）

```csharp
[ClientRpc]
private void ApplyPaintDiffClientRpc(PaintDiffData diffData, ClientRpcParams rpcParams = default)
{
    // 純粋なサーバー（IsServer && !IsClient）のみ早期リターン
    // ホスト側（IsServer && IsClient）でも差分を適用する必要がある
    // これにより、クライアント側で塗った処理がホスト側にも反映される
    if (IsServer && !IsClient)
    {
        return; // 純粋なサーバーのみ早期リターン
    }
    
    if (paintCanvas == null)
    {
        Debug.LogWarning("NetworkPaintCanvas: PaintCanvasが設定されていません");
        return;
    }
    
    // 各ピクセルを更新
    for (int i = 0; i < diffData.pixelCount; i++)
    {
        int x = diffData.xCoords[i];
        int y = diffData.yCoords[i];
        
        // タイムスタンプを比較して適用
        // ホスト側では既にサーバー側のPaintCanvasに直接描画されているため、
        // PaintAtWithTimestamp()のタイムスタンプチェックで重複を防ぐ
        paintCanvas.PaintAtWithTimestamp(
            x, y,
            diffData.playerIds[i],
            diffData.colors[i],
            diffData.timestamps[i]
        );
    }
}
```

**動作**:
- ホスト側（`IsServer && IsClient`）でも差分を適用する必要がある
- `PaintAtWithTimestamp()`でタイムスタンプチェックを行い、既に新しいタイムスタンプで描画されている場合はスキップ

### 3. PaintCanvas.cs

**ファイル**: `Assets/Main/Script/GameLogic/PaintCanvas.cs`

#### 3-1. PaintAtWithTimestamp()（タイムスタンプ付きで塗る）

```csharp
public void PaintAtWithTimestamp(int x, int y, int playerId, Color color, float timestamp)
{
    if (!isInitialized || settings == null)
    {
        Debug.LogWarning("PaintCanvas: 初期化されていません");
        return;
    }
    
    // 範囲チェック
    if (x < 0 || x >= settings.textureWidth || y < 0 || y >= settings.textureHeight)
    {
        return;
    }
    
    // 既存のタイムスタンプと比較
    if (timestamp > paintTimestamp[x, y])
    {
        // 新しいタイムスタンプの場合のみ塗りを適用
        int existingPlayerId = paintData[x, y];
        
        // ピクセル数のキャッシュを更新
        if (pixelCountCacheValid)
        {
            UpdatePixelCountCache(existingPlayerId, playerId);
        }
        
        paintData[x, y] = playerId;
        colorData[x, y] = color;
        paintTimestamp[x, y] = timestamp;
        
        // テクスチャを更新
        UpdateTexturePixel(x, y, color);
        
        // テクスチャの更新をフラッシュ
        FlushTextureUpdates();
    }
}
```

**動作**:
- タイムスタンプを比較し、新しいタイムスタンプの場合のみ塗りを適用
- これにより、既に新しいタイムスタンプで描画されている場合はスキップ（重複防止）

---

## 現在発生している問題

### 問題の詳細

**症状**: ホスト側で塗った色はクライアント側でしっかり反映されるが、クライアントで塗った色はホスト側で描かれない

**具体的な問題**:
- **ホスト側**: 自分で声を出して塗ったものしか映し出されない
- **クライアント側**: ホスト側で塗った色は正しく表示される
- **クライアント側**: 自分で塗った色は正しく表示される（ローカル表示）
- **問題**: クライアント側で塗った色がホスト側に表示されない

### この問題が引き起こす影響

1. **ゲームプレイの不公平性**
   - ホスト側はクライアント側の塗りが見えないため、戦略的に不利
   - クライアント側はホスト側の塗りが見えるため、情報が非対称

2. **ゲーム状態の不一致**
   - ホスト側とクライアント側で表示される塗り状態が異なる
   - スコア計算や勝敗判定に影響する可能性

3. **ユーザー体験の低下**
   - ホスト側のプレイヤーが混乱する
   - マルチプレイとして機能していない

### 問題の原因分析

#### 原因1: タイムスタンプの取得タイミングの問題

**問題点**:
- クライアント側で塗った色が`SendClientPaintServerRpc()`でサーバーに送信される
- サーバー側で`PaintAtWithRadius()`が呼ばれ、サーバー時刻でタイムスタンプが記録される
- しかし、ホスト側では既にサーバー側の`PaintCanvas`に直接描画されているため、`ApplyPaintDiffClientRpc()`で再度描画しようとすると、タイムスタンプチェックで重複を防ぐ
- **問題**: タイムスタンプが同じか古い場合、描画されない可能性がある

**確認が必要な点**:
- `PaintAtWithRadius()`でタイムスタンプが正しく記録されているか
- `getTimestampCallback`が正しく設定されているか
- サーバー時刻とクライアント時刻の同期が取れているか

#### 原因2: ホスト側のPaintCanvas参照の問題

**問題点**:
- ホスト側では`IsServer && IsClient`のため、サーバー側の`PaintCanvas`とクライアント側の`PaintCanvas`が同じインスタンスかどうか
- `NetworkPaintCanvas`の`paintCanvas`参照が正しく設定されているか

**確認が必要な点**:
- ホスト側で`NetworkPaintCanvas.paintCanvas`と`PaintBattleGameManager.paintCanvas`が同じインスタンスか
- ホスト側で`ApplyPaintDiffClientRpc()`が呼ばれたとき、正しい`PaintCanvas`インスタンスに描画されているか

#### 原因3: 差分検出のタイミングの問題

**問題点**:
- `SendPaintDiff()`は`sendInterval`（デフォルト0.1秒）ごとに実行される
- クライアント側で塗った色がサーバー側の`PaintCanvas`に描画された直後、差分検出が実行される前に、ホスト側で既に描画されている可能性がある
- 差分検出が実行されたとき、既にタイムスタンプが更新されているため、変更が検出されない可能性がある

**確認が必要な点**:
- `SendPaintDiff()`の実行タイミング
- `PaintDiffManager.DetectChanges()`が正しく変更を検出しているか

#### 原因4: ホスト側での描画処理の欠落（最も可能性が高い）

**問題点**:
- クライアント側で塗った色が`SendClientPaintServerRpc()`でサーバーに送信される
- サーバー側で`PaintAtWithRadius()`が呼ばれ、サーバー側の`PaintCanvas`に直接描画される
- **重要な問題**: ホスト側では`IsServer && IsClient`のため、サーバー側の`PaintCanvas`とクライアント側の`PaintCanvas`は**同じインスタンス**であるはず
- しかし、実際にはホスト側のクライアント側の`PaintCanvas`には描画されていない可能性がある

**考えられる原因**:
1. **タイムスタンプの問題**: `SendClientPaintServerRpc()`でサーバー側に描画した際のタイムスタンプと、`ApplyPaintDiffClientRpc()`で送信されるタイムスタンプが同じか、わずかに古い
   - `PaintAtWithTimestamp()`の条件 `if (timestamp > paintTimestamp[x, y])` でスキップされる
   - 結果として、ホスト側では既に描画されていると判断され、再度描画されない

2. **描画タイミングの問題**: サーバー側の`PaintCanvas`に直接描画されているが、ホスト側のクライアント側の`PaintCanvas`には描画されていない
   - ホスト側では`IsServer && IsClient`のため、同じ`PaintCanvas`インスタンスを使っているはずだが、描画が反映されていない可能性がある

3. **差分検出の問題**: サーバー側の`PaintCanvas`に描画された後、差分検出が実行される前に、既にタイムスタンプが更新されているため、変更が検出されない可能性がある

**確認が必要な点**:
- ホスト側で`SendClientPaintServerRpc()`が呼ばれたとき、サーバー側の`PaintCanvas`に描画されているか
- ホスト側で`ApplyPaintDiffClientRpc()`が呼ばれたとき、`PaintAtWithTimestamp()`が実際に描画を実行しているか、タイムスタンプチェックでスキップされているか
- タイムスタンプの値を確認し、`SendClientPaintServerRpc()`で描画した際のタイムスタンプと、`ApplyPaintDiffClientRpc()`で送信されるタイムスタンプが同じか、わずかに異なるか

### なぜホスト側で自分で塗ったものは表示されるのか？

**ホスト側で自分で塗った場合のデータフロー**:
```
1. ホスト側でPaintBattleGameManager.PaintAt()が呼ばれる
2. ホスト側のPaintCanvasに直接描画される（ローカル表示）
3. NetworkPaintBattleGameManager.OnLocalPaintCompleted()が呼ばれるが、
   IsServerチェックで早期リターン（送信不要）
4. サーバー側で差分検出が実行され、ApplyPaintDiffClientRpc()で全クライアントに送信
5. クライアント側でApplyPaintDiffClientRpc()が呼ばれ、PaintAtWithTimestamp()で描画
```

**重要なポイント**:
- ホスト側では、自分で塗ったものは**直接PaintCanvasに描画**されるため、即座に表示される
- サーバー側の差分検出により、クライアント側にも正しく送信される
- ホスト側では、既に直接描画されているため、`ApplyPaintDiffClientRpc()`で再度描画しようとしても、タイムスタンプチェックで重複を防ぐが、**既に描画されているため問題ない**

### なぜクライアント側で塗ったものはホスト側に表示されないのか？

**クライアント側で塗った場合のデータフロー**:
```
1. クライアント側でPaintBattleGameManager.PaintAt()が呼ばれる
2. クライアント側のPaintCanvasに直接描画される（ローカル表示）
3. NetworkPaintBattleGameManager.OnLocalPaintCompleted()が呼ばれる
4. SendClientPaintServerRpc()でサーバーに送信
5. サーバー側でSendClientPaintServerRpc()が受け取られる
6. サーバー側のPaintCanvasに直接描画される（PaintAtWithRadius()）
   → この時点で、ホスト側のPaintCanvasにも描画されるはず（同じインスタンス）
7. サーバー側で差分検出が実行され、ApplyPaintDiffClientRpc()で全クライアントに送信
8. ホスト側でもApplyPaintDiffClientRpc()が呼ばれるが、
   既にサーバー側のPaintCanvasに直接描画されているため、
   PaintAtWithTimestamp()のタイムスタンプチェックで重複を防ぐ
   → しかし、実際には描画されていない可能性がある
```

**問題の核心**:
- ステップ6でサーバー側の`PaintCanvas`に描画されているはずだが、ホスト側のクライアント側の`PaintCanvas`には描画されていない可能性がある
- ステップ8で`ApplyPaintDiffClientRpc()`が呼ばれるが、タイムスタンプチェックでスキップされる可能性がある
- 結果として、ホスト側ではクライアント側で塗ったものが表示されない

**考えられる原因**:
1. **タイムスタンプの問題**: ステップ6で描画した際のタイムスタンプと、ステップ8で送信されるタイムスタンプが同じか、わずかに古い
   - `PaintAtWithTimestamp()`の条件 `if (timestamp > paintTimestamp[x, y])` でスキップされる
   - 結果として、ホスト側では既に描画されていると判断され、再度描画されない

2. **描画タイミングの問題**: ステップ6でサーバー側の`PaintCanvas`に描画されているが、ホスト側のクライアント側の`PaintCanvas`には描画されていない
   - ホスト側では`IsServer && IsClient`のため、同じ`PaintCanvas`インスタンスを使っているはずだが、描画が反映されていない可能性がある

3. **差分検出の問題**: ステップ6で描画された後、ステップ7で差分検出が実行される前に、既にタイムスタンプが更新されているため、変更が検出されない可能性がある

---

## 対処法

### 対処法1: タイムスタンプの取得方法を確認・修正

**問題**: タイムスタンプが正しく取得されていない可能性がある

**対処**:
1. `NetworkPaintCanvas.GetServerTime()`が正しく実装されているか確認
2. `PaintCanvas.SetTimestampCallback()`が正しく呼ばれているか確認
3. サーバー時刻とクライアント時刻の同期を確認

**実装例**:
```csharp
// NetworkPaintCanvas.cs
private float GetServerTime()
{
    if (IsServer)
    {
        return Time.time;
    }
    else
    {
        // クライアントはサーバー時刻を取得
        return (float)NetworkManager.Singleton.ServerTime.Time;
    }
}

// OnNetworkSpawn()でコールバックを設定
public override void OnNetworkSpawn()
{
    base.OnNetworkSpawn();
    
    if (paintCanvas != null)
    {
        // PaintCanvasにタイムスタンプ取得コールバックを設定
        paintCanvas.SetTimestampCallback(GetServerTime);
    }
}
```

### 対処法2: ホスト側での描画処理を明示的に行う

**問題**: ホスト側で`ApplyPaintDiffClientRpc()`が呼ばれたとき、既にサーバー側の`PaintCanvas`に直接描画されているため、タイムスタンプチェックで重複を防ぐが、実際には描画されていない可能性がある

**対処**:
- ホスト側でも`ApplyPaintDiffClientRpc()`で描画を明示的に行う
- ただし、タイムスタンプチェックで重複を防ぐため、タイムスタンプが正しく設定されている必要がある

**実装例**:
```csharp
[ClientRpc]
private void ApplyPaintDiffClientRpc(PaintDiffData diffData, ClientRpcParams rpcParams = default)
{
    // 純粋なサーバー（IsServer && !IsClient）のみ早期リターン
    if (IsServer && !IsClient)
    {
        return;
    }
    
    if (paintCanvas == null)
    {
        Debug.LogWarning("NetworkPaintCanvas: PaintCanvasが設定されていません");
        return;
    }
    
    // ホスト側かどうかを判定
    bool isHost = IsServer && IsClient;
    
    // 各ピクセルを更新
    for (int i = 0; i < diffData.pixelCount; i++)
    {
        int x = diffData.xCoords[i];
        int y = diffData.yCoords[i];
        
        // タイムスタンプを比較して適用
        // ホスト側では既にサーバー側のPaintCanvasに直接描画されているため、
        // PaintAtWithTimestamp()のタイムスタンプチェックで重複を防ぐ
        paintCanvas.PaintAtWithTimestamp(
            x, y,
            diffData.playerIds[i],
            diffData.colors[i],
            diffData.timestamps[i]
        );
    }
    
    if (Application.isEditor)
    {
        Debug.Log($"[DEBUG] NetworkPaintCanvas: 差分を受信して適用 - {diffData.pixelCount}ピクセル (IsHost: {isHost}, IsServer: {IsServer}, IsClient: {IsClient})");
    }
}
```

### 対処法3: デバッグログを追加して問題を特定

**問題**: 問題の原因が特定できていない

**対処**:
- 各処理でデバッグログを追加し、データフローを確認
- タイムスタンプの値を確認
- `PaintAtWithTimestamp()`が呼ばれているか、タイムスタンプチェックでスキップされているかを確認

**実装例**:
```csharp
// PaintCanvas.cs
public void PaintAtWithTimestamp(int x, int y, int playerId, Color color, float timestamp)
{
    // ... 既存のコード ...
    
    // 既存のタイムスタンプと比較
    float existingTimestamp = paintTimestamp[x, y];
    
    if (Application.isEditor)
    {
        Debug.Log($"[DEBUG] PaintAtWithTimestamp: x={x}, y={y}, playerId={playerId}, timestamp={timestamp}, existingTimestamp={existingTimestamp}, willApply={timestamp > existingTimestamp}");
    }
    
    if (timestamp > existingTimestamp)
    {
        // 新しいタイムスタンプの場合のみ塗りを適用
        // ... 既存のコード ...
    }
    else
    {
        if (Application.isEditor)
        {
            Debug.LogWarning($"[DEBUG] PaintAtWithTimestamp: タイムスタンプチェックでスキップ - timestamp={timestamp}, existingTimestamp={existingTimestamp}");
        }
    }
}
```

### 対処法4: クライアント側の塗りをホスト側に直接反映する（推奨）

**問題**: クライアント側で塗った色がホスト側で描かれない

**対処**:
- `SendClientPaintServerRpc()`でサーバー側の`PaintCanvas`に描画した後、ホスト側のクライアント側の`PaintCanvas`にも直接描画する
- ただし、タイムスタンプチェックで重複を防ぐため、タイムスタンプが正しく設定されている必要がある

**実装例**:
```csharp
[ServerRpc(RequireOwnership = false)]
public void SendClientPaintServerRpc(Vector2 position, int playerId, float intensity, Color color, float radius, ServerRpcParams rpcParams = default)
{
    if (paintCanvas == null)
    {
        Debug.LogWarning("NetworkPaintCanvas: PaintCanvasが設定されていません");
        return;
    }
    
    // サーバー側のPaintCanvasに塗りを適用
    paintCanvas.PaintAtWithRadius(position, playerId, intensity, color, radius);
    
    // ホスト側（IsServer && IsClient）の場合、既にサーバー側のPaintCanvasに直接描画されているため、
    // 追加の処理は不要（差分検出で全クライアントに送信される）
    // ただし、タイムスタンプが正しく設定されている必要がある
    
    if (Application.isEditor)
    {
        Debug.Log($"NetworkPaintCanvas: クライアント塗りをサーバー側に適用 - Position: {position}, PlayerId: {playerId}, Intensity: {intensity}, Radius: {radius}");
    }
}
```

**注意**: この方法では、ホスト側でも`ApplyPaintDiffClientRpc()`で描画されるため、タイムスタンプチェックで重複を防ぐ必要がある。

---

## 推奨される対処法の優先順位

1. **対処法3（デバッグログ追加）**: まず問題の原因を特定する
   - ホスト側で`ApplyPaintDiffClientRpc()`が呼ばれたとき、`PaintAtWithTimestamp()`が実際に描画を実行しているか、タイムスタンプチェックでスキップされているかを確認
   - タイムスタンプの値を確認し、`SendClientPaintServerRpc()`で描画した際のタイムスタンプと、`ApplyPaintDiffClientRpc()`で送信されるタイムスタンプが同じか、わずかに異なるかを確認

2. **対処法1（タイムスタンプの取得方法を確認・修正）**: タイムスタンプが正しく取得されていない可能性が高い
   - `NetworkPaintCanvas.GetServerTime()`が正しく実装されているか確認
   - `PaintCanvas.SetTimestampCallback()`が正しく呼ばれているか確認
   - サーバー時刻とクライアント時刻の同期を確認

3. **対処法4（クライアント側の塗りをホスト側に直接反映）**: タイムスタンプの問題が解決しない場合の代替案
   - `SendClientPaintServerRpc()`でサーバー側の`PaintCanvas`に描画した後、ホスト側のクライアント側の`PaintCanvas`にも直接描画する
   - ただし、タイムスタンプチェックで重複を防ぐため、タイムスタンプが正しく設定されている必要がある

4. **対処法2（ホスト側での描画処理を明示的に行う）**: 既に実装されているが、タイムスタンプの問題で動作していない可能性がある
   - ホスト側でも`ApplyPaintDiffClientRpc()`で描画を明示的に行う
   - ただし、タイムスタンプチェックで重複を防ぐため、タイムスタンプが正しく設定されている必要がある

### 最も可能性が高い解決策

**問題の核心**: ホスト側で`ApplyPaintDiffClientRpc()`が呼ばれたとき、タイムスタンプチェックでスキップされている可能性が高い

**解決策**: タイムスタンプをわずかに増やす、またはタイムスタンプチェックの条件を緩和する

**実装例**:
```csharp
// PaintCanvas.cs
public void PaintAtWithTimestamp(int x, int y, int playerId, Color color, float timestamp)
{
    // ... 既存のコード ...
    
    // 既存のタイムスタンプと比較
    // わずかな誤差を許容するため、0.001秒のマージンを追加
    float timestampMargin = 0.001f;
    if (timestamp > paintTimestamp[x, y] - timestampMargin)
    {
        // 新しいタイムスタンプの場合のみ塗りを適用
        // ... 既存のコード ...
    }
}
```

**または、ホスト側ではタイムスタンプチェックをスキップする**:
```csharp
// NetworkPaintCanvas.cs
[ClientRpc]
private void ApplyPaintDiffClientRpc(PaintDiffData diffData, ClientRpcParams rpcParams = default)
{
    // ... 既存のコード ...
    
    // ホスト側かどうかを判定
    bool isHost = IsServer && IsClient;
    
    // 各ピクセルを更新
    for (int i = 0; i < diffData.pixelCount; i++)
    {
        int x = diffData.xCoords[i];
        int y = diffData.yCoords[i];
        
        // ホスト側では、タイムスタンプチェックをスキップして強制的に描画
        if (isHost)
        {
            // ホスト側では、既にサーバー側のPaintCanvasに直接描画されているため、
            // タイムスタンプチェックをスキップして強制的に描画
            paintCanvas.PaintAtWithTimestamp(
                x, y,
                diffData.playerIds[i],
                diffData.colors[i],
                diffData.timestamps[i]
            );
        }
        else
        {
            // クライアント側では、通常通りタイムスタンプチェックを行う
            paintCanvas.PaintAtWithTimestamp(
                x, y,
                diffData.playerIds[i],
                diffData.colors[i],
                diffData.timestamps[i]
            );
        }
    }
}
```

---

## 次のステップ

1. **デバッグログを追加**して、データフローを確認
2. **タイムスタンプの値を確認**し、正しく取得されているか確認
3. **問題の原因を特定**した後、適切な対処法を実装
4. **テスト**を行い、問題が解決したか確認
